









<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            <div class="post-head-wrapper-text-only"
                 style="background-image: url('')">
                <div class="post-title">
                    React 源码学习（十）：Fiber
                    <div class="post-meta">
                        <time datetime="2019-12-19T15:00:25.000Z" itemprop="datePublished">
                            2019-12-19 15:00
                        </time>&nbsp;
                        
                        
                        <i class="material-icons" style="">folder</i>
                        
                        <a href='/categories/React-源码学习/'>React 源码学习</a>
                        
                        
    
                        
                        
                        <i class="material-icons" style="">label</i>
                        
                        <a href='/tags/React/'>React</a>
                        
                        
                    </div>
                </div>
            </div>
    
            <div class="post-body-wrapper">
                <div class="post-body">
                    <!-- no node -->

<span id="more"></span>

<blockquote>
<p>继 <code>0.3-stable</code> （以下简称 v0.3）后，这里开始将解读 <code>16.8.6</code> （以下简称 v16.8.6）版本，此版本上标签于 2019 年 3 月 28 日。<br>那么接下来，我将从几个方面来解读这个版本的源码。（目录含有 v0.3 ）</p>
</blockquote>
<ol>
<li><a href="https://zongzi531.com/2019/04/01/LSC-React-01/">React 源码学习（一）：HTML 元素渲染</a></li>
<li><a href="https://zongzi531.com/2019/04/02/LSC-React-02/">React 源码学习（二）：HTML 子元素渲染</a></li>
<li><a href="https://zongzi531.com/2019/04/03/LSC-React-03/">React 源码学习（三）：CSS 样式及 DOM 属性</a></li>
<li><a href="https://zongzi531.com/2019/04/04/LSC-React-04/">React 源码学习（四）：事务机制</a></li>
<li><a href="https://zongzi531.com/2019/04/05/LSC-React-05/">React 源码学习（五）：事件机制</a></li>
<li><a href="https://zongzi531.com/2019/04/06/LSC-React-06/">React 源码学习（六）：组件渲染</a></li>
<li><a href="https://zongzi531.com/2019/04/07/LSC-React-07/">React 源码学习（七）：生命周期</a></li>
<li><a href="https://zongzi531.com/2019/04/08/LSC-React-08/">React 源码学习（八）：组件更新</a></li>
<li><a href="https://zongzi531.com/2019/12/18/LSC-React-09/">React 源码学习（九）：“脱胎换骨”</a></li>
<li><a href="https://zongzi531.com/2019/12/19/LSC-React-10/">React 源码学习（十）：Fiber</a></li>
<li><a href="https://zongzi531.com/2019/12/20/LSC-React-11/">React 源码学习（十一）：Scheduling</a></li>
<li><a href="https://zongzi531.com/2019/12/21/LSC-React-12/">React 源码学习（十二）：Reconciliation</a></li>
</ol>
<h2 id="什么是-Fiber-？"><a href="#什么是-Fiber-？" class="headerlink" title="什么是 Fiber ？"></a>什么是 Fiber ？</h2><p>Fiber 是 React 16 中新的协调引擎。他的主要目的是使 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/faq-internals.html#what-is-the-virtual-dom">Virtual DOM</a> 可以进行增量式渲染。**<a target="_blank" rel="noopener" href="https://github.com/acdlite/react-fiber-architecture">了解更多</a>**</p>
<blockquote>
<p>建议阅读<strong>了解更多</strong>来理解 Fiber ，或者阅读译文<a target="_blank" rel="noopener" href="https://juejin.im/post/5ddb722cf265da7e264736a0">《【翻译】React Fiber 架构》</a>了解。</p>
</blockquote>
<p>从数据结构来理解 Fiber ，他其实是一个链表数据结构，分别通过 <code>return</code> ， <code>child</code> ， <code>sibling</code> 连接着另一个 Fiber 。同样的也可以通过 <code>nextEffect</code> 通往下一个副作用 Fiber ，或是通过 <code>firstEffect</code> 或 <code>lastEffect</code> 跳转到第一个或最后一个副作用 Fiber 。接下来，让我们看到源码：</p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">export</span> type Fiber <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">|</span>
  <span class="token comment" spellcheck="true">// Fiber 标签，用于判断 Fiber 类型</span>
  tag<span class="token punctuation">:</span> WorkTag<span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 唯一标识</span>
  key<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> string<span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 元素类型，协调时使用</span>
  <span class="token comment" spellcheck="true">// 检索源码可以发现 elementType 有存在与 type 、 String 类型、 ReactSymbols 进行比较</span>
  elementType<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 类型</span>
  type<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 本地状态</span>
  stateNode<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 父级 Fiber</span>
  <span class="token keyword">return</span><span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 单链列表树结构。</span>
  <span class="token comment" spellcheck="true">// 子 Fiber</span>
  child<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 兄弟 Fiber</span>
  sibling<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 当前索引</span>
  index<span class="token punctuation">:</span> number<span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// ref 引用支持 callback 函数或者 React.createRef</span>
  ref<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>handle<span class="token punctuation">:</span> mixed<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>_stringRef<span class="token punctuation">:</span> <span class="token operator">?</span>string<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token operator">|</span> RefObject<span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 更新时等待的 props</span>
  pendingProps<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 创建时使用的 props</span>
  memoizedProps<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 更新队列，即协调时使用</span>
  updateQueue<span class="token punctuation">:</span> UpdateQueue<span class="token operator">&lt;</span>any<span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 创建时使用的 state</span>
  memoizedState<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 上下文以来链表结构</span>
  contextDependencies<span class="token punctuation">:</span> ContextDependencyList <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 位域，描述有关 Fiber 及其子树的属性。例如， ConcurrentMode 标志指示子树是否应默认为异步。</span>
  <span class="token comment" spellcheck="true">// 创建 Fiber 时，他将继承其父级的模式。可以在创建时设置其他标志，但是此后，该值应在 Fiber 的整个生命周期中保持不变，尤其是在创建其子 Fiber 之前。</span>
  mode<span class="token punctuation">:</span> TypeOfMode<span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 副作用标签</span>
  effectTag<span class="token punctuation">:</span> SideEffectTag<span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 单链表列出了具有副作用的通往下一个 Fiber 的快速路径。</span>
  nextEffect<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 该子树中具有副作用的第一个和最后一个 Fiber 。 当我们重用此 Fiber 中完成的工作时，这使我们可以重用链表的一部分。</span>
  firstEffect<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  lastEffect<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 当前 Fiber 的到期时间，用于调度时排序使用，将到期时间越早的排在越前面进行执行。</span>
  expirationTime<span class="token punctuation">:</span> ExpirationTime<span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// 子的到期时间，用于快速确定子树是否没有挂起的更改。</span>
  childExpirationTime<span class="token punctuation">:</span> ExpirationTime<span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// WorkInProgress 存放处（双缓存技术）</span>
  alternate<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
<span class="token operator">|</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>源码中依然会有一些难以理解的字段内容，但是没关系，相信在看完调度和调和，你会对 Fiber 有更深刻的理解，因为他贯穿在整个调和中。</p>
<p>当然啦，也可以在 <a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/16.8.6/packages/react-reconciler/src/ReactFiber.js">ReactFiber.js</a> 中看到有关 Fiber 创建函数的内容，有兴趣可以点击查看。</p>
<p>同样的，在调和中会认识到一个新的数据结构 <code>FiberRoot</code> ，他和调和密切相关，也可以先通过 <a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/16.8.6/packages/react-reconciler/src/ReactFiberRoot.js">ReactFiberRoot.js</a> 进行了解。</p>
<p>那么后面我们将介绍以 Fiber 为最小单位的时间切片（ Time Slicing ）概念的一种实现：<strong>调度</strong>。</p>

                </div>
            </div>

            
            
            
    
            
    
            
        </div>
    </div>
    
</div>






