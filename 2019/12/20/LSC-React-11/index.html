

<!DOCTYPE html>
<html lang="zh-CN" xmlns:v-bind="http://www.w3.org/1999/xhtml">

<head>
    <title>React 源码学习（十一）：Scheduling - Zong</title>
<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Zong">
<meta name="description" content="




继 0.3-stable （以下简称 v0.3）后，这里开始将解读 16.8.6 （以下简称 v16.8...">
<meta name="keywords" content="Blog JavaScript TypeScript Front-end CSS">

    <meta charset="utf-8">
    <meta name="X-UA-Compatible" content="IE=edge">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta content="telephone=no" name="format-detection">
    <meta name="renderer" content="webkit">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/journal.css?92165319">

<link rel="icon" href="/images/favicon.ico">

<script src="/js/loadCSS.js"></script>
<script>
    loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Material+Icons");
    (function(d) {
        var config = {
        kitId: 'ojl5tfq',
        scriptTimeout: 3000,
        async: true
        },
        h=d.documentElement,t=setTimeout(function(){h.className=h.className.replace(/\bwf-loading\b/g,"")+" wf-inactive";},config.scriptTimeout),tk=d.createElement("script"),f=false,s=d.getElementsByTagName("script")[0],a;h.className+=" wf-loading";tk.src='https://use.typekit.net/'+config.kitId+'.js';tk.async=true;tk.onload=tk.onreadystatechange=function(){a=this.readyState;if(f||a&&a!="complete"&&a!="loaded")return;f=true;clearTimeout(t);try{Typekit.load(config)}catch(e){}};s.parentNode.insertBefore(tk,s)
    })(document);
</script>
<noscript>
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Lora|Montserrat|Anonymous+Pro:400|Material+Icons"/>
</noscript>
<meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="Zong" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-material-oceanic.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
<body>
<div id="top"></div>
<div id="app">
<div class="single-column-drawer-container" ref="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            <a class="a-block drawer-menu-item false" href="https://zongzi531.com">
                首页
            </a>
            

            
            
                
                    <a class="a-block drawer-menu-item false" href="/bangumi/index.html">
                        番組
                    </a>
                
            
                
                    <a class="a-block drawer-menu-item false" href="/commuting/index.html">
                        通勤那点事
                    </a>
                
            
                
            
                
            
                
            
                
                    <a class="a-block drawer-menu-item false" href="/nihongonokona/index.html">
                        日本語のコーナー
                    </a>
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
                    <a class="a-block drawer-menu-item false" href="/syoukai/index.html">
                        紹介
                    </a>
                
            
                
            
                
            

            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="/">
            Zong
        </a>
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="/">
        <div class="single-column-header-title">Zong</div>
        <div class="single-column-header-subtitle"></div>
    </a>
</div>
<div ref="sideContainer" class="side-container">
    <a class="a-block nav-head false" href="/">
        <div class="nav-title">
            Zong
        </div>
        <div class="nav-subtitle">
            人之所以能<br>，是相信能
        </div>
    </a>

    <div class="nav-link-list">
        

        
        
            
                <a class="a-block nav-link-item false" href="/bangumi/index.html">
                    番組
                </a>
            
        
            
                <a class="a-block nav-link-item false" href="/commuting/index.html">
                    通勤那点事
                </a>
            
        
            
        
            
        
            
        
            
                <a class="a-block nav-link-item false" href="/nihongonokona/index.html">
                    日本語のコーナー
                </a>
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
                <a class="a-block nav-link-item false" href="/syoukai/index.html">
                    紹介
                </a>
            
        
            
        
            
        

        
    </div>

    <div class="nav-footer">
        <div style="margin-bottom: 8px;">
            <a title="GitHub" target="_blank" rel="noopener" href="https://github.com/zongzi531" style="margin: 0px 2px;"><svg height="16" width="16" viewBox="0 0 16 16" version="1.1" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg></a>
            <a title="知乎" target="_blank" rel="noopener" href="https://www.zhihu.com/people/zongzi531/posts" style="margin: 0px 2px;"><img height="16" src="https://static.zhihu.com/static/favicon.ico"></a>
            <a title="掘金" target="_blank" rel="noopener" href="https://juejin.im/user/58747cf2ac502e00646e3b8b/posts" style="margin: 0px 2px;"><img height="16" src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/favicon-32x32.png"></a>
            <a title="力扣" target="_blank" rel="noopener" href="https://leetcode-cn.com/u/zongzi0531/" style="margin: 0px 2px;"><img height="16" src="https://static.leetcode-cn.com/cn-assets/icons/favicon-32x32.png"></a>
        </div>
        &copy; 2017 - 2023 <a href="https://zongzi531.com">Zong</a>
    </div>
</div>
<div ref="extraContainer" class="extra-container">
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>

        
    </div>
</div>



<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            <div class="post-head-wrapper-text-only"
                 style="background-image: url('')">
                <div class="post-title">
                    React 源码学习（十一）：Scheduling
                    <div class="post-meta">
                        <time datetime="2019-12-20T00:05:33.000Z" itemprop="datePublished">
                            2019-12-20 00:05
                        </time>&nbsp;
                        
                        
                        <i class="material-icons" style="">folder</i>
                        
                        <a href='/categories/React-源码学习/'>React 源码学习</a>
                        
                        
    
                        
                        
                        <i class="material-icons" style="">label</i>
                        
                        <a href='/tags/React/'>React</a>
                        
                        
                    </div>
                </div>
            </div>
    
            <div class="post-body-wrapper">
                <div class="post-body">
                    <!-- no node -->

<span id="more"></span>

<blockquote>
<p>继 <code>0.3-stable</code> （以下简称 v0.3）后，这里开始将解读 <code>16.8.6</code> （以下简称 v16.8.6）版本，此版本上标签于 2019 年 3 月 28 日。<br>那么接下来，我将从几个方面来解读这个版本的源码。（目录含有 v0.3 ）</p>
</blockquote>
<ol>
<li><a href="https://zongzi531.com/2019/04/01/LSC-React-01/">React 源码学习（一）：HTML 元素渲染</a></li>
<li><a href="https://zongzi531.com/2019/04/02/LSC-React-02/">React 源码学习（二）：HTML 子元素渲染</a></li>
<li><a href="https://zongzi531.com/2019/04/03/LSC-React-03/">React 源码学习（三）：CSS 样式及 DOM 属性</a></li>
<li><a href="https://zongzi531.com/2019/04/04/LSC-React-04/">React 源码学习（四）：事务机制</a></li>
<li><a href="https://zongzi531.com/2019/04/05/LSC-React-05/">React 源码学习（五）：事件机制</a></li>
<li><a href="https://zongzi531.com/2019/04/06/LSC-React-06/">React 源码学习（六）：组件渲染</a></li>
<li><a href="https://zongzi531.com/2019/04/07/LSC-React-07/">React 源码学习（七）：生命周期</a></li>
<li><a href="https://zongzi531.com/2019/04/08/LSC-React-08/">React 源码学习（八）：组件更新</a></li>
<li><a href="https://zongzi531.com/2019/12/18/LSC-React-09/">React 源码学习（九）：“脱胎换骨”</a></li>
<li><a href="https://zongzi531.com/2019/12/19/LSC-React-10/">React 源码学习（十）：Fiber</a></li>
<li><a href="https://zongzi531.com/2019/12/20/LSC-React-11/">React 源码学习（十一）：Scheduling</a></li>
<li><a href="https://zongzi531.com/2019/12/21/LSC-React-12/">React 源码学习（十二）：Reconciliation</a></li>
</ol>
<blockquote>
<p>由于文中含有代码较多，建议收藏再做阅读</p>
</blockquote>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><blockquote>
<p>摘录自<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/design-principles.html#scheduling">官网</a></p>
</blockquote>
<p>即便你的组件以 function 的方式声明，在 React 中你也并不会直接调用他们。每个组件返回一个该渲染什么的描述，该描述会包含开发者写的组件如 <code>&lt;LikeButton&gt;</code> 和 平台特定的组件如 <code>&lt;div&gt;</code>。由 React 决定在未来的某个时间点展开 <code>&lt;LikeButton&gt;</code>，并根据组件的渲染结果递归地把这些变更实际应用到 UI 树上。</p>
<p>虽然只是微小的区别，但这样做意义重大。因为你不需要调用组件方法而是让 React 调用他，这意味着如果必要 React 可以延迟调用。在 React 当前的实现中，React 在单个 tick 周期中递归地走完这棵树，然后调用整个更新后树的渲染方法。但是以后 React 可能会<a target="_blank" rel="noopener" href="https://github.com/facebook/react/issues/6170">延迟一些更新操作来防止掉帧</a>。</p>
<p>这在 React 的设计中很常见。有一些流行的库实现了 “push” 模式，即当新数据到达时再计算。然而 React 坚持 “pull” 模式，即计算可以延迟到必要时再执行。</p>
<p>React 不是一个常规的数据处理库，他是开发用户界面的库。我们认为 React 在一个应用中的位置很独特，他知道当前哪些计算当前是相关的，哪些不是。</p>
<p>如果不在当前屏幕，我们可以延迟执行相关逻辑。如果数据数据到达的速度快过帧速，我们可以合并、批量更新。我们优先执行用户交互（例如按钮点击形成的动画）的工作，延后执行相对不那么重要的后台工作（例如渲染刚从网络上下载的新内容），从而避免掉帧。</p>
<p>要清楚我们现在还没有利用调度。然而，我们之所以偏好自己控制调度以及异步setState()，是因为拥有了选择的自由度。</p>
<p>如果我们允许用户使用在一些变体的函数反应式编程范式中常见的“推”模式直接拼接视图，我们将会很难获得调度的控制权。</p>
<p>React 的一个关键目标是在把控制权转交给 React 之前执行的用户代码量最少。这确保 React 保持调度的能力，并根据他所知道的 UI 的情况把工作切分成小块处理。</p>
<p>在团队内部有个笑话，React 本该叫做“调度”因为 React 不想变得完全“反应式（reactive）”。</p>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>让我们从代码的角度来看 Scheduling ，看到 <a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/16.8.6/packages/scheduler/src/Scheduler.js">Scheduler.js</a> 文件，接下来将分段进行解读：</p>
<p>打开文件一进入眼帘的就是 5 个优先级以及对应的超时时间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">ImmediatePriority</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">UserBlockingPriority</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">NormalPriority</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">LowPriority</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IdlePriority</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">IMMEDIATE_PRIORITY_TIMEOUT</span> = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">USER_BLOCKING_PRIORITY</span> = <span class="number">250</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">NORMAL_PRIORITY_TIMEOUT</span> = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">LOW_PRIORITY_TIMEOUT</span> = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">IDLE_PRIORITY</span> = maxSigned31BitInt;</span><br></pre></td></tr></table></figure>

<p>顾名思义，通过名字你就可以知道 <code>ImmediatePriority</code> 优先级最高， <code>IdlePriority</code> 优先级最低。再来让我们认识一下模块中的全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于存储回调函数的循环双向链表，链表头</span></span><br><span class="line"><span class="keyword">var</span> firstCallbackNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currentDidTimeout = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// Pausing the scheduler is useful for debugging.</span></span><br><span class="line"><span class="keyword">var</span> isSchedulerPaused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currentPriorityLevel = <span class="title class_">NormalPriority</span>;</span><br><span class="line"><span class="keyword">var</span> currentEventStartTime = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> currentExpirationTime = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is set when a callback is being executed, to prevent re-entrancy.</span></span><br><span class="line"><span class="keyword">var</span> isExecutingCallback = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hasNativePerformanceNow =</span><br><span class="line">  <span class="keyword">typeof</span> performance === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> performance.<span class="property">now</span> === <span class="string">&#x27;function&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>还是比较好理解的，同样通过名称和注释就能理解。接下来，让我们看到代码，先让我们看到 <code>flushFirstCallback</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushFirstCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 获取链表头，视为需要被执行回调函数的节点</span></span><br><span class="line">  <span class="keyword">var</span> flushedNode = firstCallbackNode;</span><br><span class="line">  <span class="comment">// 获取链表头的下一个节点</span></span><br><span class="line">  <span class="keyword">var</span> next = firstCallbackNode.<span class="property">next</span>;</span><br><span class="line">  <span class="keyword">if</span> (firstCallbackNode === next) &#123;</span><br><span class="line">    <span class="comment">// 若链表头（当前节点）与下一个节点相等的话，说明当前节点也是链表的最后一个节点，操作链表清空</span></span><br><span class="line">    firstCallbackNode = <span class="literal">null</span>;</span><br><span class="line">    next = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则连接链表头的前一个节点和后一个节点</span></span><br><span class="line">    <span class="comment">// 并将链表头的下一个节点更新为 firstCallbackNode 用做起始节点</span></span><br><span class="line">    <span class="keyword">var</span> lastCallbackNode = firstCallbackNode.<span class="property">previous</span>;</span><br><span class="line">    firstCallbackNode = lastCallbackNode.<span class="property">next</span> = next;</span><br><span class="line">    next.<span class="property">previous</span> = lastCallbackNode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除引用</span></span><br><span class="line">  flushedNode.<span class="property">next</span> = flushedNode.<span class="property">previous</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now it&#x27;s safe to call the callback.</span></span><br><span class="line">  <span class="keyword">var</span> callback = flushedNode.<span class="property">callback</span>;</span><br><span class="line">  <span class="keyword">var</span> expirationTime = flushedNode.<span class="property">expirationTime</span>;</span><br><span class="line">  <span class="keyword">var</span> priorityLevel = flushedNode.<span class="property">priorityLevel</span>;</span><br><span class="line">  <span class="comment">// 暂时缓存全局变量中的 currentPriorityLevel 和 currentExpirationTime 的值，在 finally 中进行还原</span></span><br><span class="line">  <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">  <span class="keyword">var</span> previousExpirationTime = currentExpirationTime;</span><br><span class="line">  currentPriorityLevel = priorityLevel;</span><br><span class="line">  currentExpirationTime = expirationTime;</span><br><span class="line">  <span class="keyword">var</span> continuationCallback;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试执行回调函数，并获取回调函数返回值，用于稍后操作</span></span><br><span class="line">    continuationCallback = <span class="title function_">callback</span>();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 还原</span></span><br><span class="line">    currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">    currentExpirationTime = previousExpirationTime;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回值依然是函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> continuationCallback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建循环双向链表节点，优先级和到期时间使用原回调函数值</span></span><br><span class="line">    <span class="keyword">var</span> <span class="attr">continuationNode</span>: <span class="title class_">CallbackNode</span> = &#123;</span><br><span class="line">      <span class="attr">callback</span>: continuationCallback,</span><br><span class="line">      priorityLevel,</span><br><span class="line">      expirationTime,</span><br><span class="line">      <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">previous</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 若循环双向链表已被清空，则这个新节点则是第一个</span></span><br><span class="line">    <span class="keyword">if</span> (firstCallbackNode === <span class="literal">null</span>) &#123;</span><br><span class="line">      firstCallbackNode = continuationNode.<span class="property">next</span> = continuationNode.<span class="property">previous</span> = continuationNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 新节点被插入的位置（插入在之前）</span></span><br><span class="line">      <span class="keyword">var</span> nextAfterContinuation = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 遍历准备</span></span><br><span class="line">      <span class="keyword">var</span> node = firstCallbackNode;</span><br><span class="line">      <span class="comment">// 仅遍历一次，再次遇到头时结束</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 直到被遍历到的节点到期时间大于等于重新创建回调节点的当前时间时，更新 nextAfterContinuation 值，然后退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">expirationTime</span> &gt;= expirationTime) &#123;</span><br><span class="line">          <span class="comment">// 当出现第一个遍历节点的到期时间大于或等于新节点的到期时间的时候，说明新节点需要被插入在之前</span></span><br><span class="line">          nextAfterContinuation = node;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.<span class="property">next</span>;</span><br><span class="line">      &#125; <span class="keyword">while</span> (node !== firstCallbackNode);</span><br><span class="line">      <span class="comment">// 遍历完都没有找到的话，那新节点就是最尾部的节点，所以新节点的后一个就是链表头</span></span><br><span class="line">      <span class="keyword">if</span> (nextAfterContinuation === <span class="literal">null</span>) &#123;</span><br><span class="line">        nextAfterContinuation = firstCallbackNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextAfterContinuation === firstCallbackNode) &#123;</span><br><span class="line">        <span class="comment">// 与上一个逻辑位置一样，只不过优先级是最高，而不是最低</span></span><br><span class="line">        firstCallbackNode = continuationNode;</span><br><span class="line">        <span class="title function_">ensureHostCallbackIsScheduled</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 插入新节点</span></span><br><span class="line">      <span class="keyword">var</span> previous = nextAfterContinuation.<span class="property">previous</span>;</span><br><span class="line">      previous.<span class="property">next</span> = nextAfterContinuation.<span class="property">previous</span> = continuationNode;</span><br><span class="line">      continuationNode.<span class="property">next</span> = nextAfterContinuation;</span><br><span class="line">      continuationNode.<span class="property">previous</span> = previous;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>flushFirstCallback</code> 函数的操作就是执行循环双向链表中到期时间最小（链表头）的回调函数，如果回调函数执行后依然有返回函数，则按照原先的优先级和到期时间重新按照到期时间的降序插入到循环双向链表中。接下来我们看到上面出现的 <code>ensureHostCallbackIsScheduled</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ensureHostCallbackIsScheduled</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 当正在执行回调函数时，退出</span></span><br><span class="line">  <span class="comment">// 通过检索源码可以总结出：</span></span><br><span class="line">  <span class="comment">// - flushImmediateWork 中执行 flushFirstCallback(); 时，满足。</span></span><br><span class="line">  <span class="comment">// - flushWork 中执行 flushFirstCallback(); 时，满足。</span></span><br><span class="line">  <span class="keyword">if</span> (isExecutingCallback) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> expirationTime = firstCallbackNode.<span class="property">expirationTime</span>;</span><br><span class="line">  <span class="keyword">if</span> (!isHostCallbackScheduled) &#123;</span><br><span class="line">    isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 若当前正在主机回调，则取消，重置相关内容</span></span><br><span class="line">    <span class="title function_">cancelHostCallback</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发起主机回调请求</span></span><br><span class="line">  <span class="title function_">requestHostCallback</span>(flushWork, expirationTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止，若已经正在执行主机回调，则先取消，最后再发起主机回调请求，有关主机回调相关，我们先来认识一下模块中的全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scheduledHostCallback = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> isMessageEventScheduled = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> timeoutTime = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isAnimationFrameScheduled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isFlushingHostCallback = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> frameDeadline = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// We start out assuming that we run at 30fps but then the heuristic tracking</span></span><br><span class="line"><span class="comment">// will adjust this value to a faster fps if we get more frequent animation</span></span><br><span class="line"><span class="comment">// frames.</span></span><br><span class="line"><span class="keyword">var</span> previousFrameTime = <span class="number">33</span>;</span><br><span class="line"><span class="keyword">var</span> activeFrameTime = <span class="number">33</span>;</span><br></pre></td></tr></table></figure>

<p>在认识完他们后，我们来看到 <code>requestHostCallback</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">requestHostCallback = <span class="keyword">function</span>(<span class="params">callback, absoluteTimeout</span>) &#123;</span><br><span class="line">  <span class="comment">// 更新至模块中的全局变量</span></span><br><span class="line">  scheduledHostCallback = callback;</span><br><span class="line">  timeoutTime = absoluteTimeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isFlushingHostCallback || absoluteTimeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 消息通道发送消息，有关 Channel Messaging API</span></span><br><span class="line">    port.<span class="title function_">postMessage</span>(<span class="literal">undefined</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isAnimationFrameScheduled) &#123;</span><br><span class="line">    <span class="comment">// 若没有安排动画帧则安排一个</span></span><br><span class="line">    isAnimationFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">requestAnimationFrameWithTimeout</span>(animationTick);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>OK ，读到这里也明白了 <code>requestHostCallback</code> 函数执行内容，将传入回调函数和超时时间更新至模块中的全局变量后，满足条件的情况下进入消息通道监听函数或者是请求动画帧，请求动画帧会涉及到 <code>window.requestAnimationFrame</code> API ，先让我们来看到 Channel Messaging API 相关的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We use the postMessage trick to defer idle work until after the repaint.</span></span><br><span class="line"><span class="keyword">var</span> channel = <span class="keyword">new</span> <span class="title class_">MessageChannel</span>();</span><br><span class="line"><span class="comment">// 对应到 port.postMessage(undefined);</span></span><br><span class="line"><span class="keyword">var</span> port = channel.<span class="property">port2</span>;</span><br><span class="line">channel.<span class="property">port1</span>.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// 进入监听函数</span></span><br><span class="line">  isMessageEventScheduled = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 缓存</span></span><br><span class="line">  <span class="keyword">var</span> prevScheduledCallback = scheduledHostCallback;</span><br><span class="line">  <span class="keyword">var</span> prevTimeoutTime = timeoutTime;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  scheduledHostCallback = <span class="literal">null</span>;</span><br><span class="line">  timeoutTime = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> currentTime = <span class="title function_">getCurrentTime</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> didTimeout = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (frameDeadline - currentTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// There&#x27;s no time left in this idle period. Check if the callback has</span></span><br><span class="line">    <span class="comment">// a timeout and whether it&#x27;s been exceeded.</span></span><br><span class="line">    <span class="keyword">if</span> (prevTimeoutTime !== -<span class="number">1</span> &amp;&amp; prevTimeoutTime &lt;= currentTime) &#123;</span><br><span class="line">      <span class="comment">// Exceeded the timeout. Invoke the callback even though there&#x27;s no</span></span><br><span class="line">      <span class="comment">// time left.</span></span><br><span class="line">      didTimeout = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有超时</span></span><br><span class="line">      <span class="keyword">if</span> (!isAnimationFrameScheduled) &#123;</span><br><span class="line">        <span class="comment">// 若没有安排动画帧则安排一个</span></span><br><span class="line">        isAnimationFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">        <span class="title function_">requestAnimationFrameWithTimeout</span>(animationTick);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 还原</span></span><br><span class="line">      scheduledHostCallback = prevScheduledCallback;</span><br><span class="line">      timeoutTime = prevTimeoutTime;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前时间没有超过截止时间</span></span><br><span class="line">  <span class="keyword">if</span> (prevScheduledCallback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    isFlushingHostCallback = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// =&gt; flushWork(didTimeout);</span></span><br><span class="line">      <span class="title function_">prevScheduledCallback</span>(didTimeout);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      isFlushingHostCallback = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>flushWork</code> 函数我们稍后再提，我们先来看到已经出现了 2 次的 <code>requestAnimationFrameWithTimeout</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动画帧超时 100 ms</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">ANIMATION_FRAME_TIMEOUT</span> = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 编号用于取消动画帧或定时器</span></span><br><span class="line"><span class="keyword">var</span> rAFID;</span><br><span class="line"><span class="keyword">var</span> rAFTimeoutID;</span><br><span class="line"><span class="comment">// 关于 window.requestAnimationFrame 为了提高性能和电池寿命，因此在大多数浏览器里，当requestAnimationFrame() 运行在后台标签页或者隐藏的&lt;iframe&gt; 里时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命。</span></span><br><span class="line"><span class="comment">// 所以 setTimeout 作为 requestAnimationFrame 的 fallback 方案。</span></span><br><span class="line"><span class="keyword">var</span> requestAnimationFrameWithTimeout = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  rAFID = <span class="title function_">localRequestAnimationFrame</span>(<span class="keyword">function</span>(<span class="params">timestamp</span>) &#123;</span><br><span class="line">    <span class="comment">// cancel the setTimeout</span></span><br><span class="line">    <span class="title function_">localClearTimeout</span>(rAFTimeoutID);</span><br><span class="line">    <span class="title function_">callback</span>(timestamp);</span><br><span class="line">  &#125;);</span><br><span class="line">  rAFTimeoutID = <span class="title function_">localSetTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// cancel the requestAnimationFrame</span></span><br><span class="line">    <span class="title function_">localCancelAnimationFrame</span>(rAFID);</span><br><span class="line">    <span class="title function_">callback</span>(<span class="title function_">getCurrentTime</span>());</span><br><span class="line">  &#125;, <span class="variable constant_">ANIMATION_FRAME_TIMEOUT</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// requestAnimationFrameWithTimeout 中执行的 callback 函数： animationTick</span></span><br><span class="line"><span class="keyword">var</span> animationTick = <span class="keyword">function</span>(<span class="params">rafTime</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (scheduledHostCallback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Eagerly schedule the next animation callback at the beginning of the</span></span><br><span class="line">    <span class="comment">// frame. If the scheduler queue is not empty at the end of the frame, it</span></span><br><span class="line">    <span class="comment">// will continue flushing inside that callback. If the queue *is* empty,</span></span><br><span class="line">    <span class="comment">// then it will exit immediately. Posting the callback at the start of the</span></span><br><span class="line">    <span class="comment">// frame ensures it&#x27;s fired within the earliest possible frame. If we</span></span><br><span class="line">    <span class="comment">// waited until the end of the frame to post the callback, we risk the</span></span><br><span class="line">    <span class="comment">// browser skipping a frame and not firing the callback until the frame</span></span><br><span class="line">    <span class="comment">// after that.</span></span><br><span class="line">    <span class="comment">// 发起下一次动画帧，若 scheduledHostCallback 一直存在则无限发起</span></span><br><span class="line">    <span class="title function_">requestAnimationFrameWithTimeout</span>(animationTick);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有待处理的工作，退出</span></span><br><span class="line">    isAnimationFrameScheduled = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// rafTime 为 requestAnimationFrame 返回的时间戳或者 setTimeout 传入的当前时间戳</span></span><br><span class="line">  <span class="comment">// 配合截止时间和每一帧时间（默认 33）计算下一帧时间</span></span><br><span class="line">  <span class="keyword">var</span> nextFrameTime = rafTime - frameDeadline + activeFrameTime;</span><br><span class="line">  <span class="comment">// 更新每一帧时间或前一帧时间，由初始的 33 可能会缩小，但是最小 8 帧</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    nextFrameTime &lt; activeFrameTime &amp;&amp;</span><br><span class="line">    previousFrameTime &lt; activeFrameTime</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextFrameTime &lt; <span class="number">8</span>) &#123;</span><br><span class="line">      <span class="comment">// Defensive coding. We don&#x27;t support higher frame rates than 120hz.</span></span><br><span class="line">      <span class="comment">// If the calculated frame time gets lower than 8, it is probably a bug.</span></span><br><span class="line">      nextFrameTime = <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If one frame goes long, then the next one can be short to catch up.</span></span><br><span class="line">    <span class="comment">// If two frames are short in a row, then that&#x27;s an indication that we</span></span><br><span class="line">    <span class="comment">// actually have a higher frame rate than what we&#x27;re currently optimizing.</span></span><br><span class="line">    <span class="comment">// We adjust our heuristic dynamically accordingly. For example, if we&#x27;re</span></span><br><span class="line">    <span class="comment">// running on 120hz display or 90hz VR display.</span></span><br><span class="line">    <span class="comment">// Take the max of the two in case one of them was an anomaly due to</span></span><br><span class="line">    <span class="comment">// missed frame deadlines.</span></span><br><span class="line">    activeFrameTime =</span><br><span class="line">      nextFrameTime &lt; previousFrameTime ? previousFrameTime : nextFrameTime;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    previousFrameTime = nextFrameTime;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新截止时间</span></span><br><span class="line">  frameDeadline = rafTime + activeFrameTime;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isMessageEventScheduled) &#123;</span><br><span class="line">    <span class="comment">// 若没有进入消息通道则进入</span></span><br><span class="line">    isMessageEventScheduled = <span class="literal">true</span>;</span><br><span class="line">    port.<span class="title function_">postMessage</span>(<span class="literal">undefined</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么现在我们回到之前说先放一放的 <code>flushWork</code> 函数，就是在消息通道监听函数中尝试执行的 <code>prevScheduledCallback(didTimeout);</code> 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushWork</span>(<span class="params">didTimeout</span>) &#123;</span><br><span class="line">  <span class="comment">// Exit right away if we&#x27;re currently paused</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulerDebugging &amp;&amp; isSchedulerPaused) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标记</span></span><br><span class="line">  isExecutingCallback = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 缓存</span></span><br><span class="line">  <span class="keyword">const</span> previousDidTimeout = currentDidTimeout;</span><br><span class="line">  currentDidTimeout = didTimeout;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (didTimeout) &#123;</span><br><span class="line">      <span class="comment">// Flush all the expired callbacks without yielding.</span></span><br><span class="line">      <span class="keyword">while</span> (</span><br><span class="line">        firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// TODO Wrap in feature flag</span></span><br><span class="line">        <span class="comment">// Read the current time. Flush all the callbacks that expire at or</span></span><br><span class="line">        <span class="comment">// earlier than that time. Then read the current time again and repeat.</span></span><br><span class="line">        <span class="comment">// This optimizes for as few performance.now calls as possible.</span></span><br><span class="line">        <span class="keyword">var</span> currentTime = <span class="title function_">getCurrentTime</span>();</span><br><span class="line">        <span class="keyword">if</span> (firstCallbackNode.<span class="property">expirationTime</span> &lt;= currentTime) &#123;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="title function_">flushFirstCallback</span>();</span><br><span class="line">          &#125; <span class="keyword">while</span> (</span><br><span class="line">            firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            firstCallbackNode.<span class="property">expirationTime</span> &lt;= currentTime &amp;&amp;</span><br><span class="line">            !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused)</span><br><span class="line">          );</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Keep flushing callbacks until we run out of time in the frame.</span></span><br><span class="line">      <span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (enableSchedulerDebugging &amp;&amp; isSchedulerPaused) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="title function_">flushFirstCallback</span>();</span><br><span class="line">        &#125; <span class="keyword">while</span> (firstCallbackNode !== <span class="literal">null</span> &amp;&amp; !<span class="title function_">shouldYieldToHost</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 还原</span></span><br><span class="line">    isExecutingCallback = <span class="literal">false</span>;</span><br><span class="line">    currentDidTimeout = previousDidTimeout;</span><br><span class="line">    <span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// There&#x27;s still work remaining. Request another callback.</span></span><br><span class="line">      <span class="title function_">ensureHostCallbackIsScheduled</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Before exiting, flush all the immediate work that was scheduled.</span></span><br><span class="line">    <span class="title function_">flushImmediateWork</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shouldYieldToHost = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> frameDeadline &lt;= <span class="title function_">getCurrentTime</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>进入 <code>flushWork</code> 函数若发现已经超时，则将链表中所有已超时的回调函数任务都执行掉；若没有超时，则链表中任然存在回调函数任务，则发起主机请求，最后将所有优先级为 <code>ImmediatePriority</code> 的任务执行掉。让我们来看到 <code>flushImmediateWork</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushImmediateWork</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// Confirm we&#x27;ve exited the outer most event handler</span></span><br><span class="line">    currentEventStartTime === -<span class="number">1</span> &amp;&amp;</span><br><span class="line">    firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    firstCallbackNode.<span class="property">priorityLevel</span> === <span class="title class_">ImmediatePriority</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    isExecutingCallback = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="title function_">flushFirstCallback</span>();</span><br><span class="line">      &#125; <span class="keyword">while</span> (</span><br><span class="line">        <span class="comment">// Keep flushing until there are no more immediate callbacks</span></span><br><span class="line">        firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        firstCallbackNode.<span class="property">priorityLevel</span> === <span class="title class_">ImmediatePriority</span></span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      isExecutingCallback = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// There&#x27;s still work remaining. Request another callback.</span></span><br><span class="line">        <span class="title function_">ensureHostCallbackIsScheduled</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看到这段代码是不是会很轻松的理解他在做什么，是不是感觉忘了什么内容，来看一下  <code>cancelHostCallback</code> 函数在做什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cancelHostCallback = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  scheduledHostCallback = <span class="literal">null</span>;</span><br><span class="line">  isMessageEventScheduled = <span class="literal">false</span>;</span><br><span class="line">  timeoutTime = -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>很明显，是放弃正在执行的主机回调。到此为止，我们将调度过程已经解读完，你是不是会好奇，这个链表在哪里添加的呢？ OK ，那么下面我们开始解读模块暴露给外部的 API 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unstable_runWithPriority</span>(<span class="params">priorityLevel, eventHandler</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ImmediatePriority</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">UserBlockingPriority</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">NormalPriority</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">LowPriority</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">IdlePriority</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      priorityLevel = <span class="title class_">NormalPriority</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">  <span class="keyword">var</span> previousEventStartTime = currentEventStartTime;</span><br><span class="line">  currentPriorityLevel = priorityLevel;</span><br><span class="line">  currentEventStartTime = <span class="title function_">getCurrentTime</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行传入回调</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">eventHandler</span>();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">    currentEventStartTime = previousEventStartTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before exiting, flush all the immediate work that was scheduled.</span></span><br><span class="line">    <span class="title function_">flushImmediateWork</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>unstable_runWithPriority</code> 函数是按照传入优先级为准正常执行传入回调，最后同样执行 <code>flushImmediateWork</code> 函数。</p>
<ul>
<li>同样的 <code>unstable_next</code> 也是大同小异的逻辑，唯一区别是他将高于 <code>NormalPriority</code> 的优先级进行了降级。</li>
<li><code>unstable_wrapCallback</code> 则是将运行时的 <code>currentPriorityLevel</code> 存入闭包，在调用回调函数时使用当时的 <code>currentPriorityLevel</code> 值。</li>
<li><code>unstable_pauseExecution</code> 则是用于暂停，执行 <code>isSchedulerPaused = true;</code> 。</li>
<li><code>unstable_continueExecution</code> 则是继续执行，复原值后如果有任务的话执行 <code>ensureHostCallbackIsScheduled();</code> 。</li>
<li><code>unstable_getFirstCallbackNode</code> 则是获取 <code>firstCallbackNode</code> 。</li>
<li><code>unstable_getCurrentPriorityLevel</code> 则是获取 <code>currentPriorityLevel</code> 。</li>
</ul>
<p>简单的逻辑，我们一并概括了，接下来我们看到添加链表节点的函数， <code>unstable_scheduleCallback</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unstable_scheduleCallback</span>(<span class="params">callback, deprecated_options</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> startTime =</span><br><span class="line">    currentEventStartTime !== -<span class="number">1</span> ? currentEventStartTime : <span class="title function_">getCurrentTime</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> expirationTime;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> deprecated_options === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">    deprecated_options !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> deprecated_options.<span class="property">timeout</span> === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> Remove this branch once we lift expiration times out of React.</span></span><br><span class="line">    expirationTime = startTime + deprecated_options.<span class="property">timeout</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 根据当前优先级计算对应的到期时间</span></span><br><span class="line">    <span class="keyword">switch</span> (currentPriorityLevel) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">ImmediatePriority</span>:</span><br><span class="line">        expirationTime = startTime + <span class="variable constant_">IMMEDIATE_PRIORITY_TIMEOUT</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">UserBlockingPriority</span>:</span><br><span class="line">        expirationTime = startTime + <span class="variable constant_">USER_BLOCKING_PRIORITY</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">IdlePriority</span>:</span><br><span class="line">        expirationTime = startTime + <span class="variable constant_">IDLE_PRIORITY</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">LowPriority</span>:</span><br><span class="line">        expirationTime = startTime + <span class="variable constant_">LOW_PRIORITY_TIMEOUT</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">NormalPriority</span>:</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        expirationTime = startTime + <span class="variable constant_">NORMAL_PRIORITY_TIMEOUT</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建新的回调节点</span></span><br><span class="line">  <span class="keyword">var</span> newNode = &#123;</span><br><span class="line">    callback,</span><br><span class="line">    <span class="attr">priorityLevel</span>: currentPriorityLevel,</span><br><span class="line">    expirationTime,</span><br><span class="line">    <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">previous</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert the new callback into the list, ordered first by expiration, then</span></span><br><span class="line">  <span class="comment">// by insertion. So the new callback is inserted any other callback with</span></span><br><span class="line">  <span class="comment">// equal expiration.</span></span><br><span class="line">  <span class="keyword">if</span> (firstCallbackNode === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// This is the first callback in the list.</span></span><br><span class="line">    firstCallbackNode = newNode.<span class="property">next</span> = newNode.<span class="property">previous</span> = newNode;</span><br><span class="line">    <span class="title function_">ensureHostCallbackIsScheduled</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 根据到期时间进行插入</span></span><br><span class="line">    <span class="keyword">var</span> next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> node = firstCallbackNode;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">expirationTime</span> &gt; expirationTime) &#123;</span><br><span class="line">        <span class="comment">// The new callback expires before this one.</span></span><br><span class="line">        next = node;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node !== firstCallbackNode);</span><br><span class="line">    <span class="comment">// 操作同 flushFirstCallback 中的部分代码</span></span><br><span class="line">    <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// No callback with a later expiration was found, which means the new</span></span><br><span class="line">      <span class="comment">// callback has the latest expiration in the list.</span></span><br><span class="line">      next = firstCallbackNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next === firstCallbackNode) &#123;</span><br><span class="line">      <span class="comment">// The new callback has the earliest expiration in the entire list.</span></span><br><span class="line">      firstCallbackNode = newNode;</span><br><span class="line">      <span class="title function_">ensureHostCallbackIsScheduled</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="keyword">var</span> previous = next.<span class="property">previous</span>;</span><br><span class="line">    previous.<span class="property">next</span> = next.<span class="property">previous</span> = newNode;</span><br><span class="line">    newNode.<span class="property">next</span> = next;</span><br><span class="line">    newNode.<span class="property">previous</span> = previous;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然有 <code>unstable_scheduleCallback</code> 函数进行插入，当然也有 <code>unstable_cancelCallback</code> 函数进行移除：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unstable_cancelCallback</span>(<span class="params">callbackNode</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> next = callbackNode.<span class="property">next</span>;</span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Already cancelled.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next === callbackNode) &#123;</span><br><span class="line">    <span class="comment">// This is the only scheduled callback. Clear the list.</span></span><br><span class="line">    firstCallbackNode = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Remove the callback from its position in the list.</span></span><br><span class="line">    <span class="keyword">if</span> (callbackNode === firstCallbackNode) &#123;</span><br><span class="line">      firstCallbackNode = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> previous = callbackNode.<span class="property">previous</span>;</span><br><span class="line">    previous.<span class="property">next</span> = next;</span><br><span class="line">    next.<span class="property">previous</span> = previous;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  callbackNode.<span class="property">next</span> = callbackNode.<span class="property">previous</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后让我们来看到 <code>unstable_shouldYield</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unstable_shouldYield</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 未超时</span></span><br><span class="line">    !currentDidTimeout &amp;&amp;</span><br><span class="line">    ((firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    <span class="comment">// 链表头存在且已经过了到期时间</span></span><br><span class="line">      firstCallbackNode.<span class="property">expirationTime</span> &lt; currentExpirationTime) ||</span><br><span class="line">      <span class="comment">// 或者帧到期时间已到</span></span><br><span class="line">      <span class="title function_">shouldYieldToHost</span>())</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，我们已经解读完 React 调度机制，至于如何发挥调度机制的作用，我们就得看到协调了。</p>

                </div>
            </div>

            
            <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者: </strong>
    Zong
  </li>
  <li class="post-copyright-link">
    <strong>本文链接: </strong>
    <a href="https://zongzi531.com/2019/12/20/LSC-React-11/" title="React 源码学习（十一）：Scheduling">https://zongzi531.com/2019/12/20/LSC-React-11/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明: </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

            
    
            <nav class="post-pagination">
    
    <a class="newer-posts" href="/2019/12/21/LSC-React-12/">
        上一篇<br>React 源码学习（十二）：Reconciliation
    </a>
    
    <span class="page-number"></span>
    
    <a class="older-posts" href="/2019/12/19/LSC-React-10/">
        下一篇<br>React 源码学习（十）：Fiber
    </a>
    
</nav>

    
            

<div class="post-comment-wrapper">
    <div class="giscus"></div>
</div>


        </div>
    </div>
    <div class="single-column-footer">
    <div style="margin-bottom: 8px;">
        <a title="GitHub" target="_blank" rel="noopener" href="https://github.com/zongzi531" style="margin: 0px 2px;"><svg height="16" width="16" viewBox="0 0 16 16" version="1.1" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg></a>
        <a title="知乎" target="_blank" rel="noopener" href="https://www.zhihu.com/people/zongzi531/posts" style="margin: 0px 2px;"><img height="16" src="https://static.zhihu.com/static/favicon.ico"></a>
        <a title="掘金" target="_blank" rel="noopener" href="https://juejin.im/user/58747cf2ac502e00646e3b8b/posts" style="margin: 0px 2px;"><img height="16" src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/favicon-32x32.png"></a>
        <a title="力扣" target="_blank" rel="noopener" href="https://leetcode-cn.com/u/zongzi0531/" style="margin: 0px 2px;"><img height="16" src="https://static.leetcode-cn.com/cn-assets/icons/favicon-32x32.png"></a>
    </div>
    &copy; 2017 - 2023 <a href="https://zongzi531.com">Zong</a>
</div>
</div>

</div>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"
        integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.4/dist/umd/popper.min.js"
        integrity="sha256-EGs9T1xMHdvM1geM8jPpoo8EZ1V1VRsmcJz8OByENLA=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js"
        integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js"
        integrity="sha256-FtWfRI+thWlNz2sB3SJbwKx5PgMyKIVgwHCTwa3biXc=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@14.2.1/dist/smooth-scroll.polyfills.min.js"
        integrity="sha256-CI4Gq5E0io1Pv0xM3qPM+NUIOhbIBvC3GiN1Y4KhXpw=" crossorigin="anonymous"></script>
<script src="/js/journal.js?76009531"></script>


    <script src="https://giscus.app/client.js"
    data-repo="zongzi531/zongzi531.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkyMTgyODY2MjA="
    data-category="General"
    data-category-id="DIC_kwDODQLKHM4COlHH"
    data-mapping="url"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="light"
    data-lang="zh-CN"
    data-loading="lazy"
    crossorigin="anonymous"
    async>
</script>


</body>
</html>
