









<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            <div class="post-head-wrapper-text-only"
                 style="background-image: url('')">
                <div class="post-title">
                    金三银四
                    <div class="post-meta">
                        <time datetime="2018-03-27T20:12:52.000Z" itemprop="datePublished">
                            2018-03-27 20:12
                        </time>&nbsp;
                        
                        
                        <i class="material-icons" style="">folder</i>
                        
                        <a href='/categories/JavaScript/'>JavaScript</a>
                        
                        
    
                        
                        
                        <i class="material-icons" style="">label</i>
                        
                        <a href='/tags/JavaScript/'>JavaScript</a>, 
                        
                        <a href='/tags/ECMAScript-6/'>ECMAScript 6</a>
                        
                        
                    </div>
                </div>
            </div>
    
            <div class="post-body-wrapper">
                <div class="post-body">
                    <!-- no node -->

<span id="more"></span>

<blockquote>
<p>《你不知道的JavaScript 中卷》 =&gt; 完成<br>《你不知道的JavaScript 下卷》 =&gt; 未开始<br><strong>“春天来了，万物复苏，同事们又到了跳槽的季节……”</strong><br>我也不例外，我也跳槽了新单位，开始了新的晋级之路。<br>待我工作交接完毕，下个月，我将前往新单位。</p>
</blockquote>
<h2 id="Ant-Design-Mobile-开发体验"><a href="#Ant-Design-Mobile-开发体验" class="headerlink" title="Ant Design Mobile 开发体验"></a>Ant Design Mobile 开发体验</h2><p>React上一款不错的移动端UI库，但是开发过程中遇到了一些业务逻辑无法满足时，我们可以修改源码或者二次封装来修改它的功能。</p>
<p>在使用到Toast <em>轻提示</em> 组件的时候，因为业务逻辑需要多次发送AJAX，导致显示多余的Toast，最终无法被关闭的情况。</p>
<p>那么我在这里采用的是在AJAX外层申明一个<strong>开关</strong>变量，来控制避免重复制造Toast，只不过方法并不那么优雅。</p>
<p>参见Modal <em>对话框</em>组件会发现，每生成一次Modal，DOM结构是含有一个随机的<code>id</code>值，但是Toast并不是如此，所以也可以期待官方提供相应的解决方案（当然这并不是必须的）。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ant-design/ant-design-mobile/issues/2304">#2304</a></p>
<h2 id="滑动验证码之初体验"><a href="#滑动验证码之初体验" class="headerlink" title="滑动验证码之初体验"></a>滑动验证码之初体验</h2><p>出于项目安全性考虑，在部分业务逻辑环节需要加入验证码功能，那么此次在移动端，我将选用滑动验证码来实现，在阅读源码实现，总结几点核心如下：</p>
<ul>
<li>设置背景画布大小，依照背景画布大小随机生成滑块位置点坐标（TOP、LEFT）</li>
<li>使用误差值来提升用户体验</li>
</ul>
<p>由于源码是由纯前端实现的，那么在前后端分离的模式下，有关于滑动验证码的参数都由后端接口提供，除<strong>LEFT值</strong>。</p>
<p>最后由前端回传LEFT值由后端进行校验（修改vue2-verify源码即可实现）。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Hibear/verify">Hibear/verify</a><br><a target="_blank" rel="noopener" href="https://github.com/trionfo1993/vue2-verify">trionfo1993/vue2-verify</a></p>
<h2 id="微信浏览器-lt-返回-gt-按钮读取缓存的解决方案"><a href="#微信浏览器-lt-返回-gt-按钮读取缓存的解决方案" class="headerlink" title="微信浏览器&lt;返回&gt;按钮读取缓存的解决方案"></a>微信浏览器&lt;返回&gt;按钮读取缓存的解决方案</h2><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/**
 * The pageshow event is fired when a session history entry is being traversed to.
 * (This includes back/forward as well as initial page-showing after the onload event.)
 */</span>

<span class="token keyword">const</span> handlePageshow <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>persisted<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    window<span class="token punctuation">.</span>location<span class="token punctuation">.</span><span class="token function">reload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'pageshow'</span><span class="token punctuation">,</span> handlePageshow<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// window.onpageshow = handlePageshow;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>persisted</code>：Persisted user state. （页面是否从浏览器缓存中加载）</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/Events/pageshow">pageshow - Event reference | MDN</a></p>
<h2 id="谈谈中卷这本书"><a href="#谈谈中卷这本书" class="headerlink" title="谈谈中卷这本书"></a>谈谈中卷这本书</h2><p>中卷并没有像上卷那样给我带来很多的惊喜，但是同样从中学习到了一些思考问题的方式，值得在使用过程中权衡。</p>
<p><strong>强制类型转换</strong>是一个很有趣的话题，并且这是分显式和隐式的，那么如何定义这两种类型，书中也给出了自己的看法，用好强制类型转换可以让我们的代码更易阅读，更易合作开发，所以使用时需要权衡其利弊，而不是特意的去使用其中一种。</p>
<p><strong>表达式的副作用</strong>也是很有趣的一章，仔细思考会发现自己的代码中会有很多副作用，有些则是刚好顺的自己意愿，反之则可能会产生意想不到的问题。理解这个问题，我认为在开发过程中是有利于发现自己代码的问题所在，思考问题产生的原因，从而解决问题。</p>
<p><strong>异步</strong>这个话题，我相信在未来都是一直火热的话题，那么书中讲述了回调噩梦的种种缺点，也展示了Generator 函数与Promise 对象组合产生的魅力，但是我在之前的开发过程中确实接触过类似的异步业务逻辑，当然我并没有选择使用这种组合方式，而我是使用async 函数与Promise 对象的组合方式，因为async 函数相比Generator 函数我认为更关注业务本身，并且可以自动执行，但是本书中提到的Generator 函数解决并行问题，我认为在并行问题上Generator 函数会更佳。本书的最后还提到了高级异步模式，是围绕着asynquence 库实现的，虽然我暂时没用使用过这个库，但是可以感受到社区目前有很多对Promise 对象的扩展，想象未来的异步会写的更有乐趣吧。</p>
<p><strong>性能</strong> 关于代码性能，希望不要拘于小节，因为那样的优化很有可能在未来产生意想不到的危害，并且可以导致自己的代码可读性大大下降。尾调用优化是真实存在的，希望编写代码的时候考虑到这一点，因为它确实可以节省内存消耗。</p>

                </div>
            </div>

            
            
            
    
            
    
            
        </div>
    </div>
    
</div>






