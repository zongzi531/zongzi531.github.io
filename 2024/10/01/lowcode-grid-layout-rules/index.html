

<!DOCTYPE html>
<html lang="zh-CN" xmlns:v-bind="http://www.w3.org/1999/xhtml">

<head>
    <title>低代码网格布局 - Zong</title>
<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Zong">
<meta name="description" content="



时隔一年，又重新参与低代码的建设，重新根据业务形态抽象网格布局逻辑。
那就来分享一下网格布局的实现逻辑。
...">
<meta name="keywords" content="Blog JavaScript TypeScript Front-end CSS">

    <meta charset="utf-8">
    <meta name="X-UA-Compatible" content="IE=edge">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta content="telephone=no" name="format-detection">
    <meta name="renderer" content="webkit">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/journal.css?48953768">

<link rel="icon" href="/images/favicon.ico">

<script src="/js/loadCSS.js"></script>
<script>
    loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Material+Icons");
    (function(d) {
        var config = {
        kitId: 'ojl5tfq',
        scriptTimeout: 3000,
        async: true
        },
        h=d.documentElement,t=setTimeout(function(){h.className=h.className.replace(/\bwf-loading\b/g,"")+" wf-inactive";},config.scriptTimeout),tk=d.createElement("script"),f=false,s=d.getElementsByTagName("script")[0],a;h.className+=" wf-loading";tk.src='https://use.typekit.net/'+config.kitId+'.js';tk.async=true;tk.onload=tk.onreadystatechange=function(){a=this.readyState;if(f||a&&a!="complete"&&a!="loaded")return;f=true;clearTimeout(t);try{Typekit.load(config)}catch(e){}};s.parentNode.insertBefore(tk,s)
    })(document);
</script>
<noscript>
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Lora|Montserrat|Anonymous+Pro:400|Material+Icons"/>
</noscript>
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Zong" type="application/atom+xml">
</head>
<body>
<div id="top"></div>
<div id="app">
<div class="single-column-drawer-container" ref="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            <a class="a-block drawer-menu-item false" href="https://zongzi531.github.io">
                首页
            </a>
            

            
            
                
                    <a class="a-block drawer-menu-item false" href="/bangumi/index.html">
                        番組
                    </a>
                
            
                
                    <a class="a-block drawer-menu-item false" href="/archives/index.html">
                        回顾
                    </a>
                
            
                
                    <a class="a-block drawer-menu-item false" href="/syoukai/index.html">
                        紹介
                    </a>
                
            
                
            

            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="/">
            Zong
        </a>
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="/">
        <div class="single-column-header-title">Zong</div>
        <div class="single-column-header-subtitle"></div>
    </a>
</div>
<div ref="sideContainer" class="side-container">
    <a class="a-block nav-head false" href="/">
        <div class="nav-title">
            Zong
        </div>
        <div class="nav-subtitle">
            人之所以能<br>，是相信能
        </div>
    </a>

    <div class="nav-link-list">
        

        
        
            
                <a class="a-block nav-link-item false" href="/bangumi/index.html">
                    番組
                </a>
            
        
            
                <a class="a-block nav-link-item false" href="/archives/index.html">
                    回顾
                </a>
            
        
            
                <a class="a-block nav-link-item false" href="/syoukai/index.html">
                    紹介
                </a>
            
        
            
        

        
    </div>

    <div class="nav-footer">
        &copy; 2017 - 2025 <a href="https://zongzi531.github.io">Zong</a>
    </div>
</div>
<div ref="extraContainer" class="extra-container">
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>

        
    </div>
</div>



<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            <div class="post-head-wrapper"
                 style="background-image: url('/2024/10/01/lowcode-grid-layout-rules/pic-1.jpg')">
                <div class="post-title">
                    低代码网格布局
                    <div class="post-meta">
                        <time datetime="2024-10-01T08:33:20.000Z" itemprop="datePublished">
                            2024-10-01 08:33
                        </time>&nbsp;
                        
                        
                        <i class="material-icons" style="">folder</i>
                        
                        <a href='/categories/Lowcode/'>Lowcode</a>
                        
                        
    
                        
                        
                        <i class="material-icons" style="">label</i>
                        
                        <a href='/tags/lowcode/'>lowcode</a>, 
                        
                        <a href='/tags/低代码/'>低代码</a>, 
                        
                        <a href='/tags/grid/'>grid</a>, 
                        
                        <a href='/tags/layout/'>layout</a>, 
                        
                        <a href='/tags/rules/'>rules</a>
                        
                        
                    </div>
                </div>
            </div>
    
            <div class="post-body-wrapper">
                <div class="post-body">
                    <!-- no node -->

<span id="more"></span>

<p>时隔一年，又重新参与低代码的建设，重新根据业务形态抽象网格布局逻辑。</p>
<p>那就来分享一下网格布局的实现逻辑。</p>
<h2 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h2><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><p>设计将网格横向分为 <strong>12</strong> 列，并根据实际页面宽度（或者页面预设固定宽度）计算每列实际列宽，以作为 <code>w</code> 的单位映射值，即 <code>w</code> 最大为 <strong>12</strong>。</p>
<p>行高固定为 <strong>32</strong>px ，即 <code>h</code> 的单位映射值，不限制最大值。</p>
<p>格间间距为 <strong>16</strong>px 。</p>
<h3 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h3><h4 id="GridItem-网格项"><a href="#GridItem-网格项" class="headerlink" title="GridItem 网格项"></a><code>GridItem</code> 网格项</h4><p>此组件会体现在 <code>GridLayout</code> 下，会对业务组件或基础组件等进行包裹，以保证 <code>GridLayout</code> 在渲染时，对 <code>children</code> 各组件进行包裹。</p>
<p>并且，此组件自身无 <code>Schema</code> 配置信息，仅从被包裹 <code>Schema</code> 中获取 <code>size</code> 以呈现组件具体大小（实际大小），或者映射大小（网格单位，通过计算呈现实际大小）。</p>
<h4 id="GridLayout-网格容器"><a href="#GridLayout-网格容器" class="headerlink" title="GridLayout 网格容器"></a><code>GridLayout</code> 网格容器</h4><p>此组件为特殊内置组件（与业务组件或基础组件一致），具备 <code>Schema</code> 配置信息。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>备注</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>layouts</code></td>
<td><code>children</code> 中组件的位置信息</td>
<td><code>Array&lt;LayoutItem&gt;</code></td>
</tr>
</tbody></table>
<h6 id="相关类型"><a href="#相关类型" class="headerlink" title="相关类型"></a>相关类型</h6><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 设计参考 react-grid-layout 配置</span>
<span class="token keyword">interface</span> <span class="token class-name">LayoutItem</span> <span class="token punctuation">&#123;</span>
  id<span class="token operator">:</span> <span class="token builtin">string</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span>
  w<span class="token operator">:</span> <span class="token builtin">number</span>
  h<span class="token operator">:</span> <span class="token builtin">number</span>
  gap<span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token string">'top'</span> <span class="token operator">|</span> <span class="token string">'right'</span> <span class="token operator">|</span> <span class="token string">'bottom'</span> <span class="token operator">|</span> <span class="token string">'left'</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">></span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="网格交互"><a href="#网格交互" class="headerlink" title="网格交互"></a>网格交互</h3><p>网格交互设计分为：插入、移动、大小调整、删除</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>获取环境信息</p>
<ul>
<li>是否选中组件</li>
<li><code>LayoutItem</code> 默认 <code>w</code> 为 6 ， <code>h</code> 为 6</li>
</ul>
<h5 id="点击插入"><a href="#点击插入" class="headerlink" title="点击插入"></a>点击插入</h5><ol>
<li>若未选中组件，则默认插入根 <code>GridLayout</code></li>
<li>更新 <code>GridLayout</code> 的 <code>layouts</code> 下 <code>LayoutItem</code> 数据至尾部（生成默认 <code>w</code> 和 <code>h</code> ）</li>
<li>布局计算</li>
<li>若选中组件，获得选中组件信息</li>
</ol>
<h6 id="选中-GridLayout"><a href="#选中-GridLayout" class="headerlink" title="选中 GridLayout"></a>选中 <code>GridLayout</code></h6><ol start="5">
<li>更新 <code>GridLayout</code> 的 <code>layouts</code> 下 <code>LayoutItem</code> 数据至尾部（生成默认 <code>w</code> 和 <code>h</code> ）</li>
<li>布局计算</li>
</ol>
<h6 id="选中业务组件或基础组件"><a href="#选中业务组件或基础组件" class="headerlink" title="选中业务组件或基础组件"></a>选中业务组件或基础组件</h6><ol start="5">
<li>获得选中组件 <code>parent</code></li>
<li>若是 <code>GridLayout</code> ，则更新 <code>GridLayout</code> 的 <code>layouts</code> 下 <code>LayoutItem</code> 数据至选中组件之后（生成默认 <code>w</code> 和 <code>h</code> ）</li>
<li>布局计算</li>
<li>若不是则默认插入，不执行网格布局逻辑</li>
</ol>
<h6 id="选中容器组件"><a href="#选中容器组件" class="headerlink" title="选中容器组件"></a>选中容器组件</h6><blockquote>
<p>容器组件为特殊组件，即业务组件或基础组件支持 <code>children</code> 渲染</p>
</blockquote>
<ol start="5">
<li>默认插入，不执行网格布局逻辑</li>
</ol>
<h5 id="移动插入"><a href="#移动插入" class="headerlink" title="移动插入"></a>移动插入</h5><ol>
<li>获得鼠标落点（鼠标抬起位置）</li>
<li>获得落点组件信息</li>
<li>逻辑同「点击插入」时选中组件情况</li>
</ol>
<h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><ol>
<li>获得鼠标落点（鼠标抬起位置）</li>
<li>获得落点组件信息</li>
</ol>
<h6 id="落点-GridLayout"><a href="#落点-GridLayout" class="headerlink" title="落点 GridLayout"></a>落点 <code>GridLayout</code></h6><ol start="3">
<li>检查落点 <code>GridLayout</code> 是否与当前移动组件的 <code>parent</code> 一致</li>
<li>若一致则更新对应 <code>layouts</code> 下 <code>LayoutItem</code> 数据至尾部</li>
<li>布局计算</li>
<li>若不一致则执行删除和插入（采用当前 <code>w</code> 和 <code>h</code> ）操作</li>
</ol>
<h6 id="落点业务组件或基础组件"><a href="#落点业务组件或基础组件" class="headerlink" title="落点业务组件或基础组件"></a>落点业务组件或基础组件</h6><ol start="3">
<li>获得落点组件 <code>parent</code> 是否与当前移动组件的 <code>parent</code> 一致</li>
<li>若一致则交换对应 <code>layouts</code> 下 <code>LayoutItem</code> 数据（除了交换，也可以是插入，具体根据自身业务决定）</li>
<li>布局计算</li>
<li>若不一致则执行删除和插入（采用当前 <code>w</code> 和 <code>h</code> ）操作</li>
</ol>
<h6 id="落点容器组件"><a href="#落点容器组件" class="headerlink" title="落点容器组件"></a>落点容器组件</h6><blockquote>
<p>容器组件为特殊组件，即业务组件或基础组件支持 <code>children</code> 渲染</p>
</blockquote>
<ol start="3">
<li>执行删除和插入（不执行网格布局逻辑）操作</li>
<li>布局计算</li>
</ol>
<h4 id="大小调整"><a href="#大小调整" class="headerlink" title="大小调整"></a>大小调整</h4><ol>
<li>获得鼠标 <code>x</code> 和 <code>y</code> 的偏移量（鼠标按下到鼠标抬起后获得）</li>
<li>根据当前组件 <code>Schema</code> 大小累加偏移量（四舍五入）计算组件新大小，即 <code>w</code> 和 <code>h</code> 的值</li>
<li>更新对应 <code>layouts</code> 下 <code>LayoutItem</code> 数据</li>
<li>布局计算</li>
</ol>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ol>
<li>移除组件 <code>Schema</code></li>
<li>移除对应 <code>layouts</code> 下 <code>LayoutItem</code> （若存在）</li>
<li>布局计算（若存在）</li>
</ol>
<h3 id="布局计算"><a href="#布局计算" class="headerlink" title="布局计算"></a>布局计算</h3><ol>
<li>获得 <code>layouts</code> 信息</li>
<li>依次基于 <code>w</code> 和 <code>h</code> 的值计算 <code>x</code> 和 <code>y</code> 位置</li>
<li>并且根据当前 <code>w</code> 、 <code>h</code> 、 <code>x</code> 和 <code>y</code> 的关系计算格间间距值</li>
<li>更新 <code>layouts</code> 信息（格间间距在渲染、位置阴影、选中框时进行累加，不影响原值）</li>
<li>渲染更新</li>
</ol>
<p>算法根据自身业务决定，可以使用二维数组进行占位计算，或是使用自然堆叠计算方式，或是其他。</p>
<table>
<thead>
<tr>
<th>算法 A</th>
<th>算法 B</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/2024/10/01/lowcode-grid-layout-rules/algorithm-a.png" alt="algorithm-a"></td>
<td><img src="/2024/10/01/lowcode-grid-layout-rules/algorithm-b.png" alt="algorithm-b"></td>
</tr>
</tbody></table>
<h4 id="算法-A"><a href="#算法-A" class="headerlink" title="算法 A"></a>算法 A</h4><blockquote>
<p>依次遍历 <code>layouts</code> 以返回新的 <code>x</code> 和 <code>y</code> 位置</p>
</blockquote>
<ol>
<li>初始化锚点 <code>x</code> 和 <code>y</code> 位置 <code>(0, 0)</code> ，行内标和行标 <code>(0, 0)</code> ，缓存最大 <code>y</code> 为 0</li>
<li>依次遍历，记录前一次的缓存最大 <code>y</code> 位置（用于计算格间间距）</li>
<li>比较 <code>LayoutItem</code> 的 <code>x</code> 与 <code>w</code> 的和是否大于 <strong>12</strong></li>
<li>若小于等于，则更新当前 <code>LayoutItem</code> 的 <code>x</code> 和 <code>y</code> 位置</li>
<li>同时更新锚点 <code>x</code> 的位置为当前 <code>LayoutItem</code> 的 <code>x</code> 与 <code>w</code> 的和</li>
<li>根据当前 <code>LayoutItem</code> 的 <code>y</code> 与 <code>h</code> 的和，缓存最大 <code>y</code> 位置（取最大值）</li>
<li>若大于，则表示溢出，重置锚点 <code>x</code> 为 0 ，将锚点 <code>y</code> 设置为缓存最大 <code>y</code></li>
<li>更新当前 <code>LayoutItem</code> 的 <code>x</code> 和 <code>y</code> 位置</li>
<li>重复 5, 6</li>
<li>每计算出 <code>LayoutItem</code> 的 <code>x</code> 和 <code>y</code> 位置后，比较前一次的缓存最大 <code>y</code> 位置和缓存最大 <code>y</code> 位置</li>
<li>若前一次的缓存最大 <code>y</code> 位置小于缓存最大 <code>y</code> 位置（说明换行过），增加行标，重置行内标为 0</li>
<li>反之则增加行内标</li>
<li>将当前行内标和行标与 <code>LayoutItem</code> 对应关联</li>
</ol>
<p>至此，已实现更新 <code>x</code> 和 <code>y</code> 位置，接下来结合行内标和行标信息来计算 <code>LayoutItem</code> 的格间间距。</p>
<blockquote>
<p>倒序遍历行内标和行标</p>
</blockquote>
<ol>
<li>设置第一次右间距存在标识为否，前一次行标为行内标和行标信息的最后一个值</li>
<li>倒序遍历，获得对应的行内标和行标</li>
<li>初始化 <code>LayoutItem</code> 对应的格间间距，左右上为 0 ，下为 1&#x2F;2 间距 8px</li>
<li>若前一次行标与当前行标不一致（意味着行变更），则重置第一次右间距存在标识为否</li>
<li>更新前一次行标为当前行标</li>
<li>若当前行标大于 1 ，则表示非第一行，设置格间间距上为 8px</li>
<li>若第一次右间距存在标识为是，或者当前对应的 <code>LayoutItem</code> 的 <code>x</code> 与 <code>w</code> 的和小于 <strong>12</strong> ，则设置格间间距右为 8px</li>
<li>若当前行内标大于 0 ，则设置格间间距左为 8px ，并将第一次右间距存在标识设置为是</li>
<li>更新格间间距至对应的 <code>LayoutItem</code></li>
</ol>
<h4 id="算法-B"><a href="#算法-B" class="headerlink" title="算法 B"></a>算法 B</h4><blockquote>
<p>依次遍历 <code>layouts</code> 以返回新的 <code>x</code> 和 <code>y</code> 位置</p>
</blockquote>
<ol>
<li>初始化空二维数组（记做标记空间），用于标记占位情况；<code>y</code> 标识用于记录需要延展的行数，初始为 0 ，以及上一次的 <code>y</code> 标识，同初始为 0</li>
<li>依次遍历，比较上一次的 <code>y</code> 标识与 <code>y</code> 标识加 <code>LayoutItem</code> 的 <code>h</code> ，取最大值更新上一次的 <code>y</code> 标识</li>
<li>使用上一次的 <code>y</code> 标识与标记空间长度比较，若大于 0 ，则批量生成行 <code>new Array(12).fill(null)</code></li>
<li>从 <code>(0, 0)</code> 标记位进行遍历（可优化至最左上角的一个 <code>null</code> 标记位），寻找 <code>null</code> 标记位</li>
<li>当找到 <code>null</code> 标记位后，以此标记位为起点，检查 <code>LayoutItem</code> 的 <code>w</code> 和 <code>h</code> 占位情况（以标记位为起点向右下检查 <code>LayoutItem</code> 的 <code>w</code> 和 <code>h</code> 长度，不能越界）</li>
<li>若均为 <code>null</code> 则更新标记空间，并更新 <code>LayoutItem</code> 的 <code>x</code> 和 <code>y</code> 为当前标记位起点，同时更新 <code>y</code> 标识为当前标记位起点 <code>y</code> 与 <code>LayoutItem</code> 的 <code>h</code> 的和，中断此次标记位遍历，进入下一个 <code>LayoutItem</code> 遍历</li>
<li>反之寻找下一个 <code>null</code> 标记位起点</li>
</ol>
<p>至此，已实现更新 <code>x</code> 和 <code>y</code> 位置，接下来结合标记空间来计算 <code>LayoutItem</code> 的格间间距。</p>
<ol>
<li>遍历标记空间 4 条边，记录占用 <code>LayoutItem</code> 信息</li>
<li>依次遍历 <code>LayoutItem</code> 并初始化对应的格间间距，左右上下为 8px</li>
<li>检查占用信息，对 4 条边存在占用的方向格间间距设置为 0</li>
<li>更新格间间距至对应的 <code>LayoutItem</code></li>
</ol>
<h3 id="辅助功能"><a href="#辅助功能" class="headerlink" title="辅助功能"></a>辅助功能</h3><ol>
<li>组件选中框跟随组件一起移动</li>
<li>计算组件预计落点位置阴影</li>
<li>动态替换</li>
</ol>

                </div>
            </div>

            
            <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者: </strong>
    Zong
  </li>
  <li class="post-copyright-link">
    <strong>本文链接: </strong>
    <a href="https://zongzi531.github.io/2024/10/01/lowcode-grid-layout-rules/" title="低代码网格布局">https://zongzi531.github.io/2024/10/01/lowcode-grid-layout-rules/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明: </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

            
    
            <nav class="post-pagination">
    
    <a class="newer-posts" href="/2024/11/01/%E5%85%B3%E4%BA%8E%E9%97%A8%E6%88%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/">
        上一篇<br>关于门户的架构思考
    </a>
    
    <span class="page-number"></span>
    
    <a class="older-posts" href="/2024/09/01/rag%E7%94%9F%E6%80%81%E6%8E%A2%E7%B4%A2/">
        下一篇<br>RAG 生态探索
    </a>
    
</nav>

    
            

<div class="post-comment-wrapper">
    <div class="giscus"></div>
</div>


        </div>
    </div>
    <div class="single-column-footer">
    &copy; 2017 - 2025 <a href="https://zongzi531.github.io">Zong</a>
</div>
</div>

</div>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"
        integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.4/dist/umd/popper.min.js"
        integrity="sha256-EGs9T1xMHdvM1geM8jPpoo8EZ1V1VRsmcJz8OByENLA=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js"
        integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js"
        integrity="sha256-FtWfRI+thWlNz2sB3SJbwKx5PgMyKIVgwHCTwa3biXc=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@14.2.1/dist/smooth-scroll.polyfills.min.js"
        integrity="sha256-CI4Gq5E0io1Pv0xM3qPM+NUIOhbIBvC3GiN1Y4KhXpw=" crossorigin="anonymous"></script>
<script src="/js/journal.js?6064238"></script>


    <script src="https://giscus.app/client.js"
    data-repo="zongzi531/zongzi531.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkyMTgyODY2MjA="
    data-category="General"
    data-category-id="DIC_kwDODQLKHM4COlHH"
    data-mapping="url"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="light"
    data-lang="zh-CN"
    data-loading="lazy"
    crossorigin="anonymous"
    async>
</script>


</body>
</html>
