<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zong</title>
  
  
  <link href="https://zongzi531.com/atom.xml" rel="self"/>
  
  <link href="https://zongzi531.com/"/>
  <updated>2022-09-01T13:18:57.000Z</updated>
  <id>https://zongzi531.com/</id>
  
  <author>
    <name>Zong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>火焰山 - 杭州</title>
    <link href="https://zongzi531.com/2022/09/01/%E7%81%AB%E7%84%B0%E5%B1%B1-%E6%9D%AD%E5%B7%9E/"/>
    <id>https://zongzi531.com/2022/09/01/%E7%81%AB%E7%84%B0%E5%B1%B1-%E6%9D%AD%E5%B7%9E/</id>
    <published>2022-09-01T13:18:57.000Z</published>
    <updated>2022-09-01T13:18:57.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>本来想说，八月很热，都是 40 度的高温天气，结果八月底降温了，感觉比去年这个时候还要凉快一些。</p><p>不过还好，赶着八月底去山顶露营玩耍了一下。</p><p>今年夏天这么热，也不知道今年冬天会不会很冷。</p><p>这个月可以说是比较忙碌，都在处理低代码的工作，但是在忙碌之余，通过公司的课程学习了「绩效管理」相关的知识内容。</p><p>同时也在中午的时候学习了部分 <code>wasm-bindgen</code> 的知识，计划着把 Rust 实践起来，在能够较为熟练的掌握 Rust 时，为大家提供一些 Rust 的入门分享。</p><p>也在考虑要不上购买一些有关 Rust 的书籍和产品、商业相关的书籍学习。</p><p>暂时就这么多吧，散会！</p><h2 id="任务进度"><a href="#任务进度" class="headerlink" title="任务进度"></a>任务进度</h2><ul><li><em><strong>「日本語学習計画」</strong>：语法及词汇 <strong>第1页</strong></em></li><li><em><strong>「计算机图形学」</strong>：材质与外观</em></li><li><strong>「锻炼身体」</strong>：步行、上楼梯、Just Dance、健身环 <strong>待加强</strong></li><li><em><strong>「ECMA-262」</strong>：6.2.4 The Reference Specification Type</em></li><li><strong>「Rust语言圣经(Rust教程 Rust Course)」</strong>：11.5.1. 数据布局和基本操作</li><li><strong>「Rust By Practice( Rust 练习实践 )」</strong>：17.3. 深入生命周期</li><li><strong>「The <code>wasm-bindgen</code> Guide」</strong>：1.10. web-sys: Closures</li></ul><h2 id="生活记忆"><a href="#生活记忆" class="headerlink" title="生活记忆"></a>生活记忆</h2><div style="display: grid; grid-template-columns: 1fr 1fr 1fr; grid-gap: 16px;">  <img src="pic2.jpeg">  <img src="pic3.jpeg">  <div></div></div>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>为什么总是在下班的时候下雷阵雨</title>
    <link href="https://zongzi531.com/2022/08/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%80%BB%E6%98%AF%E5%9C%A8%E4%B8%8B%E7%8F%AD%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%8B%E9%9B%B7%E9%98%B5%E9%9B%A8/"/>
    <id>https://zongzi531.com/2022/08/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%80%BB%E6%98%AF%E5%9C%A8%E4%B8%8B%E7%8F%AD%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%8B%E9%9B%B7%E9%98%B5%E9%9B%A8/</id>
    <published>2022-08-01T08:53:39.000Z</published>
    <updated>2022-08-01T08:53:39.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>其实也是这几年慢慢的意识到，为什么杭州夏天的雷阵雨总是在下班的时候开始下，17:30 左右，真是糟糕透了！</p><p>每每到下班，就开始下雨！不开车湿鞋、开车路上堵。</p><p>今天刚好上网搜了一下，砖家说是：热力和动力因素共同导致。</p><p>砖业的我也不太懂，我理解的大致意思就是，下午的时候天气晴朗，地面很多的水气都升上去了，到下班的时间水气厚了就下雨了（可能也不是厚了，反正就是要下雨了），也真是好巧不巧……</p><p>反正就是这样吧……</p><h2 id="加藤-恵（かとう-めぐみ）"><a href="#加藤-恵（かとう-めぐみ）" class="headerlink" title="加藤 恵（かとう めぐみ）"></a>加藤 恵（かとう めぐみ）</h2><p>入手 劇場版「冴えない彼女の育てかた Fine」 加藤恵 メイドVer. 1&#x2F;7スケールフィギュア</p><p><img src="/2022/08/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%80%BB%E6%98%AF%E5%9C%A8%E4%B8%8B%E7%8F%AD%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%8B%E9%9B%B7%E9%98%B5%E9%9B%A8/600_11878.jpg" alt="600_11878"></p><h2 id="任务进度"><a href="#任务进度" class="headerlink" title="任务进度"></a>任务进度</h2><ul><li><em><strong>「日本語学習計画」</strong>：语法及词汇 <strong>第1页</strong></em></li><li><em><strong>「计算机图形学」</strong>：材质与外观</em></li><li><strong>「锻炼身体」</strong>：步行、上楼梯、Just Dance、健身环 <strong>待加强</strong></li><li><em><strong>「ECMA-262」</strong>：6.2.4 The Reference Specification Type</em></li><li><strong>「Rust语言圣经(Rust教程 Rust Course)」</strong>：11.5.1. 数据布局和基本操作</li><li><strong>「Rust By Practice( Rust 练习实践 )」</strong>：12 类型转换</li></ul><p>有关 ECMA-262 的推进，似乎不是现在的重点，侧重发力 Rust 可能会是不错的选择，待第二语言熟悉后再回过头来看 ECMA 可能才是更好的选择，毕竟需要更多的积累才行。</p><p>也很明显的发现，前端这个领域 JavaScript 虽然占据了主导地位，但是很多底层的优化工作还是得放手交由其他更接近底层的语言去实现，比较有说服力的例子就是 swc 在工程化的的性能提升可见是非常明显了。</p><h2 id="低代码建设"><a href="#低代码建设" class="headerlink" title="低代码建设"></a>低代码建设</h2><p>引擎的设计与实现可谓是 Q3 的一部分工作内容，此次引擎开发采用的是文档、设计先行的工作模式。</p><p>在此期间锻炼了我的文档编写能力，虽然以前编写代码前都也会进行设计，但是没有落地到文档的习惯，不会把自己的设计思路落地成通熟易懂的文字的表达方式。</p><p>同事们只有在接触到我的代码才能大致理解是在做什么，但是并不能理解为什么这么做。</p><p>所以呢，此次会让我更好的学习如何简单、通熟易懂的表达，如何在编码前充分的设计可能性，这样不仅在工作交接、功能回顾的时候能够更高效，也能成为部门的知识沉淀（当然不止这些）。</p><p>引擎的设计更加考验的是抽象能力，也在不断的学习和汲取外部的知识，来提升自己的抽象能力，设计出更好更强大更通用的引擎能力。</p><p>想分享但是又不太好说，不过没关系。</p><p>我想着先把内部的文档写好，再来描述今天的这些也不迟。</p><h2 id="关于未来的焦虑"><a href="#关于未来的焦虑" class="headerlink" title="关于未来的焦虑"></a>关于未来的焦虑</h2><p>说是焦虑呢可能夸张了点，也没到焦虑的这个地步。只是说想提前对未来有些规划或者想法吧（虽然现在一点也想不到，只能定一个浅显的目标）。</p><p>期望还是如此，希望自己在 35 岁时有一份轻松的副业，这样能为自己的 35 岁有更多的保障吧，当然没有也没关系，身体健康才是最重要的。</p><p>毕竟人生无常，不过在这个环境下努力一下也是没关系的。</p><p>总之希望，身体健康、开心快乐，足矣！</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>微前端下 Webpack Runtime 遇坑记录</title>
    <link href="https://zongzi531.com/2022/07/15/%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B8%8Bwebpack-runtime%E9%81%87%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://zongzi531.com/2022/07/15/%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B8%8Bwebpack-runtime%E9%81%87%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2022-07-15T09:36:12.000Z</published>
    <updated>2022-07-15T09:36:12.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>故事发生在微前端的场景下，基于 single-spa 定制，在路由切换进行子应用交替时发生的情况。</p><p>举例说明， 有子应用 A 和子应用 B ， A 使用 Vue3 相关技术栈， B 使用 Vue2 相关技术栈。</p><p>默认情况下，第一次进入 A 或者第一次进入 B ，相应的内容都可以正常的载入，并且不会报错。</p><p>但是如果说是先进入 A ，再进入 B ，或者反之操作，会引起后者无法正常载入，并且可以从控制台查看到报错信息。</p><p>定位到的问题也非常诡异，检查 A 和 B 本身并没有什么问题会造成这样的情况。</p><p>尝试从 Webpack 的编译产物入手排查发现， Webpack Runtime 的代码中，有一个 <code>modules</code> 的对象，用于在加载模块时进行查询使用。</p><p>仔细来回切换发现， A 和 B 的 <code>modules</code> 在第一次进入时都很正常，但是进行切换后会发现 <code>modules</code> 出现了污染。</p><p>简单点来说就是 A 和 B 的 <code>modules</code> 意外的合并了……</p><p>仔细检查 Runtime 代码和翻阅 Webpack 文档发现，是因为 async chunk 引起此问题。</p><p>并且发现 A 和 B 的代码中的 <a href="https://www.webpackjs.com/configuration/output/#output-jsonpfunction"><code>jsonpFunction</code></a> 同名了，所以导致了此问题。</p><blockquote><p>只在 target 是 web 时使用，用于按需加载(load on-demand) chunk 的 JSONP 函数。</p><p>JSONP 函数用于异步加载(async load) chunk，或者拼接多个初始 chunk(CommonsChunkPlugin, AggressiveSplittingPlugin)。</p><p>如果在同一网页中使用了多个（来自不同编译过程(compilation)的）webpack runtime，则需要修改此选项。</p><p>如果使用了 output.library 选项，library 名称时自动追加的。</p></blockquote><p>比较奇怪的是，明明 A 和 B 的构建配置已经设置了独立的 <code>library</code> 选项，但是还是造成了这么多困惑。</p><p>总之，问题得以解决，记录一下。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Webpack" scheme="https://zongzi531.com/categories/Webpack/"/>
    
    
    <category term="webpack" scheme="https://zongzi531.com/tags/webpack/"/>
    
    <category term="micro" scheme="https://zongzi531.com/tags/micro/"/>
    
  </entry>
  
  <entry>
    <title>真的夏天来咯</title>
    <link href="https://zongzi531.com/2022/07/01/%E7%9C%9F%E7%9A%84%E5%A4%8F%E5%A4%A9%E6%9D%A5%E5%92%AF/"/>
    <id>https://zongzi531.com/2022/07/01/%E7%9C%9F%E7%9A%84%E5%A4%8F%E5%A4%A9%E6%9D%A5%E5%92%AF/</id>
    <published>2022-07-01T13:25:37.000Z</published>
    <updated>2022-07-01T13:25:37.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>本来还说着今年春天加班加的有点久，没想到夏天一转眼就来了，温度一下子也就上去了……</p><p>可以说是非常的炎热，没有空调不行啊！</p><h2 id="任务进度"><a href="#任务进度" class="headerlink" title="任务进度"></a>任务进度</h2><ul><li><em><strong>「日本語学習計画」</strong>：语法及词汇 <strong>第1页</strong></em></li><li><em><strong>「计算机图形学」</strong>：材质与外观</em></li><li><strong>「锻炼身体」</strong>：步行、上楼梯、Just Dance、健身环 <strong>待加强</strong></li><li><em><strong>「ECMA-262」</strong>：6.2.4 The Reference Specification Type</em></li><li><strong>「Rust语言圣经(Rust教程 Rust Course)」</strong>：11.5.1. 数据布局和基本操作</li><li><strong>「Rust By Practice( Rust 练习实践 )」</strong>：6.1 字符串</li></ul><h2 id="低代码建设"><a href="#低代码建设" class="headerlink" title="低代码建设"></a>低代码建设</h2><p>本月主要负责画布编辑、渲染模块重构工作，并适配到平台以及开发 CLI，提供即插即用能力。</p><p>并且开始布局类似于阿里低代码引起的能力，设计整体引擎架构及软件生态等。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>本月也主要负责可视化大屏渲染性能优化工作，分析当前可视化大屏在一些配置较差的设备环境下运行，会因一些交互或者大型 3D 组件产生的掉帧、卡顿现象。</p><p>利用将 JS 执行任务进行优先级划分的策略来减轻当用户产生交互或因大型 3D 组件执行 JS 产生的主线程阻塞情况。</p><p>思路大致借鉴 React Fiber 的思路来进行优化，优化效果在 6.1% ～ 36.5% 之间，从结果来看并不是很理想。</p><p>因为很不稳定，并且提升的性能也有限。</p><p>从此布局，需要重新设计组件规范，提供组件侧参与调度任务 API 能力。</p><p>同时对于渲染模块，需要具备运行策略的调度能力来实现稳定的性能优化。</p><p><img src="/2022/07/01/%E7%9C%9F%E7%9A%84%E5%A4%8F%E5%A4%A9%E6%9D%A5%E5%92%AF/pic2.png" alt="性能优化"></p><h2 id="技术分享"><a href="#技术分享" class="headerlink" title="技术分享"></a>技术分享</h2><ul><li><a href="https://github.com/zongzi531/daily-learning/blob/master/share/%E5%BD%93%E5%89%8D%E7%AB%AF%E6%8A%8A%E6%89%8B%E4%BC%B8%E5%90%91%E5%90%8E%E7%AB%AF%EF%BC%8C%E5%81%9A%E8%B5%B7%E5%85%A8%E6%A0%88%E6%97%B6.pdf">《当前端把手伸向后端，做起全栈时》</a></li><li><a href="https://zongzi531.com/2022/06/15/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84JavaScript%E5%AE%8F/">《实现自己的 JavaScript 宏》</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>借助 Webpack 实现样式手动插入</title>
    <link href="https://zongzi531.com/2022/06/22/%E5%80%9F%E5%8A%A9webpack%E5%AE%9E%E7%8E%B0%E6%A0%B7%E5%BC%8F%E6%89%8B%E5%8A%A8%E6%8F%92%E5%85%A5/"/>
    <id>https://zongzi531.com/2022/06/22/%E5%80%9F%E5%8A%A9webpack%E5%AE%9E%E7%8E%B0%E6%A0%B7%E5%BC%8F%E6%89%8B%E5%8A%A8%E6%8F%92%E5%85%A5/</id>
    <published>2022-06-22T12:30:18.000Z</published>
    <updated>2022-06-22T12:30:18.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>背景是需要将 <code>import &#39;example.css&#39;</code> 的样式插入到 <code>iframe</code> 下。</p><p>网上有很多方案，但是都不是我想要的解决方法。</p><p>比如获得到样式的内容，然后插入到 <code>iframe</code> 下，但是我希望实现的是类似于 <code>import</code> 的实现方法。</p><p>那么查阅了相关资料发现，<code>style-loader</code> 有一个配置项 <code>injectType: &#39;lazyStyleTag&#39;</code> ，支持后动插入 <code>&lt;style&gt;</code> 标签。</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token keyword">import</span> styles <span class="token keyword">from</span> <span class="token string">'example.css'</span>styles<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>是在调用 <code>use</code> 方法后对应的 <code>&lt;style&gt;</code> 标签才会插入到 <code>document.head</code> 中。由于我们的需求是插入到 <code>iframe</code> 下的 <code>head</code> 中去，所以我们还需要进行少许配置。</p><p>我们需要配置 <code>insert</code> 函数，让 <code>use</code> 方法的调用可以插入到指定的位置。</p><p>但是你会发现 <code>use</code> 方法不接受参数，所以我们需要使用一些手段来实现，当调用 <code>use</code> 方法时，能够顺利插入到指定位置。</p><p>我们需要看到 <code>node_modules/style-loader/dist/index.js</code> 的源码位置，可以看到 <code>use</code> 方法调用时会调用来自 <code>./runtime/injectStylesIntoStyleTag.js</code> 的默认导出函数。并且传入上下文和 <code>options</code> 。</p><p>当然这不是重点，这是入口，持续执行后会看到进入到 <code>insertStyleElement</code> 函数。如果配置 <code>insert</code> 为函数，相当于调用 <code>use</code> 方法时逻辑自行处理。</p><p>回到 <code>index.js</code> 的文件位置，这里很关键的内容出现了，我们可以在 <code>insert</code> 函数定义时通过外部的环境来定义需要将样式插入的具体位置。</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token function">options</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  injectType<span class="token punctuation">:</span> <span class="token string">'lazyStyleTag'</span><span class="token punctuation">,</span>  insert<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>style<span class="token punctuation">:</span> HTMLStyleElement<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> doc <span class="token operator">=</span> globalThis<span class="token punctuation">.</span>__example__ <span class="token operator">||</span> document    <span class="token keyword">if</span> <span class="token punctuation">(</span>doc<span class="token punctuation">.</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>      doc<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>style<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，你仔细观察源码可以发现，其他还可以在 <code>insert</code> 函数中获取到 <code>exported</code> 这个变量，至于是为什么，相信你去看下 <code>index.js</code> 便会明白。</p><p>我们可以按照我们的需求，声明一下 <code>d.ts</code>：</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'*.css?lazy'</span> <span class="token punctuation">{</span>  <span class="token keyword">interface</span> <span class="token class-name">LazyCSS</span> <span class="token punctuation">{</span>    locals<span class="token punctuation">:</span> Record<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">any</span><span class="token operator">></span>    use<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">void</span>    unuse<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">void</span>    __appendTo__<span class="token operator">?</span><span class="token punctuation">:</span> Document  <span class="token punctuation">}</span>  <span class="token keyword">const</span> lazycss<span class="token punctuation">:</span> LazyCSS  <span class="token keyword">export</span> <span class="token keyword">default</span> lazycss<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们就可以这样使用：</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token keyword">import</span> styles <span class="token keyword">from</span> <span class="token string">'example.css?lazy'</span>styles<span class="token punctuation">.</span>__appendTo__ <span class="token operator">=</span> iframeDocstyles<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当然， <code>insert</code> 函数也需要做稍许调整：</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token function">options</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  injectType<span class="token punctuation">:</span> <span class="token string">'lazyStyleTag'</span><span class="token punctuation">,</span>  insert<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>style<span class="token punctuation">:</span> HTMLStyleElement<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> doc <span class="token operator">=</span> exported<span class="token punctuation">.</span>__appendTo__ <span class="token operator">||</span> document    <span class="token keyword">if</span> <span class="token punctuation">(</span>doc<span class="token punctuation">.</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>      doc<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>style<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里肯定会奇怪，为何后面加了一个参数 <code>?lazy</code> ，是为了区分普通 <code>import</code> 样式和手动插入的参数。</p><p>结合完整的在 webpack-chain 中的配置如下：</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token keyword">const</span> insert <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>style<span class="token punctuation">:</span> HTMLStyleElement<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> doc <span class="token operator">=</span> exported<span class="token punctuation">.</span>__appendTo__ <span class="token operator">||</span> document  <span class="token keyword">if</span> <span class="token punctuation">(</span>doc<span class="token punctuation">.</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    doc<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>style<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 可以加入任何你想加入的逻辑</span><span class="token punctuation">}</span>config<span class="token punctuation">.</span><span class="token keyword">module</span><span class="token punctuation">.</span><span class="token function">rule</span><span class="token punctuation">(</span><span class="token string">'css'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">oneOf</span><span class="token punctuation">(</span><span class="token string">'lazy-css'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token string">'normal'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">resourceQuery</span><span class="token punctuation">(</span><span class="token regex">/lazy/</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token regex">/\.css$/</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">'style-loader'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">loader</span><span class="token punctuation">(</span><span class="token string">'style-loader'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">options</span><span class="token punctuation">(</span><span class="token punctuation">{</span> injectType<span class="token punctuation">:</span> <span class="token string">'lazyStyleTag'</span><span class="token punctuation">,</span> insert <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">'css-loader'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">loader</span><span class="token punctuation">(</span><span class="token string">'css-loader'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">'postcss-loader'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">loader</span><span class="token punctuation">(</span><span class="token string">'postcss-loader'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 同样的，你也可以配置 module.css 也使用手动插入的形式</span><span class="token comment" spellcheck="true">// 记住需要在原有的 loader 校验前加入</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里，我们其实已经实现了我们的需求。也算是大功告成！</p><p>不过这里针对 CSS Module 这种形式记得注意 <code>hash</code> 值是否能够保持一致，若你的 npm 包需要提供这类能力，可以将样式在构建产出时将 <code>hash</code> 值编译成一个非 CSS Module 的样式文件，然后进行引入使用即可。</p><p>有关 <code>style-loader</code> 的源码可以<a href="https://github.com/webpack-contrib/style-loader/tree/master/src">点击查看</a>。</p><p>同理，在别的工程化工具下，也可以借助这个思路实现手动插入样式的需求～</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="CSS" scheme="https://zongzi531.com/tags/CSS/"/>
    
    <category term="Webpack" scheme="https://zongzi531.com/tags/Webpack/"/>
    
    <category term="Style" scheme="https://zongzi531.com/tags/Style/"/>
    
    <category term="lazy" scheme="https://zongzi531.com/tags/lazy/"/>
    
    <category term="import" scheme="https://zongzi531.com/tags/import/"/>
    
    <category term="iframe" scheme="https://zongzi531.com/tags/iframe/"/>
    
  </entry>
  
  <entry>
    <title>《实现自己的 JavaScript 宏》</title>
    <link href="https://zongzi531.com/2022/06/15/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84JavaScript%E5%AE%8F/"/>
    <id>https://zongzi531.com/2022/06/15/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84JavaScript%E5%AE%8F/</id>
    <published>2022-06-15T12:55:30.000Z</published>
    <updated>2022-06-15T12:55:30.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p><strong>宏</strong>（英语：Macro），是一种批量处理的称谓。</p><p>之所以会想做这次分享一是因为想继续多的操作一些 AST 相关的知识，二是也是受到学习 Rust 的影响。</p><h2 id="什么是宏"><a href="#什么是宏" class="headerlink" title="什么是宏"></a>什么是宏</h2><p>我觉得百科中这段解释比较合理：</p><blockquote><p>计算机科学里的宏是一种抽象（Abstraction），它根据一系列预定义的规则替换一定的文本模式。解释器或编译器在遇到宏时会自动进行这一模式替换。对于编译语言，宏展开在编译时发生，进行宏展开的工具常被称为宏展开器。宏这一术语也常常被用于许多类似的环境中，它们是源自宏展开的概念，这包括键盘宏和宏语言。绝大多数情况下，“宏”这个词的使用暗示着将小命令或动作转化为一系列指令。</p><p>宏的用途在于自动化频繁使用的序列或者是获得一种更强大的抽象能力。</p></blockquote><p>当然，更多的解释可以前往百科中学习。</p><h2 id="初识宏"><a href="#初识宏" class="headerlink" title="初识宏"></a>初识宏</h2><p>我最早知道宏的时候是在小学，那时候对宏其实产生了很大的恐惧，那时候流行的是宏病毒，以至于在学习 Office 软件时一直以来不敢接触里面的宏功能。</p><blockquote><p>在计算机技术的历史中，宏病毒（英语：Macro virus）是一种使得应用软件的相关应用文档内含有被称为宏的可执行代码的病毒。一个电子表格程序可能允许用户在一个文档中嵌入“宏命令”，使得某种操作得以自动运行；同样的操作也就可以将病毒嵌入电子表格来对用户的使用造成破坏。</p></blockquote><p>那时候的我，看到这些还是会感到惧怕，担心电脑因此中病毒……当然现在的我也不会去特意接触这些。</p><h2 id="为什么-JavaScript-没有宏编程"><a href="#为什么-JavaScript-没有宏编程" class="headerlink" title="为什么 JavaScript 没有宏编程"></a>为什么 JavaScript 没有宏编程</h2><p>学习 JavaScript 至今，你会发现， JavaScript 没有宏编程的概念，我想其实这与 JavaScript 的运行环境有关系，当然 JavaScript 设计之初就没有设计宏的概念。</p><p>我会认为在 JavaScript 中要想实现类似于宏编程的能力就是函数本身，可以自己实现一个具备抽象的函数处理方法，而宏编程则是向上面百科中提到的内容一样，是一种预定义的规则替换模式。</p><h2 id="如何借助-Babel-实现自己的宏"><a href="#如何借助-Babel-实现自己的宏" class="headerlink" title="如何借助 Babel 实现自己的宏"></a>如何借助 Babel 实现自己的宏</h2><p>本文将不会侧重什么是 AST 、如何编写 AST 等知识，我们可以借助 Babel 提供的宏插件来按照要求实现自己的宏能力。</p><p>我们会以 <a href="https://github.com/kentcdodds/babel-plugin-macros">kentcdodds&#x2F;babel-plugin-macros</a> 提供的教程实现自己的宏。</p><p>我们按照文档要求编写代码如下：</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// index.ts</span><span class="token keyword">import</span> <span class="token punctuation">{</span> createMacro <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'babel-plugin-macros'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">createMacro</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> references<span class="token punctuation">,</span> state<span class="token punctuation">,</span> babel <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// do something</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>并且，我们需要这样去使用：</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// example</span><span class="token keyword">import</span> <span class="token punctuation">{</span> somemacro <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@zong/js.macro'</span>somemacro<span class="token template-string"><span class="token string">`any your want`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于使用 TypeScript 编写，为了提供更好的类型推导，我们需要在 <code>index.ts</code> 定义我们需要被导出的宏方法，并定义对应的逻辑即可。</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// index.ts</span><span class="token keyword">export</span> <span class="token keyword">declare</span> <span class="token keyword">const</span> define<span class="token punctuation">:</span> <span class="token keyword">Function</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>目前，我设计的是想实现一个属于我自己的声明变量的宏。</p><p>我期望实现的宏代码如下：</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token keyword">import</span> <span class="token punctuation">{</span> define <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@zong/js.macro'</span>define<span class="token template-string"><span class="token string">`  @a:1;  @b:2;  @c:'cde';  @d:"def";  @e:true;  @f:false;`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终经过 Babel 编译后的结果是：</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// Compiled</span><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token string">"cde"</span><span class="token punctuation">;</span><span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token string">"def"</span><span class="token punctuation">;</span><span class="token keyword">const</span> e <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span><span class="token keyword">const</span> f <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们需要从 <code>references</code> 对象中获取对应的宏名称使用：</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// index.ts</span><span class="token keyword">import</span> <span class="token punctuation">{</span> createMacro <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'babel-plugin-macros'</span><span class="token keyword">import</span> transformDefine <span class="token keyword">from</span> <span class="token string">'./transforms/define'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">createMacro</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> references<span class="token punctuation">,</span> state<span class="token punctuation">,</span> babel <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 这里的 define 即我们期望使用的宏名称</span>  <span class="token function">transformDefine</span><span class="token punctuation">(</span>references<span class="token punctuation">.</span>define<span class="token punctuation">,</span> state<span class="token punctuation">,</span> babel<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">declare</span> <span class="token keyword">const</span> define<span class="token punctuation">:</span> <span class="token keyword">Function</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来辛苦由 <code>transformDefine</code> 函数进行 AST 操作获得我们想要的结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们了解了什么是宏以及 JavaScript 该如何借助 Babel 实现自己的宏。</p><p>其中的折腾劲十足，明明可以通过抽象一个函数得到的结果，我们非要绕这么大一圈。</p><p>也并不是没有收获，我们收获上面的知识，很开心。</p><p>可以查看 <a href="https://www.npmjs.com/package/@zong/js.macro">@zong&#x2F;js.macro</a> 学习 AST 处理操作。</p><p>目前来看，我不仅实现了上面的静态宏使用方法，还实现了：</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token keyword">import</span> <span class="token punctuation">{</span> define <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@zong/js.macro'</span><span class="token keyword">const</span> var1 <span class="token operator">=</span> <span class="token number">2</span>define<span class="token template-string"><span class="token string">`  @va:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token number">1</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;  @vb:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>var1<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;`</span></span><span class="token comment" spellcheck="true">// Compiled</span><span class="token keyword">const</span> var1 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">const</span> va <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">const</span> vb <span class="token operator">=</span> var1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，未来我还考虑加入更多的宏能力来锻炼 AST 处理能力。</p><ol><li>支持 <code>let</code> 声明 (<code>mut@</code>&#x2F;<code>@@</code>) ；</li><li><code>;</code> 结尾为可选项；</li><li>支持没有初始值；</li><li>若没有初始值则必须以 <code>let</code> 进行声明的校验；</li><li>初始值支持变量等其他 JavaScript 使用方式；</li><li>ESLint 插件 —— 上下文声明变量重复检查；</li></ol>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Share" scheme="https://zongzi531.com/categories/Share/"/>
    
    
    <category term="JavaScript" scheme="https://zongzi531.com/tags/JavaScript/"/>
    
    <category term="Babel" scheme="https://zongzi531.com/tags/Babel/"/>
    
    <category term="macro" scheme="https://zongzi531.com/tags/macro/"/>
    
  </entry>
  
  <entry>
    <title>《当前端把手伸向后端，做起全栈时》</title>
    <link href="https://zongzi531.com/2022/06/09/%E5%BD%93%E5%89%8D%E7%AB%AF%E6%8A%8A%E6%89%8B%E4%BC%B8%E5%90%91%E5%90%8E%E7%AB%AF%EF%BC%8C%E5%81%9A%E8%B5%B7%E5%85%A8%E6%A0%88%E6%97%B6/"/>
    <id>https://zongzi531.com/2022/06/09/%E5%BD%93%E5%89%8D%E7%AB%AF%E6%8A%8A%E6%89%8B%E4%BC%B8%E5%90%91%E5%90%8E%E7%AB%AF%EF%BC%8C%E5%81%9A%E8%B5%B7%E5%85%A8%E6%A0%88%E6%97%B6/</id>
    <published>2022-06-09T10:56:20.000Z</published>
    <updated>2022-06-09T10:56:20.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><blockquote><p><a href="https://github.com/zongzi531/daily-learning/blob/master/share/%E5%BD%93%E5%89%8D%E7%AB%AF%E6%8A%8A%E6%89%8B%E4%BC%B8%E5%90%91%E5%90%8E%E7%AB%AF%EF%BC%8C%E5%81%9A%E8%B5%B7%E5%85%A8%E6%A0%88%E6%97%B6.pdf">链接</a></p></blockquote><p>本次内容来自内部的一些课题分享，也非技术性的内容，只是浅谈一下作为前端如何“卷”起来罢了。</p><p>首先是我们都从事着前端开发的工作，也会每天和产品、设计、后端、测试、运维等产品生命周期内的成员们打交道。</p><p>那么什么被称作是“全栈”呢？</p><p>从知乎上我看到一句内容我挺赞同的，全栈就是一个通才，能够自己创建不平凡的应用程序。</p><p>很关键，其实会和你看到这次分享时的想法有点不太一样，只是在定义全栈这件事情的角度发生了变化。</p><p>从广义上来说，全栈就是一条龙服务，即用户提出了一个应用程序的需求，全栈能够独自设计并交付这个应用程序来满足用户的需求。</p><p>可以说是包揽了整个应用程序产品的生命周期，样样精通。</p><p>但是我们今天也不会讨论的这么广，那么回到正题。</p><p>从软件开发的角度来说，即前端+后端可以产出一个应用程序，前端也就是我们俗称的切图仔，也就是我；后端是我们俗称的业务仔。</p><p>那么有了如此浅显的认识后，我们该如何从前端出发，把手往后端伸过去，做起一个全栈开发工程师呢？</p><p>其实我们可以慢慢的伸过去，我们来回忆一下。</p><p>我们与后端交互频率最高的操作，那必定是 HTTP 请求，通俗宽泛一些的讲就是 AJAX 。</p><p>在工作多了其实会发现 RESTful 这种架构并没有真正意义上的方便我们的交互，它也有它的问题。</p><p>那么这时候喜欢“卷”的我们就设计了一套中间服务，美其名曰 BFF 。</p><p>其实 BFF 可以算是我们伸向后端的第一步，首先跟我们的后端同学分析现状，业务仔每次因为一个特殊的需求或者场景需要给我们增加一个 API 接口真的很心累，作为业务仔才不想关心这些呢。我们的后端同学表示只想专心于业务，那么我们“卷”的机会就出现了。</p><p>这时候后端同学通常会暴露出一些具备通用性且抽象的 API 接口，至于我们想如何使用，我们则在 BFF 进行自行定义，那么如果遇到上面的问题，我们也不需要苦苦的去求后端同学增加 API 接口，后端同学也可以跟切图仔说拜拜了。</p><p>当然了，BFF 中间的实现过程依然可以是 RESTful to RESTful 的形式，也可以是 GraphQL to RESTful 的形式，前者有后端控制，我们 BFF 只做中间的转换者。</p><p>慢慢的，你会发现后端没有心思来管业务，他们更多的会去关心一些底层的设计和性能问题，那我们就可以既是切图仔又是业务仔了，这时候的后端为我们提供可以是一些由后端给出的操作数据的接口、或者直接操作数据库的权限，那么这时候我们就是名副其实的业务仔了。</p><p>再慢慢的，我们就把手伸到那些底层的设计和性能问题时，后端就不复存在了……（开玩笑的）这是不可能的。</p><p>当然了，对于前端……啊呸！软件开发工程师来说，熟悉并掌握整个软件开发的细节，这时候就是全栈了！</p><p>自身能力也得到了提升，可以说是卷王之王！</p><p>当然了，我觉得接触后端不一定是要做个业务仔的，也可以从应用程序优化的角度着手。</p><p>比如我们前端常说的 SSR ，优化应用程序在客户端的启动时间，也会让你接触到后端的技术。</p><p>优化 DevOps 流程、缩短编译时间等等优化方向都会让你接触到后端技术，只是作为前端，其实身边有很多机会可以把手伸到后端去，所以大胆伸进去试一试吧！</p><p>当然从此发散出去，也可以把手伸向产品设计、视觉交互设计、软件测试、软件运维等各个环节中去……卷他们。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Share" scheme="https://zongzi531.com/categories/Share/"/>
    
    
    <category term="前端" scheme="https://zongzi531.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="后端" scheme="https://zongzi531.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="全栈" scheme="https://zongzi531.com/tags/%E5%85%A8%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>お任せ</title>
    <link href="https://zongzi531.com/2022/06/01/omakase/"/>
    <id>https://zongzi531.com/2022/06/01/omakase/</id>
    <published>2022-06-01T12:57:22.000Z</published>
    <updated>2022-06-01T12:57:22.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><blockquote><p>お任せとは、料理人に注文を委託するという日本料理の用語である。</p><p>おまかせスタイルを注文したお客様は、メニューに無いような料理が提供される事を期待して注文を行う。一般的にはアラカルトで注文した料理より値段の高い料理が提供される。</p><p>近年、日本料理の浸透とともに、この用語も浸透した。</p></blockquote><p>这个月是我们的结婚纪念日，同样的在这个月老婆也带我去尝试了お任せ～</p><p>很开心～～嘿嘿</p><h2 id="任务进度"><a href="#任务进度" class="headerlink" title="任务进度"></a>任务进度</h2><ul><li><em><strong>「日本語学習計画」</strong>：语法及词汇 <strong>第1页</strong></em></li><li><em><strong>「计算机图形学」</strong>：材质与外观</em></li><li><strong>「锻炼身体」</strong>：步行、上楼梯、Just Dance、健身环 <strong>待加强</strong></li><li><em><strong>「ECMA-262」</strong>：6.2.4 The Reference Specification Type</em></li><li><strong>「Rust语言圣经(Rust教程 Rust Course)」</strong>：11.5.1. 数据布局和基本操作</li><li><strong>「Rust By Practice( Rust 练习实践 )」</strong>：4.1 数值类型</li></ul><h2 id="低代码建设"><a href="#低代码建设" class="headerlink" title="低代码建设"></a>低代码建设</h2><p>这个月主要负责画布和一些低代码业务侧的能力建设，画布新增功能可支持渲染父或子内容，因为原子组件的加入和考虑到画布未来能力的扩展，也正在进行画布的重构工作。</p><h2 id="JavaScript-Macro"><a href="#JavaScript-Macro" class="headerlink" title="JavaScript Macro"></a>JavaScript Macro</h2><p>受到 Rust 学习带来的影响，发现 JavaScript 没有宏这个概念，其实从某种角度来说 JavaScript 并不需要宏的存在，因为与其他语言有所区别，浏览器是包含编译和运行的。</p><p>当然了，我们想尝试和不需要并不冲突。</p><p>为了实现这个目标，并且更了解 AST，那么我就想着实现 JavaScript 宏看一看。</p><p>于是乎，我就创建了一个仓库开始折腾 <a href="https://github.com/zongzi531/js.macro">zongzi531&#x2F;js.macro</a> 。</p><blockquote><p>Macro in JavaScript powered by Babel.</p></blockquote><p>基于 Babel 提供的能力，利用操作 AST 来实现自己的 JavaScript 宏吧。</p><p>目前我的设想是可以声明变量，截止到儿童节（可能是我想端午节放假了吧……），只实现了一个很基础的能力。</p><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> define <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@zong/js.macro'</span>define<span class="token template-string"><span class="token string">`  @a:1;  @b:2;`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我的设计是：</p><ol><li><code>@</code> 等价于 <code>const</code> ；</li><li><code>@</code> 后为需要声明的变量名称；</li><li><code>:</code> 等价于 <code>=</code> ；</li><li><code>:</code> 后为变量的初始值；</li><li><code>;</code> 表示声明完成；</li></ol><p>最后代码经过 Babel 编译后得到的代码内容是：</p><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然， <code>define</code> 宏目前功能还有很多局限性，我没有进行对应的处理。</p><p>后面计划实现的能力：</p><ol><li>支持 <code>let</code> 声明 (<code>mut@</code>&#x2F;<code>@@</code>) ；</li><li><code>;</code> 结尾为可选项；</li><li>支持没有初始值；</li><li>若没有初始值则必须以 <code>let</code> 进行声明的校验；</li><li>初始值支持变量等其他 JavaScript 使用方式；</li><li>ESLint 插件 —— 上下文声明变量重复检查；</li></ol><p>同时计划输出文章和内部分享。</p><p>马上端午节了，放假咯～跑</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>核酸常态化</title>
    <link href="https://zongzi531.com/2022/05/01/%E6%A0%B8%E9%85%B8%E5%B8%B8%E6%80%81%E5%8C%96/"/>
    <id>https://zongzi531.com/2022/05/01/%E6%A0%B8%E9%85%B8%E5%B8%B8%E6%80%81%E5%8C%96/</id>
    <published>2022-05-01T08:38:10.000Z</published>
    <updated>2022-05-01T08:38:10.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>杭州市政府发布核酸常态化的通知，看出了杭州政府的抗疫决心，我们能做的就是理解和配合，加油杭州！</p><h2 id="PBC"><a href="#PBC" class="headerlink" title="PBC"></a>PBC</h2><p>Q2 开始正式执行 PBC 绩效考核，全称：Personal Business Commitment（个人绩效承诺）。整个 Q2 的工作内容也是围绕着低代码平台迭代、浏览器性能优化等工作进行开展，整个团队也按照一样的目标，分工去一起达成整个团队的 PBC 绩效考核。</p><h2 id="低代码基础建设"><a href="#低代码基础建设" class="headerlink" title="低代码基础建设"></a>低代码基础建设</h2><p>低代码平台也进入正式迭代阶段，除了前端侧业务级别的代码修改，还接触了 Node.js 服务端的业务代码修改。比如学习 <code>typeorm</code>, 编写 migration 文件等业务级别代码。</p><p>同时维护低代码平台配套物料开发 CLI 脚手架，包括能力扩展和缺陷修复。</p><p>以及内部 Webpack 插件能力扩展（布局嵌套功能等）。</p><p>说来说去，其实大部分都是业务级别的工作内容，接触到比较额外的内容就是写 Node.js 在实战中了。</p><h2 id="任务进度"><a href="#任务进度" class="headerlink" title="任务进度"></a>任务进度</h2><ul><li><em><strong>「日本語学習計画」</strong>：语法及词汇 <strong>第1页</strong></em></li><li><em><strong>「计算机图形学」</strong>：材质与外观</em></li><li><strong>「锻炼身体」</strong>：步行、上楼梯、Just Dance、健身环 <strong>待加强</strong></li><li><em><strong>「ECMA-262」</strong>：6.2.4 The Reference Specification Type</em></li><li><strong>「Rust语言圣经(Rust教程 Rust Course)」</strong>：10. Rust最佳实践</li><li><strong>「Rust By Practice( Rust 练习实践 )」</strong>：4.1 数值类型</li></ul><h2 id="短期规划"><a href="#短期规划" class="headerlink" title="短期规划"></a>短期规划</h2><p>发现内容有点少，那么来水一点短期规划吧。</p><p>从低代码角度，更多的是提升自己对业务的抽象能力，并且把产品落地落下来，是当前首要任务。</p><p>其二是学习 Rust ，其实已经发现学习了 Rust 后对 JavaScript 的看法也有些转变，也印证了我之前对 ECMA 规范的想法，如果想改进 ECMA ，必须从其他语言入手，寻找 JavaScript 缺少的地方等等。学习 Rust 对我自身的能力也是一种提升。</p><p>预计 5月，进入实践阶段。</p><p>5月还计划做的一件事情就是内部技术分享，本来计划着分享一篇《实现自己的 JavaScript 宏》的技术内容，也是受 Rust 的启发，想利用 AST 去实现一些有意思的内容，但是查阅了资料发现，还是需要去学习一些内容，但是我还是想把主题暂定在这个上面去做一些挑战和学习。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>初探 Rust</title>
    <link href="https://zongzi531.com/2022/04/01/%E5%88%9D%E6%8E%A2rust/"/>
    <id>https://zongzi531.com/2022/04/01/%E5%88%9D%E6%8E%A2rust/</id>
    <published>2022-04-01T10:05:50.000Z</published>
    <updated>2022-04-01T10:05:50.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>羡慕老婆先去三亚旅游～而我还在搬砖…</p><p>Rust 依靠着每天一些碎片时间来学习着，等着把基础知识学完成后，开始实践起来，争取写一些工具出来使用。</p><h2 id="低代码基础建设"><a href="#低代码基础建设" class="headerlink" title="低代码基础建设"></a>低代码基础建设</h2><p><strong>我们团队目前有 HC, 需要招从事低代码基础建设的开发人员…</strong></p><p>这个月主要完成的工作是基于团队内部的低代码协议，打通团队内两款低代码平台和工具的资产，比如组件、配置项等。</p><p>这也是当初编写协议的初衷，为了在早期建立起低代码相关的规范。实现自己的低代码引擎！</p><p>提供了一个运行时适配器工具，能够实现类似于微前端形式的不同 UI 框架的渲染 SDK ，同时为内部两款低代码平台和工具提供了 <code>preset</code> 适配。</p><p>再一个就是既然有运行时，那么就必然存在编译时的工具，当然了，编译适配器这么叫肯定不合理，那么我也找了开源社区中并没有像我们这样的可怕需求，就是使用 Vue3 开发，还得兼容 IE 11 。</p><p>对于这个需求来说，我基于 <code>unplugin</code> 实现了一款编译插件，可以将 Vue3 的 SFC 或者 TSX 文件编译成 Vue2 的编译结果，可以使用在 Vue2 环境下的降级兼容。参考了 <code>vue-loader</code> 、 <code>@vue/compiler-sfc</code> 、 <code>vue-template-compiler</code> 、 <code>vue-template-es2015-compiler</code> 、 <code>@vue/babel-preset-app</code> 等工具来实现。截止当前插件已实现基础的降级兼容能力，还有不少边界问题没有处理。</p><p>以 SFC 为例，对其内容进行解析，解析结果主要产出 <code>template</code> 、 <code>script</code> 、 <code>styles</code> 。</p><p><code>template</code> 会带有 <code>with(this) &#123; ...</code> 将其包装后编译成 <code>es2015</code> 后使用， <code>script</code> 则解析语言类型，若是 Typescript 则进入 Babel 处理后更新， <code>styles</code> 则会遍历处理，当然若语言是 <code>postcss</code> 则进行再处理，等等其他补丁操作。</p><p>最后生成 Vue2 编译结果以达成降级兼容。</p><p>那么今年也将主要发力低代码基础建设了，加油！</p><h2 id="绩效"><a href="#绩效" class="headerlink" title="绩效"></a>绩效</h2><p>绩效的调整，对未来的工作来说，即是机遇也是挑战。可以接触到更多的管理模式，对自己来说也是增加压力，达成目标，同样加油！</p><h2 id="开源贡献"><a href="#开源贡献" class="headerlink" title="开源贡献"></a>开源贡献</h2><p>这方面这个月主要集中在 Rust 书籍上的一些修正，既然认真阅读了，那也顺手帮忙修正了一些问题。</p><h2 id="内部建设"><a href="#内部建设" class="headerlink" title="内部建设"></a>内部建设</h2><p>其实非常喜欢开源这套协同工作流程，异步的方式去完成各自的目标。也是参考开源的这套协同流程，现在在内部的 Issues 和 PR 上面也有了不错的的进展。在内部 Wiki 上规范了开设 Issues 和 PR 的模板和要求，大家也能按照要求在上面反映和修复问题。内部组件库也进入了一个更好的迭代更新模式～</p><h2 id="任务进度"><a href="#任务进度" class="headerlink" title="任务进度"></a>任务进度</h2><ul><li><strong>「日本語学習計画」</strong>：语法及词汇 <strong>第1页</strong></li><li><strong>「计算机图形学」</strong>：材质与外观</li><li><strong>「锻炼身体」</strong>：步行、上楼梯、Just Dance、健身环 <strong>待加强</strong></li><li><strong>「ECMA-262」</strong>：6.2.4 The Reference Specification Type</li><li><strong>「Rust语言圣经(Rust教程 Rust Course)」</strong>：6.3.5 工作空间 Workspace (跳过 4 Rust 异步编程)</li></ul>]]></content>
    
    
    <summary type="html">羡慕老婆先去三亚旅游～而我还在搬砖...</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>想旅游</title>
    <link href="https://zongzi531.com/2022/03/01/%E6%83%B3%E6%97%85%E6%B8%B8/"/>
    <id>https://zongzi531.com/2022/03/01/%E6%83%B3%E6%97%85%E6%B8%B8/</id>
    <published>2022-03-01T10:05:13.000Z</published>
    <updated>2022-03-01T10:05:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>冬天渐渐过去了，天气渐渐的要暖和起来了，想计划着带老婆去三亚度个假，挑选一个天气晴朗的好日子出游。</p><p>春节过完年回来后，主要负责组织内低代码项目的基础协议编写，参考阿里提供的两份协议《阿里巴巴中后台前端物料规范》和《阿里巴巴中后台前端搭建协议规范》，并集合组织内两个低代码项目的架构，重新整理并编写两份贴合组织现有低代码项目的协议内容，以整合两个项目的基础架构和物料资源。</p><p>再一个就是在完成两份协议后，进行基础架构的设计和开发，正在进行中……</p><p>回到自身，在春节放假前其实已经想明白，要学习 Rust ，那么回来也没闲着，利用休息时间学习 Rust 知识，待学习完成后进入实践状态。</p><p>开源社区方面，这个月对多处 Rust 教程书写错误进行了修正，以及对 Element Plus 进行了一次类型修复。</p><p>要说能写在这里的内容，似乎还不如直接去看 Rust 教程或者我的 Github 主页。</p><p>其余的话就是对组织内的基础建设支持了。</p><h2 id="任务进度"><a href="#任务进度" class="headerlink" title="任务进度"></a>任务进度</h2><ul><li><strong>「日本語学習計画」</strong>：语法及词汇 <strong>第1页</strong></li><li><strong>「计算机图形学」</strong>：材质与外观</li><li><strong>「锻炼身体」</strong>：步行、上楼梯、Just Dance、健身环 <strong>待加强</strong></li><li><strong>「ECMA-262」</strong>：6.2.4 The Reference Specification Type</li><li><strong>「Rust语言圣经(Rust教程 Rust Course)」</strong>：3.2.1 闭包 Closure</li></ul><p>回到家其实一直有想学习日语的想法，但是白天消耗的精力实在太多了，还是看情况而定吧……当然了，要学的东西一样也不会少，加油吧。</p><p>话说回来，最近我的厨艺确实有了点提升，老婆经常夸我烧的菜好吃～因为上班的关系，老婆总会说“好想吃你做的菜”，嘿嘿～</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>虎虎生威</title>
    <link href="https://zongzi531.com/2022/02/01/%E8%99%8E%E8%99%8E%E7%94%9F%E5%A8%81/"/>
    <id>https://zongzi531.com/2022/02/01/%E8%99%8E%E8%99%8E%E7%94%9F%E5%A8%81/</id>
    <published>2022-02-01T17:01:10.000Z</published>
    <updated>2022-02-01T17:01:10.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>春节快乐！～</p><p>其实这一年下来发现，自己仍然在开发这个环境中打转，但是也很明显的发现自己的侧重方向发生了转变，首当其冲的是加强了自己对 TypeScript 的使用能力，通过对 TypeScript 的进阶挑战做题和帮助同事解决使用过程中遇到的高阶类型推导问题来提升这方面的能力，截止今年年初，部门内部 TypeScript 的使用率较去年有大幅度提升，从去年的 20% 的使用率到今年年初的近 80% 使用率，可以说同事们对 TypeScript 的接纳程度也越来越好了。</p><p>其次就是自己这一年在编译方面也有了更多的关注和实践，真实的接触了 AST 的部分结构，开发编译插件来提升同事们的开发体验和提供友好的同构产物，使用 AST 来处理补充代码、替换或移除代码、清除注释块中的代码等等场景……在有过这些铺垫后，当下，我会有想学习 Rust 的冲动。<a href="https://course.rs/">《Rust语言圣经(Rust教程 Rust Course)》</a>，这可能是我会学习的下一门编程语言（本来想说第二门的，但是我接触过的语言也有好几门，虽然用不到）。</p><p>业务交付的话就是基本的需求排期、功能开发、缺陷修复、功能自测工作了。</p><p>当然了，去年年中时候定下的中期目标仍然会一直伴随我</p><ul><li>35 岁前，有一份轻松快乐的副业</li><li>35 岁，打稳主业基础，尝试更多突破</li></ul><p>话说回来，春节前进行了几次 2022 年工作方向的汇报和讨论，对产品商业价值这一问题形成了一个很简单的认识，但是对如何寻找产品的切入点、寻找商业价值这一系列问题上，暂时还是无从下手，这也是我缺乏的能力，或许具备了某些方法论和商业眼光的话，或许就会出现好的机会。</p><h1 id="基础建设"><a href="#基础建设" class="headerlink" title="基础建设"></a>基础建设</h1><p>首先是微前端的支持工作，包含提供技术架构、技术支持、新特性支持和缺陷修复工作。在同事开发过程中不免会遇到一些写法造成当初架构未考虑到的情况，那么解决业务问题当然是第一位的，发布新特性支持和缺陷修复就成为了微前端架构的迭代路径。也同时在今年年中，依靠此技术架构构建的项目体积增长到了 100 多兆，并且自动化的时间也变得缓慢，解决此问题也刻不容缓，经过一些解决思路的整理，最终提升自动化时间和缩小项目的大小，性能提升近70% 。</p><p>差点忘了提，自动化的环节使用了动态构建平台，可以任意撮合各项目之间的子应用关系，组成一个新应用来复用开发。</p><p>再来就是基于 Vue3 的内部组件库开发工作，结合设计部门一起打造新的内部组件库，带着新的设计风格进入 beta 版本。</p><p>这一年，内部标准代码风格也进行了迭代，根据会议内容进行了相应的调整。</p><p>再一个就是低代码建设，也是今年的主要工作内容，工作相关的关键点在之前的博客中有提到，这里就不再提了。</p><h1 id="技术分享"><a href="#技术分享" class="headerlink" title="技术分享"></a>技术分享</h1><ul><li>《追求优雅的代码2》</li><li>《进阶 TypeScript 之初见泛型》</li><li>《现代 Web 应用的资源及网络优化分享》</li></ul><h1 id="开源贡献"><a href="#开源贡献" class="headerlink" title="开源贡献"></a>开源贡献</h1><ul><li><a href="https://github.com/element-plus/element-plus">element-plus</a> <a href="https://github.com/element-plus/element-plus/pull/1953">#1953</a> <a href="https://github.com/element-plus/element-plus/pull/1963">#1963</a> <a href="https://github.com/element-plus/element-plus/pull/1975">#1975</a> <a href="https://github.com/element-plus/element-plus/pull/2050">#2050</a></li><li><a href="https://github.com/element-plus/vite-plugin-element-plus">vite-plugin-element-plus</a> <a href="https://github.com/element-plus/vite-plugin-element-plus/pull/2">#2</a> <a href="https://github.com/element-plus/vite-plugin-element-plus/pull/5">#5</a></li><li><a href="https://github.com/type-challenges/type-challenges">type-challenges</a> <a href="https://github.com/type-challenges/type-challenges/pull/2158">#2158</a></li><li><a href="https://github.com/fczbkk/css-selector-generator">css-selector-generator</a> <a href="https://github.com/fczbkk/css-selector-generator/pull/132">#132</a></li></ul>]]></content>
    
    
    <summary type="html">春节快乐！～</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>２０２２年おめでとうございます</title>
    <link href="https://zongzi531.com/2022/01/01/%EF%BC%92%EF%BC%90%EF%BC%92%EF%BC%92%E5%B9%B4%E3%81%8A%E3%82%81%E3%81%A7%E3%81%A8%E3%81%86%E3%81%94%E3%81%96%E3%81%84%E3%81%BE%E3%81%99/"/>
    <id>https://zongzi531.com/2022/01/01/%EF%BC%92%EF%BC%90%EF%BC%92%EF%BC%92%E5%B9%B4%E3%81%8A%E3%82%81%E3%81%A7%E3%81%A8%E3%81%86%E3%81%94%E3%81%96%E3%81%84%E3%81%BE%E3%81%99/</id>
    <published>2022-01-01T13:13:21.000Z</published>
    <updated>2022-01-01T13:13:21.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><blockquote><p>2021 年，负责内部组件库，TypeScript 进阶，工程化实践，接触低代码，核心架构设计，做技术分享等等。<br>2022 年，持续前进，明确目标。</p></blockquote><h2 id="回顾-2021-年"><a href="#回顾-2021-年" class="headerlink" title="回顾 2021 年"></a>回顾 2021 年</h2><ul><li><strong><span class="github-emoji" alias="couplekiss_man_woman" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f469-2764-1f48b-1f468.png?v8">👩️‍❤️‍💋️‍👨</span> 更爱老婆，和她开心幸福在一起</strong></li><li><strong><span class="github-emoji" alias="heartpulse" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f497.png?v8">💗</span> 更爱家人，祝家人身体健康，平平安安</strong></li><li><strong><span class="github-emoji" alias="horse_racing" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f3c7.png?v8">🏇</span> 锻炼身体</strong> <code>微量</code></li><li><strong><span class="github-emoji" alias="notebook_with_decorative_cover" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d4.png?v8">📔</span> 日本語学習文法・語彙</strong> <code>语法及词汇 第1页</code></li><li><strong><span class="github-emoji" alias="books" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4da.png?v8">📚</span> 建立自己的前端知识体系</strong> <code>持续进行</code></li><li><strong><span class="github-emoji" alias="hammer_and_wrench" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f6e0.png?v8">🛠</span> 学习前端自动化工程体系</strong> <code>持续进行</code></li><li>阅读 ECMA 标准 <code>6.2.4 The Reference Specification Type</code></li><li>学习 OKR</li></ul><h2 id="展望-2022-年"><a href="#展望-2022-年" class="headerlink" title="展望 2022 年"></a>展望 2022 年</h2><ul><li><strong><span class="github-emoji" alias="couplekiss_man_woman" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f469-2764-1f48b-1f468.png?v8">👩️‍❤️‍💋️‍👨</span> 更爱老婆，和她开心幸福在一起</strong></li><li><strong><span class="github-emoji" alias="heartpulse" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f497.png?v8">💗</span> 更爱家人，祝家人身体健康，平平安安</strong></li><li><strong><span class="github-emoji" alias="horse_racing" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f3c7.png?v8">🏇</span> 锻炼身体</strong></li><li><strong><span class="github-emoji" alias="notebook_with_decorative_cover" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d4.png?v8">📔</span> 日本語学習文法・語彙</strong></li><li><strong><span class="github-emoji" alias="books" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4da.png?v8">📚</span> 建立自己知识体系</strong><ul><li>阅读 ECMA 标准</li><li>学习计算机图形学&#x2F;可视化领域</li><li>实践 Three.js</li><li>学习服务端架构</li><li>学习产品思维</li></ul></li></ul><h2 id="持续进行"><a href="#持续进行" class="headerlink" title="持续进行"></a>持续进行</h2><ul><li>关注 ECMA 标准 &#x2F; ECMAScript Next</li><li>关注前端发展趋势</li><li>关注 NPM 社区</li><li>关注 TypeScript</li><li>学习算法</li><li>学习 CSS</li><li>至少 2 场技术分享</li></ul><h2 id="优先级较低的规划"><a href="#优先级较低的规划" class="headerlink" title="优先级较低的规划"></a>优先级较低的规划</h2><ul><li>了解 JavaScript 在不同宿主环境下的表现</li><li>尝试实践渲染性能优化</li><li>尝试 Angular、Ember.js</li><li>尝试 Progressive Web Apps</li><li>尝试 WebAssembly</li><li>学习 Web Accessibility</li></ul><h2 id="📚-建立自己知识体系"><a href="#📚-建立自己知识体系" class="headerlink" title="📚 建立自己知识体系"></a><span class="github-emoji" alias="books" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4da.png?v8">📚</span> 建立自己知识体系</h2><p>怎么说呢，今年的学习其实较去年来说，变得缓慢了……</p><p>当然了，形成自己的知识体系必然重要，现在看来其实可以跑出「前端」这个范围，而是从一个更广更大的范围形成自己的知识体系。</p><p>我来一点点说明，从语言这个角度出发，我们需要具备对 ECMA 标准的认识，并且能够在宿主环境中找到可优化的方案，从而在 TC39 发起提案。</p><p>可以说是一条非常牛逼的道路，并且从中还会学习更底层的语言，对 JS 的认识会有大幅度提升，对宿主环境（V8）有着清晰的认识。</p><p>从样式的角度出发，也不乏是一个走的人不太多的道路，通过学习 CSS 规范并加以实践，形成自己对宿主环境表现的认知体系，不断总结，尝试更高阶的使用方式，掌握样式带来的渲染性能优化等等能力。</p><p>从计算机图形学、可视化这类角度出发，掌握图形学基础，也可以在「前端」以外的地方发力，比如做一款游戏是一件很有成就感的事情。</p><p>从服务端的角度则是后端技术，我也不太了解，总之这是一条路。</p><p>从技术架构这个角度出发，需要学会对每一种技术优劣形态的分析，并且能够在当前的场景下选择合适的解决方案，同样具备在未来 5 - 10 年可升级、并且含有兜底的技术方案，这条路需要具备大量的技术能力，当然还需要掌握最前沿的技术，不过各个角度都需要掌握最前沿的技术。</p><p>从项目的角度出发，需要能够负责项目的可行性、推进和落地的能力，同时需要具备能够对项目进行合理排期、风险把控等管理能力。对了，关于项目孵化的这块内容，同时需要具备商业价值的探索、立项、结合 OKR 形成核心目标，从痛点切入等等。</p><p>大概目前能想到的就是这些内容，这些角度可以同时并行，我认为不影响，只要你能力足够强大……</p><p>经过这一年，慢慢回顾其实发现自己做的最多的是关于逻辑相关的工作，会让自己觉得可能是擅长逻辑？缺乏思维创新和审美创新，当然这有可能是没有尝试过另外一块领域导致自己有这样的刻板印象，不过没什么关系，可以尝试学习一些专业的书籍以尝试看看。</p><p>不过还是需要进行大量的体验、学习、比对、总结和积累，才会形成自己的一套体系。</p><p>有一点其实我也慢慢想明白了，我想 Remote 远程办公。</p><p>这就是我这一年对职业的新看法，其实比去年来说，不会再聚焦于「前端」这个词，而是看的更多更广了。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>想冲刺的Q4</title>
    <link href="https://zongzi531.com/2021/12/01/%E6%83%B3%E5%86%B2%E5%88%BA%E7%9A%84Q4/"/>
    <id>https://zongzi531.com/2021/12/01/%E6%83%B3%E5%86%B2%E5%88%BA%E7%9A%84Q4/</id>
    <published>2021-12-01T10:38:26.000Z</published>
    <updated>2021-12-01T10:38:26.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>转眼间，已经迎来 12 月了，马上 2021 年也将过完。<br>回顾这一年，技术上面带来的深入并没有很多，更多的可能是一些思路上的深入吧……<br>或许这是给自己技术上没有深入的一个借口，同样日语的学习也停滞不动，好难提起精神来苦读一番……</p><p>这个月仍然是负责内部的低代码平台开发工作，因为平台组件开发需要编写额外的代码，所以平台的构建产物需要把这块内容去掉的，那么编写了一个基于 <code>unplugin</code> 的插件工具，用于清洗组件内平台运行层的代码。</p><p>从学习 <code>unplugin</code> 相关插件中学习到使用 Yarn2 可以带来的 Workspaces 工作模式，因为开发环境导致无法在内网实践这个 Yarn2 的特性，也有可能是因为自己的姿势不对所导致，不过没关系，我来简单的回顾一下这个特性。</p><p>比如需要发布的工具内含示例，那么示例又引用到了外层的发布内容，按照以往的方式，我们会选用相对路径、或者按照已在线上发布的版本、或者 Lerna 来进行管理，但是我发现 Yarn2 的工作区模式实在是方便（虽然我没有实践）</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"dependencies"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"star"</span><span class="token operator">:</span> <span class="token string">"workspace:*"</span><span class="token punctuation">,</span>    <span class="token property">"caret"</span><span class="token operator">:</span> <span class="token string">"workspace:^"</span><span class="token punctuation">,</span>    <span class="token property">"tilde"</span><span class="token operator">:</span> <span class="token string">"workspace:~"</span><span class="token punctuation">,</span>    <span class="token property">"range"</span><span class="token operator">:</span> <span class="token string">"workspace:^1.2.3"</span><span class="token punctuation">,</span>    <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"workspace:path/to/baz"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只需要这样配置即可转换成你想要的版本形式，转换结果如下：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"dependencies"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"star"</span><span class="token operator">:</span> <span class="token string">"1.5.0"</span><span class="token punctuation">,</span>    <span class="token property">"caret"</span><span class="token operator">:</span> <span class="token string">"^1.5.0"</span><span class="token punctuation">,</span>    <span class="token property">"tilde"</span><span class="token operator">:</span> <span class="token string">"~1.5.0"</span><span class="token punctuation">,</span>    <span class="token property">"range"</span><span class="token operator">:</span> <span class="token string">"^1.2.3"</span><span class="token punctuation">,</span>    <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"1.5.0"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为没有实践，官方的文档链接请点击 <a href="https://yarnpkg.com/features/workspaces">Workspaces</a></p><p>同样还学习到 Node.js 12.7 的 Exports Field 语法，此语法可算是谁用谁知道，谁用谁舒服呀！</p><p>比如说有这样一段 package.json 配置项</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"my-awesome-lib"</span><span class="token punctuation">,</span>  …  <span class="token property">"exports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"."</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"browser"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"default"</span><span class="token operator">:</span> <span class="token string">"./lib/whole-lib.browser.js"</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"module-a"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"import"</span><span class="token operator">:</span> <span class="token string">"./lib/public-module-a.mjs"</span><span class="token punctuation">,</span>      <span class="token property">"require"</span><span class="token operator">:</span> <span class="token string">"./lib/public-module-a.cjs"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"module-b"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"import"</span><span class="token operator">:</span> <span class="token string">"./lib/public-module-b.mjs"</span><span class="token punctuation">,</span>      <span class="token property">"require"</span><span class="token operator">:</span> <span class="token string">"./lib/public-module-b.cjs"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当你使用时就会非常的方便</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token keyword">import</span> whole <span class="token keyword">from</span> <span class="token string">'my-awesome-lib'</span><span class="token keyword">import</span> publicModuleA <span class="token keyword">from</span> <span class="token string">'my-awesome-lib/module-a'</span><span class="token keyword">import</span> publicModuleB <span class="token keyword">from</span> <span class="token string">'my-awesome-lib/module-b'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>懂吧！就很舒服！</p><p>自己编写插件的过程中也学习大佬们写的代码，结合产出自己的清洗插件，总的来说使用到了 <code>es-module-lexer</code> 进行 <code>import</code> 检查，替换入口位置、使用 Babel 进行 AST 解析，进行源码的参数和调用改写、最后使用 <code>magic-string</code> 进行替换。 </p><p>并且增加新的特性，支持删除特定注释块，比如你代码中有这样一段代码</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// @lowcode-ignore-start</span><span class="token keyword">const</span> handleRemove <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// @lowcode-ignore-end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过清洗插件后，这段代码会被删除，当前此功能是我自己实现的，不过大佬和我说 <code>terser</code> 就可以完成此操作，还没去了解。后面可以去把这块功能由 <code>terser</code> 替换掉。</p><p>同样也发现代码有包含 <code>npm -C ...</code> 这样的脚本命令，我也查阅了些资料，找到了 Yarn 的命令 <code>yarn -cwd</code>， 提到这个我就想是不是时候要转 <code>pnpm</code> 了，说个题外话，最近前端工程话使用 Rust 的复刻工具都在疯狂爆出来，感觉提效的另一种方式就是让工程化更快吧。</p><p>也遇到了坑，比如在 <code>tsconfig.json</code> 的 <code>include</code> 属性中加入了一些快捷的 d.ts 工具类型，但是构建后的 d.ts 并不会对这些工具类型解析，以至于使用包的时候会有报错提示，因为找不到这些工具类型，后面采用手动导入导出的形式解决了这个问题。</p><p>还有其他比如 postcss 未完全编译导致的使用时解析错误的问题，VuePress2 尝鲜写了一个开发者文档，支持组件渲染，TypeScript 引用使用相对路径可以避免文件构建结果内容缺失的问题等等</p><p>就前两天，发生了一个比较严重的事故算是，本来是想升级 Hexo 的插件 <code>hexo-renderer-ejs</code> 的，但是因为我操作的失误导致未提交的文件被我使用 <code>git reset --hard ...</code> 强制干掉了……</p><p>我当时人都傻了，好几个文件白写了，查阅了各种资料都没办法恢复，还好狗屎运，这是 Hexo ，在项目的根目录有一个 db.json 文件……，靠着他我把那些被我误删的文件恢复回来了……</p><p>然后我在 VSCode 中安装了一个 Local History 的插件，要是在别的场景下，我可能真的凉凉了……</p><p>说起这次升级，因为本来的主题文件语法有被废弃，这次我使用正则表达式进行一键替换，方便又快捷，可算是。搜索 <code>&lt;% include (\S+).ejs %&gt;</code> 替换 <code>&lt;%- include(&#39;$1&#39;) %&gt;</code> 即可。</p><h2 id="任务进度"><a href="#任务进度" class="headerlink" title="任务进度"></a>任务进度</h2><ul><li><strong>「日本語学習計画」</strong>：语法及词汇 <strong>第1页</strong></li><li><strong>「计算机图形学」</strong>：材质与外观</li><li><strong>「锻炼身体」</strong>：步行、上楼梯、Just Dance <strong>待加强</strong></li><li><strong>「ECMA-262」</strong>：6.2.4 The Reference Specification Type</li></ul>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>想去日本旅游</title>
    <link href="https://zongzi531.com/2021/11/01/%E6%83%B3%E5%8E%BB%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8/"/>
    <id>https://zongzi531.com/2021/11/01/%E6%83%B3%E5%8E%BB%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8/</id>
    <published>2021-11-01T14:10:07.000Z</published>
    <updated>2021-11-01T14:10:07.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>想法见标题，因为疫情的关系，真的是有点难受。</p><p>想去横滨看元祖高达，也不知道疫情啥时候才能好，估计到时候横滨的元祖高达就被搬走了……</p><p>这个月，在公司内部做了一次《现代 Web 应用的资源及网络优化分享》分享，跟之前的分享区别就是面向公司的分享。</p><p>分享内容罗列了当前 Web 应用场景的下资源及网络优化的策略及方向，以及在微前端场景下的实战经验。</p><p>因为国庆放假回来就三周的工作时间，主要忙于内部低代码平台的开发。</p><p>最近让我感触最深的就是对产品的理解，如何做好产品设计等等方面。</p><p>类似于解决问题的最短路径，虽然不是很专业无法归纳，但是能很明显感受到，新产品就像大家一起精心培育出来的一样，试着想去让产品变得更好用。</p><p>回看今年的任务进度，当前已经是 Q4 ，并且即将过半。</p><p>今年的任务也没完成多少，不过没关系。</p><p>我觉得尽力而为也不错，如果遇到调整我也可以尽快的调整我的行进路线。</p><p>总之加油。</p><h2 id="任务进度"><a href="#任务进度" class="headerlink" title="任务进度"></a>任务进度</h2><ul><li><strong>「日本語学習計画」</strong>：语法及词汇 <strong>第1页</strong></li><li><strong>「计算机图形学」</strong>：材质与外观</li><li><strong>「锻炼身体」</strong>：简单运动 <strong>待加强</strong></li><li><strong>「ECMA-262」</strong>：6.2.4 The Reference Specification Type</li></ul>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>天还没凉快起来</title>
    <link href="https://zongzi531.com/2021/10/09/%E5%A4%A9%E8%BF%98%E6%B2%A1%E5%87%89%E5%BF%AB%E8%B5%B7%E6%9D%A5/"/>
    <id>https://zongzi531.com/2021/10/09/%E5%A4%A9%E8%BF%98%E6%B2%A1%E5%87%89%E5%BF%AB%E8%B5%B7%E6%9D%A5/</id>
    <published>2021-10-09T13:32:03.000Z</published>
    <updated>2021-10-09T13:32:03.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>讲道理，现在的气候真的太奇怪了，都 10 月份了，还这么热……</p><blockquote><p>摄于 20210912 06:43 酒店餐厅给老婆拍早餐</p></blockquote><h2 id="任务进度"><a href="#任务进度" class="headerlink" title="任务进度"></a>任务进度</h2><ul><li><strong>「日本語学習計画」</strong>：语法及词汇 <strong>第1页</strong></li><li><strong>「计算机图形学」</strong>：材质与外观</li><li><strong>「锻炼身体」</strong>：简单运动 <strong>待加强</strong></li><li><strong>「ECMA-262」</strong>：6.2.4 The Reference Specification Type</li></ul><p>我自己都不太看的下去了，任务进度停滞的问题很明显，但是其实也还好。毕竟 9 月是我和老婆的大喜日子，我们结婚咯！～</p><p>最近基本都在置办婚礼相关的事情，现在有了我们的家，当然要好好经营啦，毕竟家更重要！～</p><h2 id="最近的工作"><a href="#最近的工作" class="headerlink" title="最近的工作"></a>最近的工作</h2><p>除去基本的服务业务，主要精力就是在开发内部的低代码平台，作为核心开发目前主要负责整体插件系统设计与实现、逻辑编排功能设计与实现等核心功能实现和工作安排及进度推进。</p><p>当然了，还需要负责内部 UI 库的代码审查、缺陷修复和发布更新工作，期间还持续更新了内部标准代码风格。</p><h2 id="一些新思考"><a href="#一些新思考" class="headerlink" title="一些新思考"></a>一些新思考</h2><p>在 8 月底做了一次技术分享，因为对技术的掌握片面导致没有把技术讲透彻，被大佬指导了一番……</p><p>有关 C &#x2F; C# 的技术掌握自己确实欠缺（亏我在大学里还学过 C# ……）</p><p>包括在最近看到的一篇文章<a href="https://zhuanlan.zhihu.com/p/417534662">《用Rust锈化Vue Compiler》</a>，引用作者的一段回复：</p><blockquote><p>先学好TS理解现代编程语言的概念，然后学Rust（主要以clone和Rc为主）。再学习C语言和阅读C++的笑话集，之后可以学习Rust的生命周期部分</p></blockquote><p>其实可以想到，前端除了之前想到的几个路线，往广义上去思考其实往更深去学习，需要具备 C &#x2F; C++ 、计算机基础这类知识储备，不能狭隘的只停留在 JavaScript 上，因为从某些角度想虽然 JavaScript 能实现很多，但是仍然是被大佬们包装过的语言，如果要想更自由的去控制计算机，这条路线是一条可以深入并且长期发展的路线。</p><p>并且当未来发生某些变化时，具备如此底层的知识在切换技术栈时也会变得轻松。</p>]]></content>
    
    
    <summary type="html">讲道理，现在的气候真的太奇怪了，都 10 月份了，还这么热……</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Hello Swing</title>
    <link href="https://zongzi531.com/2021/09/01/hello-swing/"/>
    <id>https://zongzi531.com/2021/09/01/hello-swing/</id>
    <published>2021-09-01T13:10:37.000Z</published>
    <updated>2021-09-01T13:10:37.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>这个月周末都在学习摇摆舞，也是抱着尝试一下的心态报名学习的，不过真的在跳摇摆舞的时候心情会很愉悦，哈哈，尤其是和老婆一起跳的时候。</p><h2 id="任务进度"><a href="#任务进度" class="headerlink" title="任务进度"></a>任务进度</h2><ul><li><strong>「日本語学習計画」</strong>：语法及词汇 <strong>第1页</strong></li><li><strong>「计算机图形学」</strong>：材质与外观</li><li><strong>「锻炼身体」</strong>：简单运动 <strong>待加强</strong></li><li><strong>「ECMA-262」</strong>：6.2.4 The Reference Specification Type</li></ul>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>《进阶 TypeScript 之初见泛型》</title>
    <link href="https://zongzi531.com/2021/08/20/%E8%BF%9B%E9%98%B6TypeScript%E4%B9%8B%E5%88%9D%E8%A7%81%E6%B3%9B%E5%9E%8B/"/>
    <id>https://zongzi531.com/2021/08/20/%E8%BF%9B%E9%98%B6TypeScript%E4%B9%8B%E5%88%9D%E8%A7%81%E6%B3%9B%E5%9E%8B/</id>
    <published>2021-08-20T09:28:10.000Z</published>
    <updated>2021-08-20T09:28:10.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><blockquote><p><a href="https://github.com/zongzi531/daily-learning/blob/master/share/%E8%BF%9B%E9%98%B6%20TypeScript%20%E4%B9%8B%E5%88%9D%E8%A7%81%E6%B3%9B%E5%9E%8B.pdf">链接</a></p></blockquote><p>大家晚上好，特别为大家做这次分享，因为现在几个团队都开始使用 TypeScript 了，那么除了在日常的 TypeScript 基础使用外，我想给大家带来一些 TypeScript 的进阶使用，那么本次为大家分享有关泛型的进阶入门技巧。</p><p>那我们现在就从为什么会有泛型来说什么是泛型，让我们看到这段代码，我们定义了一个 <code>identity</code> 函数，他用来处理 <code>number</code> 类型的数据，并返回 <code>number</code> 类型的数据。再来看到下一段代码，当这个函数要处理另外的类型的时候，我们不得不定义另外的类型，比如在 <code>number</code> 的基础上添加 <code>string | Array&lt;string&gt;</code> 等等类型，当然这里可以用到函数重载的概念，不过我这里要硬生生的引出泛型。</p><p>最后我们来看到这段代码，我们可以在使用的时候借助 TypeScript 的类型推断自动来使用，或者说我们可以传入类型来定义我们想要的类型，比如 <code>identity&lt;boolean&gt;(true)</code> ，这就是泛型。</p><p>我给大家摘抄了官方提供的全局泛型，见 <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html">Utility Types</a> 。</p><p>官方提供的这些泛型可以说使用起来非常的方便，并且大家在日常开发当中也用到了许多，那么如何自己书写泛型呢？从这里开始将是本次分享的重点。</p><p>我们来看到例子1，这里的 <code>isString</code> 并没有 <code>typeof value === &#39;string&#39;</code> 来的好用，因为 <code>isString</code> 不能进行类型推断，有同学可能会说，我在下面对 <code>el</code> 使用断言，从代码运行上来说，这确实没什么问题。但是既然使用了 TypeScript ，就应该让类型推断变的更自然，而不是用断言来解决问题，这样和写 JavaScript 又有什么区别呢？那么其实很简单，我们将函数返回的 <code>boolean</code> 修改成 <code>value is string</code> 这样就可以实现类型推断了。</p><p>是不是很有趣，再进阶一步讲，我们是不是可以将这个 <code>isString</code> 函数改造一下，是他变成一个更通用的泛型。</p><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">function</span> isSomething <span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> T<span class="token punctuation">)</span><span class="token punctuation">:</span> value is T<span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token function">isSomething</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// isSomething&lt;number></span><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token function">isSomething</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// isSomething&lt;string></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>非常的妙是不是。再来看到例子2，假设我们要写一个样式对象，但是我们需要自己考虑兼容性，比如会加入前缀 <code>webkit</code> ，那么我们自然会一个个把他们写出来，但是在维护类型的时候会带来很多繁琐的问题，比如说我修改 <code>flex</code> 的类型时，我还需要顺带修改 <code>webkit</code> 前缀的对应的类型，当这种场景变得多又复杂时，代码的维护成本就会逐渐提升。</p><p>那么当然是有办法解决解决这样的问题的，首先我们需要利用一些手段将 <code>flex</code> 转换成 <code>webkitFlex</code> ，然后将 <code>interface</code> 的 key 换成我们想要的内容。</p><p>到目前为止，我们已经可以实现 key 的替换，但是原来的 key 却不见了，所以我们这里需要借助 <code>| P</code> 来完成，来实现我们的需求。到目前为止我们已经完成了我们想要的，我们再来进阶一步讲，把问题变得有趣，我们这里希望经过转换后， <code>lineHeight</code> 是不会加 <code>webkit</code> 前缀的，怎么实现呢。</p><pre class="line-numbers language-typescript"><code class="language-typescript">type WebkitKey<span class="token operator">&lt;</span>K <span class="token keyword">extends</span> <span class="token class-name">string</span><span class="token operator">></span> <span class="token operator">=</span> K <span class="token keyword">extends</span> <span class="token string">'lineHeight'</span> <span class="token operator">?</span> never <span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`webkit</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>Capitalize<span class="token operator">&lt;</span>K<span class="token operator">></span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，我们就可以实现新的需求，当然了这里还是可以结合例子1进行进阶。</p><pre class="line-numbers language-typescript"><code class="language-typescript">type ExcludeWebkitKey <span class="token operator">=</span> <span class="token string">'lineHeight'</span> <span class="token operator">|</span> <span class="token string">'something you need.'</span>type WebkitKey<span class="token operator">&lt;</span>K <span class="token keyword">extends</span> <span class="token class-name">string</span><span class="token punctuation">,</span> E <span class="token operator">=</span> ExcludeWebkitKey<span class="token operator">></span> <span class="token operator">=</span> K <span class="token keyword">extends</span> <span class="token class-name">E</span> <span class="token operator">?</span> never <span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`webkit</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>Capitalize<span class="token operator">&lt;</span>K<span class="token operator">></span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>哈哈，是不是也非常的有趣。确实，就是这么有趣。</p><p>那么我们来看到例子3，我们如何可以在 <code>methods</code> 下的方法中获得到 <code>data</code> 返回的类型呢，我这边摘抄了官网的例子，大家可以看一下。</p><p>其实我们的例子和官网的区别就是官网是个对象，而我们是个函数，我们只要把 <code>D</code> 修改成 <code>() =&gt; D</code> 就可以了。</p><p>那么本次的分享就到这里，后面我也会尝试总结更多的技巧分享到大家。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Share" scheme="https://zongzi531.com/categories/Share/"/>
    
    
    <category term="TypeScript" scheme="https://zongzi531.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>持续挺进</title>
    <link href="https://zongzi531.com/2021/08/01/%E6%8C%81%E7%BB%AD%E6%8C%BA%E8%BF%9B/"/>
    <id>https://zongzi531.com/2021/08/01/%E6%8C%81%E7%BB%AD%E6%8C%BA%E8%BF%9B/</id>
    <published>2021-08-01T13:39:29.000Z</published>
    <updated>2021-08-01T13:39:29.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><h2 id="任务进度"><a href="#任务进度" class="headerlink" title="任务进度"></a>任务进度</h2><ul><li><strong>「日本語学習計画」</strong>：语法及词汇 <strong>第1页</strong></li><li><strong>「计算机图形学」</strong>：材质与外观</li><li><strong>「锻炼身体」</strong>：简单运动 <strong>待加强</strong></li><li><strong>「ECMA-262」</strong>：6.1.7.3 Invariants of the Essential Internal Methods</li><li><strong>「<code>Type&lt;Challenge[]&gt;</code>」</strong>：<img src="https://camo.githubusercontent.com/8aa86fec69f7058be373c9d85c7a81801a934668476172dd4b3d48e4a05b5538/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f2d3135312545332538332542425175657279253230537472696e672532305061727365722d623131623864" alt="151・Query String Parser"></li><li><strong>「OKR工作法」</strong></li></ul><blockquote><p><code>Type&lt;Challenge[]&gt;</code> 进入到 <img src="https://camo.githubusercontent.com/4c893b9915ad480e68f7b53b53e2d84a4914ea1f9ed0a45593eb5606dfb73043/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f65787472656d652d31322d623131623864" alt="extreme"> 模式，后面的题目暂时先不做了，等进阶一段时间再继续尝试吧，计划以这个挑战为例，做一次有关 TypeScript 进阶的技术分享，争取今年做 3 次分享。</p></blockquote><h2 id="OKR工作法"><a href="#OKR工作法" class="headerlink" title="OKR工作法"></a>OKR工作法</h2><p>在读完 OKR工作法后，会印象更深刻，因为目前团队的模式已经基于 OKR 实践了近 1 年的时间，也能看到确实多多少少有影响到团队的成员。总结来说，OKR就是让团队聚焦在优先级最高的任务上，并且会在阶段性同步任务进度，可以以更快的响应速度进行任务调整，避免将精力转移到不重要的任务上。同样需要具备，任务的描述需要是激进的，有挑战的。而不是轻松可以完成的或不可能完成的。</p><p>其实可以发现，在我个人每年的任务目标上，确实有列不少想做的事情，也同样分着优先级，同样都是具备挑战性的。在我一样样将任务完成时，会带有激情和成就感。</p><h2 id="微前端资源共享优化"><a href="#微前端资源共享优化" class="headerlink" title="微前端资源共享优化"></a>微前端资源共享优化</h2><p>在之前发现微前端构建后，重复资源没有利用起来的情况下，对构建流程进行优化，利用 <code>externals</code> + <code>html-webpack-plugin</code> 将子应用公共资源使用 CDN 替换。</p><p>目前对内部 3 个平台进行改造优化，实现资源大小，缩小 70% 。构建速度提升 40% 。</p><p>其实本来想采用 <code>splitChunks</code> 的方案来抽离应用中的公共模块，但是这不符合资源共享的特征，并且在实践过程中发现成本远高于现在实现的方案。</p><h2 id="低代码中台搭建平台核心功能开发"><a href="#低代码中台搭建平台核心功能开发" class="headerlink" title="低代码中台搭建平台核心功能开发"></a>低代码中台搭建平台核心功能开发</h2><p>当前低代码平台可以说是非常火热，同样的我们内部也在早前就萌生了低代码平台提效业务的想法，但是作为开发的我们，在每一次碰撞思维的时候，太过容易发散，在最近我们拉拢了一个产品来参与到我们的项目，确实是明智之选，产品很好的收拢了我们发散的思维，和我们共同确认了我们的任务优先级，有序的推进平台的开发进度。</p><p>回顾起来，产品的加入，有效的理清楚了我们发散的思路，有规范的合规了产品的生命周期，感受起来其实也有点像 OKR ，总之，从产品身上学习了不少经验。</p><p>也同样的，我参与了市场竞品的分析和比较，那么回到本次的主题。我负责核心（ CORE ）的功能开发，整体基于插件体系和发布订阅进行设计，将左侧插件栏、顶部工具栏、右侧配置栏，以及中间画布结合，通过插件体系和发布订阅进行组合。</p><p>值得高兴的是，目前核心功能的开发即将进入尾声，结合同事画布的开发配合，可以进入迭代开发的进度了。</p><h2 id="Element-Plus"><a href="#Element-Plus" class="headerlink" title="Element Plus"></a>Element Plus</h2><p>和作者有谈论到为何在源码中会出现 <code>TODO: change it to symbol</code> ，本来打算提一个 PR 的，但是采用 <code>string</code> 其实是有历史原因的，因为在目前单独发包的时候，如果使用 <code>Symbol</code> 的话，会出现 <code>Symbol</code> 不同的情况。</p><p>那么其实这算是历史遗留问题，我们内部在 Element Plus 基础上已经换成了 workspace 的发包模式，如可以通过 <code>yarn add @element-plus/affix</code> 进行单独安装，而本身的 <code>element-plus</code> 则是将这些子包以依赖的形式关联。理论上这没问题，有待进一步测试和实践，我们拭目以待吧。</p><p>再回到需求方面， Element Plus 也在切换到 CSS Var 和 SVG Icon 等等，当然内部我们已经在使用 CSS Var 并完成了一套主题切换服务，比如切换暗黑模式。</p>]]></content>
    
    
    <summary type="html">OKR工作法</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>油断中……</title>
    <link href="https://zongzi531.com/2021/07/01/%E6%B2%B9%E6%96%AD%E4%B8%AD/"/>
    <id>https://zongzi531.com/2021/07/01/%E6%B2%B9%E6%96%AD%E4%B8%AD/</id>
    <published>2021-07-01T13:22:09.000Z</published>
    <updated>2021-07-01T13:22:09.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><h2 id="任务进度"><a href="#任务进度" class="headerlink" title="任务进度"></a>任务进度</h2><ul><li><strong>「日本語学習計画」</strong>：语法及词汇 <strong>第1页</strong></li><li><strong>「计算机图形学」</strong>：材质与外观</li><li><strong>「锻炼身体」</strong>：简单运动 <strong>待加强</strong></li><li><strong>「ECMA-262」</strong>：6.1.7.3 Invariants of the Essential Internal Methods</li><li><strong>「<code>Type&lt;Challenge[]&gt;</code>」</strong>：651・Length of String 2</li></ul><p>这里其实得批评一下自己，日语的学习从今年年初开始就一直停滞不前，面对文法和词汇退缩了。ECMA 规范虽然有在阅读，但是进度还是太慢了，因为 6 月已过，规范却连一半都没读到。总体从任务来说，真的较去年太松散了！（虽然今年可能确实没多少时间做，给自己找借口中……）</p><h2 id="工程化的实践"><a href="#工程化的实践" class="headerlink" title="工程化的实践"></a>工程化的实践</h2><p>借助内部组件库的开发机会，包揽了构建和发布的工作，学习 ElementPlus 的构建代码（特别感谢鸡哥的耐心指导），采用多进程构建，并且结合自身组件库的需求，虽然同样采用 monorepo 的包管理方式，但是与 ElementPlus 不同的是每一个组件都进行独立的构建和发布，并非统一构建在根目录的 <code>es</code> 和 <code>lib</code> 下，而是构建在 <code>packages</code> 下组件们的 <code>es</code> 和 <code>lib</code> 下，并且进行了独立的依赖配置。</p><p>也遇到了与 ElementPlus 一样的问题，生成的 <code>d.ts</code> 文件存在路径问题，则按照上述的场景，重新编写了 <code>build:type</code> 的工程化代码。</p><p>同样的也提供了 ESM&#x2F;CJS&#x2F;UMD 的构建文件，并且因为上述的场景区别，重新编写了 <code>babel</code> 按需引入插件，实现以下 3 种按需引入方式：</p><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 伪代码</span><span class="token keyword">import</span> ElementPlus<span class="token punctuation">,</span> <span class="token punctuation">{</span> ElButton<span class="token punctuation">,</span> locale <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'element-plus'</span><span class="token keyword">import</span> ElSelect <span class="token keyword">from</span> <span class="token string">'@element-plus/select'</span><span class="token comment" spellcheck="true">// babel 转换后</span><span class="token keyword">import</span> ElementPlus<span class="token punctuation">,</span> <span class="token punctuation">{</span> ElButton<span class="token punctuation">,</span> locale <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'element-plus'</span><span class="token keyword">import</span> ElSelect <span class="token keyword">from</span> <span class="token string">'@element-plus/select'</span><span class="token keyword">import</span> <span class="token string">'@element-plus/theme-chalk/lib/index.css'</span> <span class="token comment" spellcheck="true">// 全量</span><span class="token keyword">import</span> <span class="token string">'@element-plus/theme-chalk/lib/button.css'</span> <span class="token comment" spellcheck="true">// 仅 button</span><span class="token keyword">import</span> <span class="token string">'@element-plus/theme-chalk/lib/select.css'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然说内部组件库的初版功能大体是参考 ElementPlus 的，不过会在未来让内部组件库变得更适合我司，并且计划推进组合式 API 来代替原来的二次封装业务组件。</p><p>在学习过程中接触到 esbuild ，可算是对性能有了新的认识，使用其构建会大大提升构建效率，可算是前端工程化里的一颗新新力量了，也同样计划在后期改善构建效率。</p><p>也同样的，对于内部组件库计划推广和实行更多的计划（当然这里就不会多说了）。</p><p>突然想起一点， ElementPlus 的 TypeScript 代码没有开启严格模式，真的改起来有点头疼，虽然我只是在这里说，没有去提 PR 。</p><h2 id="NO-CODE"><a href="#NO-CODE" class="headerlink" title="NO CODE"></a>NO CODE</h2><p>再来谈一谈零代码这个概念，内部成立了一个小组在推进零代码。并且这个零代码强就强在可以结合我们自己的微前端架构和微前端动态构建平台直出业务到业务。</p><p>用户可以简单的进行拖拽、组合等等一系列操作（反正不用写代码），组合出新的页面或页面集合，结合上述系统，直出到业务。</p><p>并且零代码的架构设计采用开放的插件模式，安全的沙箱模式等设计模式组成。</p><p>总之，正在开发中……</p><p>值得期待！</p><h2 id="📚-建立自己的前端知识体系"><a href="#📚-建立自己的前端知识体系" class="headerlink" title="📚 建立自己的前端知识体系"></a><span class="github-emoji" alias="books" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4da.png?v8">📚</span> 建立自己的前端知识体系</h2><p>回到这个话题，虽然好几个月没有聊起过，但是从整体来说还是有在慢慢的推进，只不过文章开始提到的那些进度有些缓慢……希望可以在下半年抓起来（加油）！</p>]]></content>
    
    
    <summary type="html">这里其实得批评一下自己，日语的学习从今年年初开始就开始停滞不前，面对文法和词汇退缩了。ECMA 规范虽然有...</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
</feed>
