<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zong</title>
  
  
  <link href="https://zongzi531.com/atom.xml" rel="self"/>
  
  <link href="https://zongzi531.com/"/>
  <updated>2024-11-01T08:33:35.000Z</updated>
  <id>https://zongzi531.com/</id>
  
  <author>
    <name>Zong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于门户的架构思考</title>
    <link href="https://zongzi531.com/2024/11/01/%E5%85%B3%E4%BA%8E%E9%97%A8%E6%88%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/"/>
    <id>https://zongzi531.com/2024/11/01/%E5%85%B3%E4%BA%8E%E9%97%A8%E6%88%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/</id>
    <published>2024-11-01T08:33:35.000Z</published>
    <updated>2024-11-01T08:33:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我负责 UED 门户项目整体的架构设计及服务端研发工作，<br>在确定项目需求后，我使用「分层架构」设计了项目整体的架构实现方式，设计系统自上而下分为应用层、业务层、服务层、数据层；<br>在面临多种的认证方式时，选用「适配器模式」解决认证方式差异的问题；<br>在解决 UED 门户需要获取应用操作记录的问题上，使用「观察者模式」，将通过向应用获取转变为应用上送以优化操作记录获取的方式，解耦功能；<br>并且从部署视角的角色选型「虚拟化技术」以保证部署的效率和稳定；</p></blockquote><!-- no node --><span id="more"></span><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>项目第一阶段已告一段，UED 门户项目，是我写 Node.js 开始第一次正式的、完整的参与到研发过程中的项目。</p><p>从技术选型、架构设计逐一入手，是一次较为全面完整的项目体验。</p><p>后续其他部门需要门户网站时，此项目即替换 Web 界面即可交付其他部门，已实现大体复用。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>UED 部门需要建立自己的门户网站，网站需要将现有的 UED 模块服务（原型设计稿、前端组件、设计资源、文档等）集成为一体，以提供一个统一设计资源规范、资源共建、学习成长为一体的门户网站。</p><h2 id="项目要求"><a href="#项目要求" class="headerlink" title="项目要求"></a>项目要求</h2><ol><li>用户的认证方式需要支持公司认证和独立认证，并且认证的用户角色分为用户和应用即「服务模块」</li><li>门户需要收集接入应用中指定的操作记录或其他消息信息</li><li>门户计划在多套环境下进行独立部署</li></ol><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p>架构设计采用「分层架构」，将门户分别为应用层、业务层、服务层、数据层。</p><ul><li>应用层包含 UED 门户自身对用户的 Web 界面以及需要集成进来的应用如：原型设计平台、组件平台、资源平台和文档平台等</li><li>业务层包含 UED 门户提供的业务模块，包含：服务模块管理模块、用户角色权限管理模块、意见反馈模块和文章模块</li><li>服务层包含认证服务、日志服务、订阅服务和资源服务</li><li>数据层包含 PostgreSQL 、 Redis 、 MinIO</li></ul><h3 id="认证服务设计"><a href="#认证服务设计" class="headerlink" title="认证服务设计"></a>认证服务设计</h3><p>认证方式在设计之初存在两种，分别是接入公司的认证中心和实现自己独立的认证中心。可以见得，认证方式是在项目部署时就决定的内容，并且只存在认证服务内部的实现逻辑差异，所以需要保证认证服务对外一致即可。</p><p>所以在设计时，选择以自己独立的认证中心为接口标准进行设计，设计认证标准抽象，让两种方式可以按照抽象进行实现。</p><p>设计模式上，这里选择适配器（Adapter）设计模式，此模式的优点是：</p><ol><li>单一职责原则你可以将接口或数据转换代码从程序主要业务逻辑中分离。</li></ol><p>以保证每一种接入的认证方式都和程序主要业务逻辑无关，保证认证服务对外提供的接口和行为一致。</p><ol start="2"><li>开闭原则。只要客户端代码通过客户端接口与适配器进行交互，你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。</li></ol><p>新增认证方式或则切换认证方式，都无需修改其他服务。</p><p>缺点是：</p><ol><li>代码整体复杂度增加，因为你需要新增一系列接口和类。有时直接更改服务类使其与其他代码兼容会更简单。</li></ol><p>所以在认证模式开发的阶段，使用适配器设计模式会使得代码较无设计模式的情况下，更为复杂一些。但是在程序运行阶段对认证方式切换则无需更新程序即可完成，同时新增认证方式也不会修改到程序的其他业务逻辑。</p><p>从程序质量属性的角度，保证了程序的可修改性。</p><h3 id="订阅服务设计"><a href="#订阅服务设计" class="headerlink" title="订阅服务设计"></a>订阅服务设计</h3><p>如果按照传统的方式去一一对接各个应用中的操作记录或者消息信息，会使得 UED 门户的程序代码与接入的应用功能强耦合，为了解决这个问题。</p><p>UED 门户提供订阅服务，采用观察者模式（Observer）来对接实现各个应用中的操作记录或者消息信息记录。</p><p>通过向应用获取转变为应用上送以优化操作记录获取的方式，约定 UED 门户所需的消息主题，各个应用将需要上送的消息按照对应的主题上送至 UED 门户，由 UED 门户向用户进行展示。</p><p>观察者模式的优点是：</p><ol><li>开闭原则。你无需修改发布者代码就能引入新的订阅者类</li></ol><p>即如果有新应用接入 UED 门户，保持同主题的推送消息，门户在无需进行修改的情况下，用户即可以获得新应用的消息内容。</p><p>缺点是：</p><ol><li>订阅者的通知顺序是随机的</li></ol><p>目前从需求来看，通知的顺序并没有很重要，但如果要实现顺序可以在通知内容中添加时间戳，以应用上送的时间戳为基准，以此来解决消息顺序的问题。</p><h3 id="部署视角"><a href="#部署视角" class="headerlink" title="部署视角"></a>部署视角</h3><p>从部署视角来看，项目需要在多套环境下进行部署，为了避免环境不一致引起的额外部署工作，所以选用虚拟化技术来完成项目部署。</p><p>目前公司存在办公网和内网环境，两套环境分别需要部署正式和测试环境，在技术选型上，我对 Docker 和 Kubernetes 进行了对比。</p><p>Docker 和 Kubernetes 都是虚拟化容器技术，以解决在任何计算机上部署你的项目，但是相比较而言。</p><p>Docker 属于容器运行时技术，更适合单机运行或对资源要求较小的应用，而 Kubernetes 则属于一种容器编排工具，更适合集群运行或更大规模的应用。</p><p>所以从部署视角来看，项目目前使用的用户对内，并且大部分都是研发侧的同学，同时在使用性能上并没有较高的并发需求，即最终选用 Docker 来完成部署工作更合适不过。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我负责 UED 门户项目整体的架构设计及服务端研发工作，&lt;br&gt;在确定项目需求后，我使用「分层架构」设计了项目整体的架构实现方式，设计系统自上而下分为应用层、业务层、服务层、数据层；&lt;br&gt;在面临多种的认证方式时，选用「适配器模式」解决认证方式差异的问题；&lt;br&gt;在解决 UED 门户需要获取应用操作记录的问题上，使用「观察者模式」，将通过向应用获取转变为应用上送以优化操作记录获取的方式，解耦功能；&lt;br&gt;并且从部署视角的角色选型「虚拟化技术」以保证部署的效率和稳定；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Architecture" scheme="https://zongzi531.com/categories/Architecture/"/>
    
    
    <category term="Architecture" scheme="https://zongzi531.com/tags/Architecture/"/>
    
    <category term="架构" scheme="https://zongzi531.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>低代码网格布局</title>
    <link href="https://zongzi531.com/2024/10/01/lowcode-grid-layout-rules/"/>
    <id>https://zongzi531.com/2024/10/01/lowcode-grid-layout-rules/</id>
    <published>2024-10-01T08:33:20.000Z</published>
    <updated>2024-10-01T08:33:20.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>时隔一年，又重新参与低代码的建设，重新根据业务形态抽象网格布局逻辑。</p><p>那就来分享一下网格布局的实现逻辑。</p><h2 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h2><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><p>设计将网格横向分为 <strong>12</strong> 列，并根据实际页面宽度（或者页面预设固定宽度）计算每列实际列宽，以作为 <code>w</code> 的单位映射值，即 <code>w</code> 最大为 <strong>12</strong>。</p><p>行高固定为 <strong>32</strong>px ，即 <code>h</code> 的单位映射值，不限制最大值。</p><p>格间间距为 <strong>16</strong>px 。</p><h3 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h3><h4 id="GridItem-网格项"><a href="#GridItem-网格项" class="headerlink" title="GridItem 网格项"></a><code>GridItem</code> 网格项</h4><p>此组件会体现在 <code>GridLayout</code> 下，会对业务组件或基础组件等进行包裹，以保证 <code>GridLayout</code> 在渲染时，对 <code>children</code> 各组件进行包裹。</p><p>并且，此组件自身无 <code>Schema</code> 配置信息，仅从被包裹 <code>Schema</code> 中获取 <code>size</code> 以呈现组件具体大小（实际大小），或者映射大小（网格单位，通过计算呈现实际大小）。</p><h4 id="GridLayout-网格容器"><a href="#GridLayout-网格容器" class="headerlink" title="GridLayout 网格容器"></a><code>GridLayout</code> 网格容器</h4><p>此组件为特殊内置组件（与业务组件或基础组件一致），具备 <code>Schema</code> 配置信息。</p><table><thead><tr><th>属性</th><th>备注</th><th>类型</th></tr></thead><tbody><tr><td><code>layouts</code></td><td><code>children</code> 中组件的位置信息</td><td><code>Array&lt;LayoutItem&gt;</code></td></tr></tbody></table><h6 id="相关类型"><a href="#相关类型" class="headerlink" title="相关类型"></a>相关类型</h6><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 设计参考 react-grid-layout 配置</span><span class="token keyword">interface</span> <span class="token class-name">LayoutItem</span> <span class="token punctuation">&#123;</span>  id<span class="token operator">:</span> <span class="token builtin">string</span>  x<span class="token operator">:</span> <span class="token builtin">number</span>  y<span class="token operator">:</span> <span class="token builtin">number</span>  w<span class="token operator">:</span> <span class="token builtin">number</span>  h<span class="token operator">:</span> <span class="token builtin">number</span>  gap<span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token string">'top'</span> <span class="token operator">|</span> <span class="token string">'right'</span> <span class="token operator">|</span> <span class="token string">'bottom'</span> <span class="token operator">|</span> <span class="token string">'left'</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="网格交互"><a href="#网格交互" class="headerlink" title="网格交互"></a>网格交互</h3><p>网格交互设计分为：插入、移动、大小调整、删除</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>获取环境信息</p><ul><li>是否选中组件</li><li><code>LayoutItem</code> 默认 <code>w</code> 为 6 ， <code>h</code> 为 6</li></ul><h5 id="点击插入"><a href="#点击插入" class="headerlink" title="点击插入"></a>点击插入</h5><ol><li>若未选中组件，则默认插入根 <code>GridLayout</code></li><li>更新 <code>GridLayout</code> 的 <code>layouts</code> 下 <code>LayoutItem</code> 数据至尾部（生成默认 <code>w</code> 和 <code>h</code> ）</li><li>布局计算</li><li>若选中组件，获得选中组件信息</li></ol><h6 id="选中-GridLayout"><a href="#选中-GridLayout" class="headerlink" title="选中 GridLayout"></a>选中 <code>GridLayout</code></h6><ol start="5"><li>更新 <code>GridLayout</code> 的 <code>layouts</code> 下 <code>LayoutItem</code> 数据至尾部（生成默认 <code>w</code> 和 <code>h</code> ）</li><li>布局计算</li></ol><h6 id="选中业务组件或基础组件"><a href="#选中业务组件或基础组件" class="headerlink" title="选中业务组件或基础组件"></a>选中业务组件或基础组件</h6><ol start="5"><li>获得选中组件 <code>parent</code></li><li>若是 <code>GridLayout</code> ，则更新 <code>GridLayout</code> 的 <code>layouts</code> 下 <code>LayoutItem</code> 数据至选中组件之后（生成默认 <code>w</code> 和 <code>h</code> ）</li><li>布局计算</li><li>若不是则默认插入，不执行网格布局逻辑</li></ol><h6 id="选中容器组件"><a href="#选中容器组件" class="headerlink" title="选中容器组件"></a>选中容器组件</h6><blockquote><p>容器组件为特殊组件，即业务组件或基础组件支持 <code>children</code> 渲染</p></blockquote><ol start="5"><li>默认插入，不执行网格布局逻辑</li></ol><h5 id="移动插入"><a href="#移动插入" class="headerlink" title="移动插入"></a>移动插入</h5><ol><li>获得鼠标落点（鼠标抬起位置）</li><li>获得落点组件信息</li><li>逻辑同「点击插入」时选中组件情况</li></ol><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><ol><li>获得鼠标落点（鼠标抬起位置）</li><li>获得落点组件信息</li></ol><h6 id="落点-GridLayout"><a href="#落点-GridLayout" class="headerlink" title="落点 GridLayout"></a>落点 <code>GridLayout</code></h6><ol start="3"><li>检查落点 <code>GridLayout</code> 是否与当前移动组件的 <code>parent</code> 一致</li><li>若一致则更新对应 <code>layouts</code> 下 <code>LayoutItem</code> 数据至尾部</li><li>布局计算</li><li>若不一致则执行删除和插入（采用当前 <code>w</code> 和 <code>h</code> ）操作</li></ol><h6 id="落点业务组件或基础组件"><a href="#落点业务组件或基础组件" class="headerlink" title="落点业务组件或基础组件"></a>落点业务组件或基础组件</h6><ol start="3"><li>获得落点组件 <code>parent</code> 是否与当前移动组件的 <code>parent</code> 一致</li><li>若一致则交换对应 <code>layouts</code> 下 <code>LayoutItem</code> 数据（除了交换，也可以是插入，具体根据自身业务决定）</li><li>布局计算</li><li>若不一致则执行删除和插入（采用当前 <code>w</code> 和 <code>h</code> ）操作</li></ol><h6 id="落点容器组件"><a href="#落点容器组件" class="headerlink" title="落点容器组件"></a>落点容器组件</h6><blockquote><p>容器组件为特殊组件，即业务组件或基础组件支持 <code>children</code> 渲染</p></blockquote><ol start="3"><li>执行删除和插入（不执行网格布局逻辑）操作</li><li>布局计算</li></ol><h4 id="大小调整"><a href="#大小调整" class="headerlink" title="大小调整"></a>大小调整</h4><ol><li>获得鼠标 <code>x</code> 和 <code>y</code> 的偏移量（鼠标按下到鼠标抬起后获得）</li><li>根据当前组件 <code>Schema</code> 大小累加偏移量（四舍五入）计算组件新大小，即 <code>w</code> 和 <code>h</code> 的值</li><li>更新对应 <code>layouts</code> 下 <code>LayoutItem</code> 数据</li><li>布局计算</li></ol><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ol><li>移除组件 <code>Schema</code></li><li>移除对应 <code>layouts</code> 下 <code>LayoutItem</code> （若存在）</li><li>布局计算（若存在）</li></ol><h3 id="布局计算"><a href="#布局计算" class="headerlink" title="布局计算"></a>布局计算</h3><ol><li>获得 <code>layouts</code> 信息</li><li>依次基于 <code>w</code> 和 <code>h</code> 的值计算 <code>x</code> 和 <code>y</code> 位置</li><li>并且根据当前 <code>w</code> 、 <code>h</code> 、 <code>x</code> 和 <code>y</code> 的关系计算格间间距值</li><li>更新 <code>layouts</code> 信息（格间间距在渲染、位置阴影、选中框时进行累加，不影响原值）</li><li>渲染更新</li></ol><p>算法根据自身业务决定，可以使用二维数组进行占位计算，或是使用自然堆叠计算方式，或是其他。</p><table><thead><tr><th>算法 A</th><th>算法 B</th></tr></thead><tbody><tr><td><img src="/2024/10/01/lowcode-grid-layout-rules/algorithm-a.png" alt="algorithm-a"></td><td><img src="/2024/10/01/lowcode-grid-layout-rules/algorithm-b.png" alt="algorithm-b"></td></tr></tbody></table><h4 id="算法-A"><a href="#算法-A" class="headerlink" title="算法 A"></a>算法 A</h4><blockquote><p>依次遍历 <code>layouts</code> 以返回新的 <code>x</code> 和 <code>y</code> 位置</p></blockquote><ol><li>初始化锚点 <code>x</code> 和 <code>y</code> 位置 <code>(0, 0)</code> ，行内标和行标 <code>(0, 0)</code> ，缓存最大 <code>y</code> 为 0</li><li>依次遍历，记录前一次的缓存最大 <code>y</code> 位置（用于计算格间间距）</li><li>比较 <code>LayoutItem</code> 的 <code>x</code> 与 <code>w</code> 的和是否大于 <strong>12</strong></li><li>若小于等于，则更新当前 <code>LayoutItem</code> 的 <code>x</code> 和 <code>y</code> 位置</li><li>同时更新锚点 <code>x</code> 的位置为当前 <code>LayoutItem</code> 的 <code>x</code> 与 <code>w</code> 的和</li><li>根据当前 <code>LayoutItem</code> 的 <code>y</code> 与 <code>h</code> 的和，缓存最大 <code>y</code> 位置（取最大值）</li><li>若大于，则表示溢出，重置锚点 <code>x</code> 为 0 ，将锚点 <code>y</code> 设置为缓存最大 <code>y</code></li><li>更新当前 <code>LayoutItem</code> 的 <code>x</code> 和 <code>y</code> 位置</li><li>重复 5, 6</li><li>每计算出 <code>LayoutItem</code> 的 <code>x</code> 和 <code>y</code> 位置后，比较前一次的缓存最大 <code>y</code> 位置和缓存最大 <code>y</code> 位置</li><li>若前一次的缓存最大 <code>y</code> 位置小于缓存最大 <code>y</code> 位置（说明换行过），增加行标，重置行内标为 0</li><li>反之则增加行内标</li><li>将当前行内标和行标与 <code>LayoutItem</code> 对应关联</li></ol><p>至此，已实现更新 <code>x</code> 和 <code>y</code> 位置，接下来结合行内标和行标信息来计算 <code>LayoutItem</code> 的格间间距。</p><blockquote><p>倒序遍历行内标和行标</p></blockquote><ol><li>设置第一次右间距存在标识为否，前一次行标为行内标和行标信息的最后一个值</li><li>倒序遍历，获得对应的行内标和行标</li><li>初始化 <code>LayoutItem</code> 对应的格间间距，左右上为 0 ，下为 1&#x2F;2 间距 8px</li><li>若前一次行标与当前行标不一致（意味着行变更），则重置第一次右间距存在标识为否</li><li>更新前一次行标为当前行标</li><li>若当前行标大于 1 ，则表示非第一行，设置格间间距上为 8px</li><li>若第一次右间距存在标识为是，或者当前对应的 <code>LayoutItem</code> 的 <code>x</code> 与 <code>w</code> 的和小于 <strong>12</strong> ，则设置格间间距右为 8px</li><li>若当前行内标大于 0 ，则设置格间间距左为 8px ，并将第一次右间距存在标识设置为是</li><li>更新格间间距至对应的 <code>LayoutItem</code></li></ol><h4 id="算法-B"><a href="#算法-B" class="headerlink" title="算法 B"></a>算法 B</h4><blockquote><p>依次遍历 <code>layouts</code> 以返回新的 <code>x</code> 和 <code>y</code> 位置</p></blockquote><ol><li>初始化空二维数组（记做标记空间），用于标记占位情况；<code>y</code> 标识用于记录需要延展的行数，初始为 0 ，以及上一次的 <code>y</code> 标识，同初始为 0</li><li>依次遍历，比较上一次的 <code>y</code> 标识与 <code>y</code> 标识加 <code>LayoutItem</code> 的 <code>h</code> ，取最大值更新上一次的 <code>y</code> 标识</li><li>使用上一次的 <code>y</code> 标识与标记空间长度比较，若大于 0 ，则批量生成行 <code>new Array(12).fill(null)</code></li><li>从 <code>(0, 0)</code> 标记位进行遍历（可优化至最左上角的一个 <code>null</code> 标记位），寻找 <code>null</code> 标记位</li><li>当找到 <code>null</code> 标记位后，以此标记位为起点，检查 <code>LayoutItem</code> 的 <code>w</code> 和 <code>h</code> 占位情况（以标记位为起点向右下检查 <code>LayoutItem</code> 的 <code>w</code> 和 <code>h</code> 长度，不能越界）</li><li>若均为 <code>null</code> 则更新标记空间，并更新 <code>LayoutItem</code> 的 <code>x</code> 和 <code>y</code> 为当前标记位起点，同时更新 <code>y</code> 标识为当前标记位起点 <code>y</code> 与 <code>LayoutItem</code> 的 <code>h</code> 的和，中断此次标记位遍历，进入下一个 <code>LayoutItem</code> 遍历</li><li>反之寻找下一个 <code>null</code> 标记位起点</li></ol><p>至此，已实现更新 <code>x</code> 和 <code>y</code> 位置，接下来结合标记空间来计算 <code>LayoutItem</code> 的格间间距。</p><ol><li>遍历标记空间 4 条边，记录占用 <code>LayoutItem</code> 信息</li><li>依次遍历 <code>LayoutItem</code> 并初始化对应的格间间距，左右上下为 8px</li><li>检查占用信息，对 4 条边存在占用的方向格间间距设置为 0</li><li>更新格间间距至对应的 <code>LayoutItem</code></li></ol><h3 id="辅助功能"><a href="#辅助功能" class="headerlink" title="辅助功能"></a>辅助功能</h3><ol><li>组件选中框跟随组件一起移动</li><li>计算组件预计落点位置阴影</li><li>动态替换</li></ol>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Lowcode" scheme="https://zongzi531.com/categories/Lowcode/"/>
    
    
    <category term="lowcode" scheme="https://zongzi531.com/tags/lowcode/"/>
    
    <category term="低代码" scheme="https://zongzi531.com/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"/>
    
    <category term="grid" scheme="https://zongzi531.com/tags/grid/"/>
    
    <category term="layout" scheme="https://zongzi531.com/tags/layout/"/>
    
    <category term="rules" scheme="https://zongzi531.com/tags/rules/"/>
    
  </entry>
  
  <entry>
    <title>RAG 生态探索</title>
    <link href="https://zongzi531.com/2024/09/01/rag%E7%94%9F%E6%80%81%E6%8E%A2%E7%B4%A2/"/>
    <id>https://zongzi531.com/2024/09/01/rag%E7%94%9F%E6%80%81%E6%8E%A2%E7%B4%A2/</id>
    <published>2024-09-01T09:19:39.000Z</published>
    <updated>2024-09-01T09:19:39.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>在对 RAG 有了简单认识之后，基于一些业务的场景，对 RAG 生态进行了一些探索。</p><p>网上有一张 RAG 生态的概括图，我认为不错。</p><p><img src="/2024/09/01/rag%E7%94%9F%E6%80%81%E6%8E%A2%E7%B4%A2/rag-eco.png" alt="rag-ecosystem"></p><h2 id="图谱"><a href="#图谱" class="headerlink" title="图谱"></a>图谱</h2><p>在 RAG 工作流中，考虑通过图谱的概念，生成更全面的一些信息以提升问答的功能。</p><p>尝试微软开源的 GraphRAG 对文本（大文本、多文本）提取实体、关系，以在问答环节可以尝试一些逻辑或者总结性的路由流程。</p><p>图谱相较于切片，具有更强的逻辑性，并且信息链更为清晰，而切片却有冗余以及无法多内容关联的问题。</p><p>当然了，也可以使用支持大 tokens 的 LLM 进行总结或其他动作，只不过这样会重复的消耗大 tokens ，从资源层面是浪费的。</p><p>以下是 GraphRAG 索引步骤：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">⠋ GraphRAG Indexer ├── Loading Input <span class="token punctuation">(</span>text<span class="token punctuation">)</span>├── create_base_text_units├── create_base_extracted_entities├── create_final_covariates├── create_summarized_entities├── join_text_units_to_covariate_ids├── create_base_entity_graph├── create_final_entities├── create_final_nodes├── create_final_communities├── join_text_units_to_entity_ids├── create_final_relationships├── join_text_units_to_relationship_ids├── create_final_community_reports├── create_final_text_units├── create_base_documents└── create_final_documents🚀 All workflows completed successfully.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目前， GraphRAG 对不同类型的文档进行索引时，需要人为为工具提供实体类型（考虑是不是能由 LLM 代替），以在索引时能够更好的分析提取实体和其之间的关系。</p><p>所以如果需要接入到现有的 RAG 流程，需要 Python 编程调整各节点逻辑，以适配 RAG 流程。</p><p>视觉效果：</p><p><img src="https://github.com/zongzi531/modular-rag/blob/main/index/graphrag/images/graph_example.png?raw=true" alt="graph_example"></p><blockquote><p>详细可<a href="https://github.com/zongzi531/modular-rag/blob/main/index/graphrag/README.md">查看</a></p></blockquote><h2 id="微调-Embeddings-模型尝试"><a href="#微调-Embeddings-模型尝试" class="headerlink" title="微调 Embeddings 模型尝试"></a>微调 Embeddings 模型尝试</h2><p>使用 <code>uniem</code> 工具对模型进行微调，分别尝试过对 <code>small</code> 、 <code>base</code> 、 <code>large</code> 进行不同的微调对比，可能是数据集选用的关系，效果并不是特别理想，并且在大数据集的微调场景下，微调时间较长，成本较大，所以暂缓。</p><p>最后直接选用 <code>bge-large-zh-v1.5</code> 为本地 Embeddings 模型。</p><h2 id="评测"><a href="#评测" class="headerlink" title="评测"></a>评测</h2><p>使用 Ragas 工具进行 RAG 流程评测。在使用此工具前，采用人工测试集进行评测，并且评测维度较为主观。</p><p>需要注意 ⚠️ ：在测试集生成和评测阶段，会大量消耗 LLM tokens ，请合理选择需要评测指标。</p><h3 id="评测指标"><a href="#评测指标" class="headerlink" title="评测指标"></a>评测指标</h3><table><thead><tr><th>指标名称</th><th>范围</th><th>含义</th></tr></thead><tbody><tr><td><code>context_precision</code> 上下文精度</td><td>(0,1)</td><td>值越大，表示 <code>ground_truth</code> 与 <code>contexts</code> 越相关。</td></tr><tr><td><code>faithfulness</code> 忠诚度&#x2F;可信度</td><td>(0,1)</td><td>由 <code>answer</code> 与 <code>contexts</code> 计算得出，值越大，表示 <code>answer</code> 更可信。</td></tr><tr><td><code>answer_relevancy</code> 答案相关性</td><td>(-1,1)</td><td>由 <code>answer</code> 、 <code>contexts</code> 与 <code>question</code> 计算得出，值越大，表示 <code>answer</code> 的相关性较好。</td></tr><tr><td><code>context_recall</code> 上下文召回</td><td>(0,1)</td><td>通过对 <code>ground_truth</code> 进行分解以验证是否可以归因于 <code>contexts</code> ，值越大，表示性能越好（避免反复尝试）。</td></tr><tr><td><code>context_entity_recall</code> 上下文实体召回</td><td>(0,1)</td><td>分别计算 <code>ground_truth</code> 和 <code>contexts</code> 的实体，使用其实体进行召回，值越大，表示性能越好（避免反复尝试）。</td></tr><tr><td><code>answer_similarity</code> 答案语义相似度</td><td>(0,1)</td><td>由 <code>answer</code> 与 <code>ground_truth</code> 计算得出，值越大，表示 <code>answer</code> 与 <code>ground_truth</code> 更相似。</td></tr><tr><td><code>answer_correctness</code> 答案正确性</td><td>(0,1)</td><td>由 <code>answer</code> 与 <code>ground_truth</code> 计算得出，值越大，表示 <code>answer</code> 与 <code>ground_truth</code> 一致性越高。</td></tr><tr><td><code>AspectCritique</code> 方面批评</td><td>-</td><td>用于评测 <code>answer</code> 的内容是否包含评测「方面」的内容，如有害性、恶意性、连贯性、正确性、简洁性</td></tr><tr><td><code>summarization_score</code> 总结分数</td><td>-</td><td>-</td></tr></tbody></table><hr><p>所以在不考虑 LLM tokens 的情况下，可以利用自动化评测工具来优化现在有的 RAG 应用，不限于 RAG 流程、Prompt 工程等，相较于人工测试集，可以说效率大大提升。</p><blockquote><p>详细可<a href="https://github.com/zongzi531/modular-rag/tree/main/evaluation/ragas">查看</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
    <category term="RAG" scheme="https://zongzi531.com/tags/RAG/"/>
    
    <category term="GraphRAG" scheme="https://zongzi531.com/tags/GraphRAG/"/>
    
    <category term="Fine-tuning" scheme="https://zongzi531.com/tags/Fine-tuning/"/>
    
    <category term="Ragas" scheme="https://zongzi531.com/tags/Ragas/"/>
    
  </entry>
  
  <entry>
    <title>初识 RAG</title>
    <link href="https://zongzi531.com/2024/08/01/%E5%88%9D%E8%AF%86rag/"/>
    <id>https://zongzi531.com/2024/08/01/%E5%88%9D%E8%AF%86rag/</id>
    <published>2024-08-01T08:39:09.000Z</published>
    <updated>2024-08-01T08:39:09.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>继上个月对 Sentence Transformers 框架下的 embedding 模型有了简单的尝试和使用后，现在对 RAG 有了简单的认识。</p><p>用一张图来解释最为合适不过了。</p><p><img src="/2024/08/01/%E5%88%9D%E8%AF%86rag/C1-2-RAG.png" alt="rag"></p><blockquote><p>图片来自 <a href="https://github.com/datawhalechina/llm-universe">llm-universe</a></p></blockquote><p>关于什么是 RAG 这里就不多做介绍了，其实回顾下来，可以发现 RAG 的流程中，还有很多的优化点，可以更好的优化 LLM 在回答问题过程中的幻觉问题。</p><p>例如：</p><ul><li>文件在解析过程中的清洗操作，包括不限于对不同类型的文件进行特殊处理，对图片视频音频等媒体资源进行识别转文字或向量化。</li><li>知识库场景下，对单文件整篇进行总结、多文件集合总结。</li></ul><blockquote><p>以上优化目的在于尽可能产生多的向量可能与 Query 进行匹配，丰富进入 LLM 时生成 prompt 的内容。</p></blockquote><ul><li>Query 也可以在向量化前，经过 LLM 生成相似的 Query 生成多个向量进行查询匹配的优化逻辑。</li><li>知识库场景下，对存在的数据进行自动化知识图谱生成，并且优化 Query 的向量化流程，以能够更好的匹配到问题的领域，避免越界的同类词汇出现的问题。</li><li>Query 的 Chat 场景对一些模糊内容可以提供一些交互式的引导，来辅助问答。</li></ul><p>我们也在尝试着使用 RAG 来研发一个新型的知识库，解决传统知识库需要问题内容强匹配的问题，期望提供一个更易用的知识库。</p><p>其实 RAG 完全不限于知识库的场景。</p><p>在辅助编程领域，可以结合自身的代码合集进行更精准的推荐，也可以避免一些技术过时的问题，等等。</p><p>同样的，在办公领域，可以结合自身的业务领域，实现类似自动生成 Word 、 PPT 、PDF 等文件。</p><p>总之，可以让 LLM 的回答更实时、更准确、更专业。</p><p>回过来想一下， RAG 其实也会演变成一个基座，在此基座上衍生产品。</p><p>比较疑惑的点是，目前对 LLM 了解的并不充分，可以明白 LLM 对自然语言的理解还不错，但是对一些数理化的内容，似乎并不擅长，是不是在 LLM 的过程中引导进行推理可以提升准确率呢……</p><p>所以 RAG 之路，还很长……</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
    <category term="RAG" scheme="https://zongzi531.com/tags/RAG/"/>
    
  </entry>
  
  <entry>
    <title>Sentence Transformers 使用介绍</title>
    <link href="https://zongzi531.com/2024/07/05/sentence-transformer%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>https://zongzi531.com/2024/07/05/sentence-transformer%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</id>
    <published>2024-07-05T09:17:30.000Z</published>
    <updated>2024-07-05T09:17:30.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><blockquote><p>官网 <a href="https://www.sbert.net/index.html">SBERT.net</a></p></blockquote><p>有关于 Sentence Transformers 是什么，其官网都有介绍，那本篇博客将简单介绍此框架该如何使用。</p><p>Sentence Transformers 框架支持直接使用模型，也就是 <strong>Inference</strong> 。</p><p>另外可以使用此框架对模型进行微调（<strong>fine-tuning</strong>），从而训练（<strong>Training</strong>）属于自己的模型，当然我目前还没操作过。</p><p>安装教程请参照官网，这里接直接进入使用阶段。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 引用框架及工具</span><span class="token keyword">from</span> sentence_transformers <span class="token keyword">import</span> SentenceTransformer<span class="token punctuation">,</span> util<span class="token comment"># 设置一些语句用于匹配</span>sentences <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"That is a happy dog"</span><span class="token punctuation">,</span> <span class="token string">"That is a very happy person"</span><span class="token punctuation">,</span> <span class="token string">"Today is a sunny day"</span><span class="token punctuation">]</span><span class="token comment"># 加载模型，这里使用的是官方模型，首次运行程序会从官网下载</span>model <span class="token operator">=</span> SentenceTransformer<span class="token punctuation">(</span><span class="token string">'sentence-transformers/all-MiniLM-L6-v2'</span><span class="token punctuation">)</span><span class="token comment"># 这是我想进行匹配的语句，从上面设置的语句中寻找最相似的</span>question <span class="token operator">=</span> <span class="token string">"That is a happy person"</span><span class="token comment"># 先将我想匹配的语句解析成向量数据</span>question_embeddings <span class="token operator">=</span> model<span class="token punctuation">.</span>encode<span class="token punctuation">(</span>question<span class="token punctuation">)</span><span class="token comment"># 可以尝试打印出来看一下</span><span class="token comment"># print(question_embeddings)</span><span class="token comment"># 可以打印该向量数据的维度</span><span class="token comment"># print(question_embeddings.shape)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"question is: &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>question<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> sentence <span class="token keyword">in</span> sentences<span class="token punctuation">:</span>  <span class="token comment"># 对上面设置的语句们，解析成向量数据</span>  embeddings <span class="token operator">=</span> model<span class="token punctuation">.</span>encode<span class="token punctuation">(</span>sentence<span class="token punctuation">)</span>  <span class="token comment"># 使用官方提供的数据计算两个向量的相似度</span>  sym <span class="token operator">=</span> <span class="token builtin">round</span><span class="token punctuation">(</span><span class="token builtin">float</span><span class="token punctuation">(</span>util<span class="token punctuation">.</span>pytorch_cos_sim<span class="token punctuation">(</span>question_embeddings<span class="token punctuation">,</span> embeddings<span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125; -> &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>sentence<span class="token punctuation">,</span> sym<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行这段 Python 脚本可以看到如下输出结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">question is: That is a happy personThat is a happy dog -<span class="token operator">></span> <span class="token number">0.69458</span>That is a very happy person -<span class="token operator">></span> <span class="token number">0.94292</span>Today is a sunny day -<span class="token operator">></span> <span class="token number">0.25688</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>看效果还不错吧，这时候是不是想试试看中文。我们可以使用官网 <a href="https://www.sbert.net/docs/sentence_transformer/pretrained_models.html#multilingual-models">Multilingual Models</a> 下的官方模型使用。</p><p>对中文都有所支持，我们调整一下 <code>sentences</code> 和 <code>question</code> 的内容，我这边使用的是 <code>distiluse-base-multilingual-cased-v1</code> 模型来运行，我们来看一下运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">question is: 我喜欢吃苹果我喜欢吃香蕉 -<span class="token operator">></span> <span class="token number">0.79271</span>我最喜欢苹果 -<span class="token operator">></span> <span class="token number">0.91433</span>今天买了一个苹果 -<span class="token operator">></span> <span class="token number">0.61951</span>我拥有一个苹果 -<span class="token operator">></span> <span class="token number">0.71284</span>儿子喜欢吃苹果 -<span class="token operator">></span> <span class="token number">0.73278</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到这个输出值，让人有点感觉“舒适”，在这个结果上，我们调整一下问题，在问题上加一个 <code>不</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">question is: 我不喜欢吃苹果我喜欢吃香蕉 -<span class="token operator">></span> <span class="token number">0.69195</span>我最喜欢苹果 -<span class="token operator">></span> <span class="token number">0.82793</span>今天买了一个苹果 -<span class="token operator">></span> <span class="token number">0.58365</span>我拥有一个苹果 -<span class="token operator">></span> <span class="token number">0.64693</span>儿子喜欢吃苹果 -<span class="token operator">></span> <span class="token number">0.674</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以要想提升这个准确度，可能就是需要我们自己对模型进的微调了吧……</p><p>当然其实也可以借助大语言模型对整个工作流进行优化，以约束这里匹配出来的结果。</p><p>官网也有一个示例集 <a href="https://github.com/UKPLab/sentence-transformers/blob/master/examples">examples</a> ，可以在里面学习不少。</p><p>到这里，其实已经对 Sentence Transformers 框架在 Python 下的使用已经有了一个简单的认识，至于怎么结合自己的工作流，就要看自己的业务场景了。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="NLP" scheme="https://zongzi531.com/categories/NLP/"/>
    
    
    <category term="embeddings" scheme="https://zongzi531.com/tags/embeddings/"/>
    
    <category term="tutorial" scheme="https://zongzi531.com/tags/tutorial/"/>
    
    <category term="framework" scheme="https://zongzi531.com/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>原谅别人的错，解脱自己的苦</title>
    <link href="https://zongzi531.com/2024/07/01/%E5%8E%9F%E8%B0%85%E5%88%AB%E4%BA%BA%E7%9A%84%E9%94%99%EF%BC%8C%E8%A7%A3%E8%84%B1%E8%87%AA%E5%B7%B1%E7%9A%84%E8%8B%A6/"/>
    <id>https://zongzi531.com/2024/07/01/%E5%8E%9F%E8%B0%85%E5%88%AB%E4%BA%BA%E7%9A%84%E9%94%99%EF%BC%8C%E8%A7%A3%E8%84%B1%E8%87%AA%E5%B7%B1%E7%9A%84%E8%8B%A6/</id>
    <published>2024-07-01T09:22:00.000Z</published>
    <updated>2024-07-01T09:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>嘿，这个月基本就是在写业务，有空出来的时间学习了一下 embedding 相关的内容，虽然对其实现可以说是一无所知，但是对怎么使用有了一些浅显的理解（包括 Python 开发）。</p><p>可以想象一些应用场景吧。</p><p>对了，还因为紧急情况，写了一个 shell 脚本，用于运维部署（真好家伙，啥都干啊）。</p><p>另外，有什么境外旅游推荐么，悠闲的那种，非特种兵，非网红打卡。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Here We Go!</title>
    <link href="https://zongzi531.com/2024/06/01/here-we-go/"/>
    <id>https://zongzi531.com/2024/06/01/here-we-go/</id>
    <published>2024-06-01T13:36:33.000Z</published>
    <updated>2024-06-01T13:36:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>周末去了一趟 USJ ，对马里奥园区还是很满意的，非常 Nice ，好玩！</p><p>哈利波特园区的项目也不错，其他的项目中规中矩吧～</p><p>还是东迪情绪给得到位，当然马里奥园区也不差。</p><p>这个月中规中矩吧，VSCode 插件开发、服务端开发（Node.js&#x2F;Python）。</p><p>简单入门了一下 Python ，因为交接同事的项目里有两个 Python 工具，需要转成服务，那就简单学习了一下 Python 来迁移吧。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>技术慢增长</title>
    <link href="https://zongzi531.com/2024/05/01/%E6%8A%80%E6%9C%AF%E6%85%A2%E5%A2%9E%E9%95%BF/"/>
    <id>https://zongzi531.com/2024/05/01/%E6%8A%80%E6%9C%AF%E6%85%A2%E5%A2%9E%E9%95%BF/</id>
    <published>2024-05-01T13:07:10.000Z</published>
    <updated>2024-05-01T13:07:10.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>这个月一半是服务端和运维的身份吧，另一半回到了从前的领域，开始接触 VSCode 插件开发，也算是一个分支积累吧。</p><p>当然了，其实换汤不换药，就是使用编程语言在给定的环境中实现功能罢了。</p><p>说是接触了有小半年服务端的研发及上线，其实最多也就是基本的一些 CRUD 和抽象罢了，以及踩了一些运维的坑。</p><p>深入服务端的路径确实太长，太黑。</p><p>以前想着的深入到 JS 规范中，似乎还是那么的遥远，其实还是缺乏系统性的计算机知识导致的。</p><p>所以，当下一步一个脚印还是没问题的。</p><p>OK，更多的时间还是得交给生活，享受生活～</p><blockquote><p>vscode logo, wallpaper, work space, office, lady –aspect 16:9 –v 6.0</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>赏花</title>
    <link href="https://zongzi531.com/2024/04/01/%E8%B5%8F%E8%8A%B1/"/>
    <id>https://zongzi531.com/2024/04/01/%E8%B5%8F%E8%8A%B1/</id>
    <published>2024-04-01T13:27:12.000Z</published>
    <updated>2024-04-01T13:27:12.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>这个月依然是服务端身份，已经成功的交付了 Midjourney API 供公司内部使用，并且在公司内部已经开始尝试 AI 辅助编码，感觉公司整体方向已经在往 AI 靠了。</p><p>总结来说就是基本的服务端研发 + 运维，以及 API 代理工程师。</p><p>赏樱的时间到了，本来想着要是能去日本看樱花就好了，但是机票实在是太不实惠了，而且杭州的樱花也好多呢。</p><p>话不多说，来欣赏一下吧～</p><div style="display: grid; grid-template-columns: 1fr 1fr; grid-gap: 16px;">  <img src="pic2.jpg">  <img src="pic3.jpg"></div><p>还去了太子湾欣赏郁金香，也是美美哒～</p><p>一起欣赏一下吧～</p><div style="display: grid; grid-template-columns: 1fr 1fr; grid-gap: 16px;">  <img src="pic4.jpg">  <img src="pic5.jpg"></div><p>一起享受生活吧～哈哈</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>年味鱼灯</title>
    <link href="https://zongzi531.com/2024/03/01/%E5%B9%B4%E5%91%B3%E9%B1%BC%E7%81%AF/"/>
    <id>https://zongzi531.com/2024/03/01/%E5%B9%B4%E5%91%B3%E9%B1%BC%E7%81%AF/</id>
    <published>2024-03-01T10:13:11.000Z</published>
    <updated>2024-03-01T10:13:11.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>春节过去了，又回归到了工作岗位上。</p><p>今年春节没有安排旅游，原因是发现今年出行的成本较以往变大了，所以暂时不考虑旅游。</p><p>春节假期这么长，考虑周边城市哪里晃一圈。</p><p>感觉现在的年味是没有小的时候那样热闹和开心，所以想着去感受一下其他地方的年味。</p><p>于是前往安徽北岸镇瞻淇村看一下鱼灯，感受下来确实很热闹也有年味。</p><p>和单纯的人多是不一样的感觉，是一种喜庆和开心的感觉，是一种文化的吸收。</p><div style="display: grid; grid-template-columns: 1fr 1fr; grid-gap: 16px;">  <img src="pic2.jpg">  <img src="pic3.jpg"></div><p>回来也发现今年类似于这种非物质文化遗产都慢慢浮现出来，好像大家都开始关注起来了。</p><p>也借机会去逛了一下浙江省非物质文化遗产馆，了解和学习以前留下来的文化。</p><p>这个月呢，主要还是从事后端开发的工作，接触了域名泛解析和 PVUV 相关的研发内容。</p><p>对了，还尝试结合开源的 API 接入 Midjourney 。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>龙行大运</title>
    <link href="https://zongzi531.com/2024/02/01/%E9%BE%99%E8%A1%8C%E5%A4%A7%E8%BF%90/"/>
    <id>https://zongzi531.com/2024/02/01/%E9%BE%99%E8%A1%8C%E5%A4%A7%E8%BF%90/</id>
    <published>2024-02-01T13:35:11.000Z</published>
    <updated>2024-02-01T13:35:11.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>这一年可以说比去年更“精彩”，团队独立后，确实向前迈了一大步，但是由于市场环境的影响，团队最终被解散，部分成员出去成立了子公司，部分成员分布在了公司其他部门，部分成员离开了公司。</p><p>确实也慢慢接受了这些变化，虽然自己是喜欢变化的，但是这个变化确实有点“猛”。</p><p>低代码的业务确实也刚刚进入落地即将闭环的阶段，转而我开始从事基础建设，开始编写 Node.js ，开始尝试做运维的工作。</p><p>当然，这还是能让我从中学习到一些些产品的知识。</p><p>就眼下而已，其实做好手上事，持续积累即可，因为就算焦虑了也没用。</p><p>对了，关于性能优化，今年确实做了比较多的在浏览器上减少 JavaScript 的执行时间的相关优化工作。</p><p>这个月设计了 C2D 和 D2C 的架构，也不知道新年能不能就此有新的进展。</p><h1 id="基础建设"><a href="#基础建设" class="headerlink" title="基础建设"></a>基础建设</h1><ul><li>低代码引擎、低代码产品孵化</li><li>[Unity] <a href="https://github.com/zongzi531/make_fun">make_fun</a></li><li>Node.js 服务端研发</li></ul><h1 id="开源贡献"><a href="#开源贡献" class="headerlink" title="开源贡献"></a>开源贡献</h1><ul><li><p><a href="https://github.com/insightfuls/inquirer-tree-prompt">insightfuls&#x2F;inquirer-tree-prompt</a> <a href="https://github.com/insightfuls/inquirer-tree-prompt/pull/10">#10</a></p></li><li><p><a href="https://github.com/oven-sh/bun">oven-sh&#x2F;bun</a> <a href="https://github.com/oven-sh/bun/pull/5243">#5243</a> <a href="https://github.com/oven-sh/bun/pull/5250">#5250</a> <a href="https://github.com/oven-sh/bun/pull/5451">#5451</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>２０２４年おめでとうございます</title>
    <link href="https://zongzi531.com/2024/01/01/%EF%BC%92%EF%BC%90%EF%BC%92%EF%BC%94%E5%B9%B4%E3%81%8A%E3%82%81%E3%81%A7%E3%81%A8%E3%81%86%E3%81%94%E3%81%96%E3%81%84%E3%81%BE%E3%81%99/"/>
    <id>https://zongzi531.com/2024/01/01/%EF%BC%92%EF%BC%90%EF%BC%92%EF%BC%94%E5%B9%B4%E3%81%8A%E3%82%81%E3%81%A7%E3%81%A8%E3%81%86%E3%81%94%E3%81%96%E3%81%84%E3%81%BE%E3%81%99/</id>
    <published>2024-01-01T10:51:08.000Z</published>
    <updated>2024-01-01T10:51:08.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><h2 id="想先说的话"><a href="#想先说的话" class="headerlink" title="想先说的话"></a>想先说的话</h2><p>很明显大家都能感受到今年的经济很差，最后只能说难，大家都难。</p><p>虽然说开头这么消极，但是我还是对未来有所规划的，至少不能停滞不前吧。</p><p>能确定的大方向即是架构，如果说我想在这个行业继续深耕下去的话，架构是一定的。当然也可能转行咯，关注动态吧。</p><p>现在比较火热的就是 AI 了，人们对 AI 有着很多畅想，并且 AI 领域确实存在着很多机会。</p><p>比较让我没想到的是，下半年的时候部门没了，所以低代码就此应该就打住了。</p><p>Unity 其实在年中的时候也简单学习和把玩了一下，但是考虑到自己起步晚的事，想想还是算了。</p><p>更让我们没想到的是，进入到新部门做公司 UED 的时候，我居然开始写 Node.js 服务端了，还得负责运维的工作。</p><p>新年的工作走向很有可能继续是从事服务端开发的工作，有好有坏吧。</p><p>坏就是，我开始会慢慢脱离前端，在前端领域没办法继续“精”下去，虽然我本来在视觉层也只是皮毛，更擅长一些抽象。</p><p>好就是，我能够接触到服务端的内容，从整体去接触产品，会让走向架构轻松一些。</p><p>这可能会成为我架构方向的一个契机，也可能会成为我学习 Python 的一个契机。</p><p>但是也说不定，就领大礼包了～</p><h2 id="回顾-2023-年"><a href="#回顾-2023-年" class="headerlink" title="回顾 2023 年"></a>回顾 2023 年</h2><ul><li><strong><span class="github-emoji" alias="couplekiss_man_woman" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f469-2764-1f48b-1f468.png?v8">👩️‍❤️‍💋️‍👨</span> 更爱老婆，和她开心幸福在一起</strong></li><li><strong><span class="github-emoji" alias="heartpulse" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f497.png?v8">💗</span> 更爱家人，祝家人身体健康，平平安安</strong></li><li><strong><span class="github-emoji" alias="horse_racing" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f3c7.png?v8">🏇</span> 锻炼身体</strong> <code>适量</code></li><li><del><strong><span class="github-emoji" alias="notebook_with_decorative_cover" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d4.png?v8">📔</span> 日本語学習文法・語彙</strong></del></li><li><strong><span class="github-emoji" alias="books" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4da.png?v8">📚</span> 建立自己的知识体系</strong> <code>持续进行</code></li><li><del><strong>深入 Rust</strong></del></li><li><strong>深入低代码</strong></li><li><strong>性能优化</strong></li><li><strong>初探 Unity</strong></li><li><strong>初探机器学习</strong></li><li><strong>初探服务端 Node.js</strong></li></ul><h2 id="展望-2024-年"><a href="#展望-2024-年" class="headerlink" title="展望 2024 年"></a>展望 2024 年</h2><ul><li><strong><span class="github-emoji" alias="couplekiss_man_woman" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f469-2764-1f48b-1f468.png?v8">👩️‍❤️‍💋️‍👨</span> 更爱老婆，和她开心幸福在一起</strong></li><li><strong><span class="github-emoji" alias="heartpulse" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f497.png?v8">💗</span> 更爱家人，祝家人身体健康，平平安安</strong></li><li><strong><span class="github-emoji" alias="horse_racing" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f3c7.png?v8">🏇</span> 锻炼身体</strong></li><li><strong><span class="github-emoji" alias="books" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4da.png?v8">📚</span> 建立自己的知识体系</strong></li><li><strong>架构</strong></li><li><strong>Python</strong></li><li><strong>机器学习</strong></li></ul>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>登山</title>
    <link href="https://zongzi531.com/2023/12/01/%E7%99%BB%E5%B1%B1/"/>
    <id>https://zongzi531.com/2023/12/01/%E7%99%BB%E5%B1%B1/</id>
    <published>2023-12-01T10:39:00.000Z</published>
    <updated>2023-12-01T10:39:00.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>也算不上是登山吧，哈哈哈！坐中巴车上山 15 分钟，路程非常山路，自己开车估计得半小时起码。</p><p>到了山顶感觉真好，山上有两棵很大的银杏树，去的时候叶子半绿半黄。</p><p>下山的时候是走下山的，走了差不多 1 个小时。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>整个月的工作内容基本就是一个后端实习生了……</p><p>继续上个月的服务端功能，这个月学习了不少知识。</p><p>数据库本来只会使用 <code>typeorm</code> 进行简单的 API 调用，比如 <code>find</code> 之类的简单操作，对于需要聚合多张表的数据也是使用了比较拙劣的办法，查出一张表并根据这张表的关联 ID 进行遍历查询，最后进行聚合，后来经过后端大哥的提示，可以使用多表关联查询来实现，虽然过程中出现了一些 SQL 的报错是后端大哥帮忙给出的解决思路，但是自己对 SQL 的时候确实还是一片空白。</p><p>数据库备份则是通过 <code>pg_dump</code> 来进，还原则是通过 <code>psql</code> 进行，这些命令都依赖于 <code>postgresql-client</code> 这个库。</p><p>Docker 方面，一是将 GitLab Runner 从部署服务器上运行调整为 Docker 容器运行，以确保每个 <code>stage</code> 的执行过程足够纯粹。</p><p>也经历了 Docker 镜像启动时需要添加额外的 <code>hosts</code> 配置，解决 DNS 映射问题，以及自己打包依赖集合镜像。</p><p>因为要经历 Docker 镜像的推送，考虑通过登录服务器来操作，利用 <code>ssh-agent</code> 来实现免密登录服务器，以进行一系列操作，比如推送镜像、更新服务等。</p><p>特别需要一提的是挂载功能真的很好用。</p><p>NestJS 开启了日志功能，便于 API 调试，虽然没做持久化，但是可以直接进入容器查看日志，如果考虑做持久化的话，结合挂载功能实现即可，只不过需要额外考虑日志存储的上限，清除等逻辑。</p><p>并且在开发的过程中也发现了，起初数据库设计的不完全，结合数据库迁移 migration 对数据库进行了字段补充。</p><p>服务端的单元测试算是其中比较轻松的，连接测试数据库，保证每一个测试用例的纯净，根据业务场景编写单元测试。</p><p>部署过程中也为前端仓库添加 CI 、 Docker 镜像制作、自动化等工作，也同时配置了 Nginx 的配置文件，算是简单的尝试了一把。</p><p>不仅部署了前端，还针对各环境提供了测试和正式环境的部署，并且对正式环境关闭了端口映射，统一通过网关进行对外暴露（简单尝试了进入容器查询数据库数据）。</p><p>办公网环境同时还提供给前端同学可视化 Docker 操作界面 portainer 使用。</p><p>看似这个月的服务端学习过程比较顺利，但是我们原业务组的后端被“优化了”，我来接手原业务组 Node.js 侧的业务，还部分接手部署相关的工作。真的是挑战啊！</p><p>同时小组有打算尝试接入 AI 来辅助开发的意向，后续计划开始预研。</p><p>又能尝试新的事物咯！</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>初入后端</title>
    <link href="https://zongzi531.com/2023/11/01/%E5%88%9D%E5%85%A5%E5%90%8E%E7%AB%AF/"/>
    <id>https://zongzi531.com/2023/11/01/%E5%88%9D%E5%85%A5%E5%90%8E%E7%AB%AF/</id>
    <published>2023-11-01T09:39:05.000Z</published>
    <updated>2023-11-01T09:39:05.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>国庆回来之后，开始从事服务端开发的工作，也在服务端同事的帮助下，快速的熟悉了服务端的搭建及开发。</p><p>从框架选型开始，我选择了一个较为成熟生态的 NestJS 服务端框架，数据库选用 postgresql 。</p><p>开发规范则也是按照 NestJS 推荐的最佳实践进行执行，从 <code>controllers</code> <code>entities</code> <code>services</code> <code>modules</code> <code>dtos</code> <code>filters</code> <code>interceptors</code> 到单元测试，都是按照推荐规范进行，也是感受了一波服务端的开发规范吧。</p><p>数据库从熟悉基础的 SQL 语言外，也尝试了 <code>typeorm</code> 的同步生成功能（当然，这是不推荐在生产使用的，但是在单元测试中我选择使用同步功能，以保证每个测试用例都可以纯净的执行），最后也是选用 SQL + migration 进行初始化的实现，当然也满足后期迭代的数据库迁移工作。</p><p>实现基础的 API 后也体验了使用 swagger 自动生成 API 文档的功能，感受还不错。</p><p>通过 redis 来记录用户登录状态，也是简单尝试了一把鉴权。</p><p>再来就是 CI 了，因为研发环境相当于是私有环境，部署环境不仅需要在私有环境上部署，还要在办公环境上部署，所以选型考虑使用 docker 来完成。</p><p>私有环境部署较为简单，利用 CI + docker 可以实现自动化，但是办公网环境的部署则需要将镜像 <code>docker push</code> 出来，进行手动部署。出于工作环境的限制，暂时这一步骤就考虑手动进行了。</p><p>环境的配置目前采用 dot 文件 + Dockerfile 参数实现，也可以在后期进行更自由的定制。</p><p>其余就是基础的 CRUD + 单元测试了，也是借此机会简单的熟悉了服务端研发的入门。</p><p>对了，有关鉴权 <code>token</code> 的生成，以及一些加解密算法，后续可以深入研究一下。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>再来就是这个月负责了老低代码平台的性能优化问题，因为原有的业务还在持续交付，但是在交付环境的表现并不是特别的理想。</p><p>在部分情况下会出现卡顿，或者长时间运行后会卡顿的现象。</p><p>经过对交付项目的观察，也是发现了确实存在内存泄露的问题。</p><p>从而对老低代码平台进行性能排查，从平台侧、组件侧、框架侧（Vue 2.6、组件库）其实都能看到一些内存泄露的问题。</p><p>比较简单击破的其实是组件侧，虽然组件量大，但是代码逻辑相对较为简单，内存泄露的原因也比较好找，大多是闭包产生的内存泄露问题，其次就是全局变量、事件监听、监听对象外泄、意外报错等问题。</p><p>平台侧则较为复杂一些，需要了解分析平台渲染的运行时逻辑才能击破，检查平台自身、引用组件时、操作组件生命周期时产生不当的副作用或者未及时释放关联关系产生的内存泄露问题。</p><p>也存在着一些双向链表解除单边引起的内存泄露问题以及一些业务逻辑执行顺序不合理的地方。</p><p>再一个就是因为交付场景是在 Electron 里运行的，是不是可以使用 Electron 来进行定期手动 GC 释放，当然这个思路还没有尝试过。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>鸽子王</title>
    <link href="https://zongzi531.com/2023/10/07/%E9%B8%BD%E5%AD%90%E7%8E%8B/"/>
    <id>https://zongzi531.com/2023/10/07/%E9%B8%BD%E5%AD%90%E7%8E%8B/</id>
    <published>2023-10-07T07:30:33.000Z</published>
    <updated>2023-10-07T07:30:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>「消消乐」的开发进度可以说是堪比龟速，主打一个慢，咕咕咕～</p><p>最近阅读了一下比较火的 Bun 的文档，当然还没读完。</p><p>和老婆一起做了几次提拉米苏，挺有趣的。</p><p>还干嘛了？</p><p>《异人之下》好看的呀批，推荐！</p><p>话说经过这个夏天，厨艺变强了一点……</p><p>再就是国庆去日本玩了趟～嘿嘿，开心～</p><p>水完了……</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>思考性能优化</title>
    <link href="https://zongzi531.com/2023/09/01/%E6%80%9D%E8%80%83%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://zongzi531.com/2023/09/01/%E6%80%9D%E8%80%83%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2023-09-01T08:52:51.000Z</published>
    <updated>2023-09-01T08:52:51.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>其实最近也是受到了一些文章的启发，所以文章的标题会取这个，也比较怪异吧。</p><p>说起来前端的性能优化其实就是从资源入手，从浏览器运行时入手。</p><p>当然了，如果网络层面也算的话，也可以从网络层面入手。</p><h1 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h1><p>比如对从项目业务的角度出发，分析编译代码，拆分业务场景时需要用到的代码，移除不必要的模块，本质是分析无用代码，并剔除。</p><p>同样的，可以抽离减少各模块中的公共依赖模块。</p><p>比如对用户上传的资源进行相应的压缩缓存，用户读取时加快页面的加载速度，减轻服务器的负担。</p><p>比如服务端接口的必要合并、网络请求的缓存以及服务间通信使用 gRPC 。</p><h1 id="运行时优化"><a href="#运行时优化" class="headerlink" title="运行时优化"></a>运行时优化</h1><p>比如将一些包含大量计算的逻辑交由 WebWorker 来执行，虽然说线程通信也同样存在着性能的开销，但是比起大量计算的逻辑来说，这些开销似乎也不算什么。</p><p>比如通过对页面渲染任务进行拆分，以保证重要的内容优先渲染的优化逻辑，从用户体验的角度来说会是一个不错的选择，但是会产生额外的渲染任务调度拆分的开销。</p><p>从火焰图其实也可以排查出业务中存在的不必要的 JS 执行时间，对应的将其进行优化，并且可以减少不必要的重新渲染页面逻辑。</p><p>在一些交互高频的操作场景下，可以考虑使用原生语法代替框架带来的性能损耗。</p><h1 id="无止境的优化"><a href="#无止境的优化" class="headerlink" title="无止境的优化"></a>无止境的优化</h1><p>其实让我比较纠结的就是，优化这件事件总是针对当下，而代码设计也总是针对未来，但是在团队开发的环境中，怎样可以避免因为业务迭代产生的优化失效？</p><p>如果说是需要通过人工的方式来持续的做这件事情的话，未免也太无止境了，会让人崩溃。</p><p>就算掌握了这些技巧，针对当前的版本来说是最优解，但是产品肯定会一直的迭代，而优化如何能够轻松的跟上迭代的步伐呢？</p><p>这是一个引人思考的问题，我也暂时还没解出来……</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="优化" scheme="https://zongzi531.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="性能优化" scheme="https://zongzi531.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="优化" scheme="https://zongzi531.com/tags/%E4%BC%98%E5%8C%96/"/>
    
    <category term="性能" scheme="https://zongzi531.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>git多合一</title>
    <link href="https://zongzi531.com/2023/08/01/git%E5%A4%9A%E5%90%88%E4%B8%80/"/>
    <id>https://zongzi531.com/2023/08/01/git%E5%A4%9A%E5%90%88%E4%B8%80/</id>
    <published>2023-08-01T09:09:25.000Z</published>
    <updated>2023-08-01T09:09:25.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>我们都会遇到分支 Feature 合并的协作场景吧，接下来我将总结一个。</p><p>假设我们在某个 Feature 分支提交了许多 commit 信息，我们需要将近期研发的 Feature 合并至主分支，或者将近期的某部分 Feature 合并至主分支。</p><p>操作这个的前提是，需要团队养成平时研发时保持良好的纯净的 commit 信息习惯，我们只做 git 操作。</p><p>首先我们需要操作 <code>git rebase -i</code> 指令，将需要合并的 Feature 合成一条 commit 记录。</p><p>操作后，可能会变成 <code>Detached HEAD</code> commit 记录，需要执行 <code>git branch [branch-name] [commit id]</code> 以创建新的分支。</p><p>在此之后，我们需要修改此条 commit 记录的时间，可以执行 <code>date -R</code> 取得当前时间，如 <code>Tue, 01 Aug 2023 09:15:01 +0800</code> 。</p><p>然后通过 <code>git commit --amend --date=&quot;Tue, 01 Aug 2023 09:15:01 +0800&quot;</code> 命令修改提交时间。</p><p>记住此条 commit 的 hash 值后回到主分支操作 <code>git cherry-pick</code> 命令（如果有冲突请自行本地处理）。</p><blockquote><p>如果额外产生了一条 merge 信息，请尝试使用 <code>git cherry-pick -m</code> 进行解决。</p></blockquote><p>待操作完成后，可以将操作过程中产生的额外本地分支移除，或是同步删除远端 Feature 。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#删除本地分支</span><span class="token function">git</span> branch <span class="token parameter variable">-d</span> <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment">#删除远程分支</span><span class="token function">git</span> push origin <span class="token parameter variable">--delete</span> <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么，现在就实现了分支 Feature 合并到主分支的纯净操作。</p><p>分支多条 commit 合一后，同步到主分支为一次 commit。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Git" scheme="https://zongzi531.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://zongzi531.com/tags/Git/"/>
    
    <category term="git" scheme="https://zongzi531.com/tags/git/"/>
    
    <category term="rebase" scheme="https://zongzi531.com/tags/rebase/"/>
    
    <category term="commit" scheme="https://zongzi531.com/tags/commit/"/>
    
    <category term="cherry-pick" scheme="https://zongzi531.com/tags/cherry-pick/"/>
    
  </entry>
  
  <entry>
    <title>试着做一个「消消乐」吧</title>
    <link href="https://zongzi531.com/2023/07/03/%E8%AF%95%E7%9D%80%E5%81%9A%E4%B8%80%E4%B8%AA%E6%B6%88%E6%B6%88%E4%B9%90%E5%90%A7/"/>
    <id>https://zongzi531.com/2023/07/03/%E8%AF%95%E7%9D%80%E5%81%9A%E4%B8%80%E4%B8%AA%E6%B6%88%E6%B6%88%E4%B9%90%E5%90%A7/</id>
    <published>2023-07-03T18:01:23.000Z</published>
    <updated>2023-07-03T18:01:23.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>这个月很高兴老婆抢到了五月天的演唱会门票，又去 High 了一把，真爽！</p><p>可是后半个月我却因为吃坏肚子，休息了好几天……</p><p>始终是怀疑是盒马的冷冻烤翅因为我没烤熟吃坏了肚子，非常难受……</p><p>生病使我更加的确信，健康的重要以及老婆的重要！</p><h2 id="碧蓝航线"><a href="#碧蓝航线" class="headerlink" title="碧蓝航线"></a>碧蓝航线</h2><p>陪伴了我好几年的黄油，决定退坑了！也愿碧蓝航线可以蒸蒸日上！</p><h2 id="任务进度"><a href="#任务进度" class="headerlink" title="任务进度"></a>任务进度</h2><ul><li><em><strong>「日本語学習計画」</strong>：语法及词汇 <strong>第1页</strong></em></li><li><em><strong>「计算机图形学」</strong>：材质与外观</em></li><li><strong>「锻炼身体」</strong>：步行、上楼梯、Just Dance、健身环、刘畊宏直播 <strong>待加强</strong></li><li><em><strong>「ECMA-262」</strong>：6.2.4 The Reference Specification Type</em></li><li><strong>「Rust语言圣经(Rust教程 Rust Course)」</strong>：11.5.1. 数据布局和基本操作</li><li><strong>「Rust By Practice( Rust 练习实践 )」</strong>：17.3. 深入生命周期</li><li><strong>「The <code>wasm-bindgen</code> Guide」</strong>：1.10. web-sys: Closures</li><li><strong>「Rust 秘典（死灵书）」</strong>：3.1. 引用</li><li><del><strong>「Machine Learning 2022 Spring」</strong>：Lecture 15:Meta Learning</del></li></ul><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>来谈谈机器学习吧，学习完机器学习的课程，可以说只学了几根鸡毛，因为没有「环境」的关系，所以其实没办法真正涉猎到这个领域去，只是希望自己可以通过这次学习简单的认识到一些有关机器学习的内容，或许可以在将来，在其他的领域把这些概念融会贯通应用起来。</p><h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><p>Unity 在这个月也完成了基础课程的学习，对基础的界面有了浅显的认识，也学习了一个消消乐的课程，课程中提供的游戏模式有时间模式、障碍模式、剩余次数模式，还是比较经典的。</p><p>我想经过学习后，通过自己的理解（绝对不抄），实现一款消消乐的游戏。</p><p>我计划只先实现一个时间奖励模式，计划在国庆节前能完成。</p><p>话说回来，我去查了一下，如果上架苹果商店或者 Steam 商店是要交一笔费用的，想想还是算了，毕竟自己啥也不是。</p><p>再来就是这个消消乐的 UI 设计了，我打算使用 sd 来完成，所以我最近又抓起了 sd 来尝试把玩。</p><p>也希望能够算出让我满意的 UI 了，如果这一步没走通的话，我只能先用一些素的图片来撑场面了。</p><h2 id="低代码"><a href="#低代码" class="headerlink" title="低代码"></a>低代码</h2><p>工作方面还是主要负责低代码相关的研发，低代码调度器、低代码脚手架、低代码运行时性能优化</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>游戏梦</title>
    <link href="https://zongzi531.com/2023/06/01/%E6%B8%B8%E6%88%8F%E6%A2%A6/"/>
    <id>https://zongzi531.com/2023/06/01/%E6%B8%B8%E6%88%8F%E6%A2%A6/</id>
    <published>2023-06-01T08:20:55.000Z</published>
    <updated>2023-06-01T08:20:55.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>AI 的热度从我这里开始降低了，一是能做的事情确实很少，只能尝试些末端的产物，比如说生图。</p><p>不过生图这块领域还得去玩一下训练，这毕竟和游戏梦有着关联。</p><p>机器学习学习起来的感觉就是，道理都听得懂，但是没法实践，受到了设备的限制吧算是，当然我只听了一些理论，到实践确实还是有很大距离的。</p><p>AI 先说到这里，为什么这次想说游戏梦。</p><p>其实，应该来说喜欢玩游戏的人，一定有着自己做游戏的想法，假如自己能做出一款游戏，不会觉得很酷嘛！</p><p>如果说自己做的游戏有人玩，并且玩的开心，自己也会非常开心！</p><p>到现在前端也做了 6 年之久了，虽然现在会的一些东西已经超出了前端范畴，但是仍然会觉得处在瓶颈期。</p><p>也虽然本意上就不希望自己过度工作，而是把自己的时间更多聚焦在生活。</p><p>说了这么多废话，我想表达什么呢？</p><p>我觉得现在机会出现了，因为工作出现 Unity 的关系，有大佬和我分享游戏相关的内容时，并且 AI 在未来能协助我的时候，我认为我需要开始学习游戏制作，尝试着梦想成真！</p><p>我也不介意我跳出前端这个圈子，我认为软件开发，语言只是达到目的的工具，而思想才是能够让自己更上一层楼的宝贵核心。</p><p>所以，我想制作游戏，我想让人玩我做的游戏！</p><p>光是想想就觉得很酷！鸡皮疙瘩起来了！</p><h2 id="任务进度"><a href="#任务进度" class="headerlink" title="任务进度"></a>任务进度</h2><ul><li><em><strong>「日本語学習計画」</strong>：语法及词汇 <strong>第1页</strong></em></li><li><em><strong>「计算机图形学」</strong>：材质与外观</em></li><li><strong>「锻炼身体」</strong>：步行、上楼梯、Just Dance、健身环、刘畊宏直播 <strong>待加强</strong></li><li><em><strong>「ECMA-262」</strong>：6.2.4 The Reference Specification Type</em></li><li><strong>「Rust语言圣经(Rust教程 Rust Course)」</strong>：11.5.1. 数据布局和基本操作</li><li><strong>「Rust By Practice( Rust 练习实践 )」</strong>：17.3. 深入生命周期</li><li><strong>「The <code>wasm-bindgen</code> Guide」</strong>：1.10. web-sys: Closures</li><li><strong>「Rust 秘典（死灵书）」</strong>：3.1. 引用</li><li><strong>「Machine Learning 2022 Spring」</strong>：Lecture 12:Reinforcement Learning</li></ul><p>工作方面仍然在参与云渲染、低代码建设（脚手架、开放式调度器）</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>初识机器学习</title>
    <link href="https://zongzi531.com/2023/05/04/%E5%88%9D%E8%AF%86%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zongzi531.com/2023/05/04/%E5%88%9D%E8%AF%86%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-05-04T13:43:48.000Z</published>
    <updated>2023-05-04T13:43:48.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>很明显， AI 一定会改变我们的生活方式、工作方式，并且是危险的。</p><p>因为从目前来看，需要 Web3 得到进一步发展，并且成为基础设施后， AI 才会相对变得不那么危险。</p><p>当然，我这里指的危险并不是 AI 自己的演化，而是某些企业基于 AI 的能力来深度定制千人千面。</p><p>毕竟目前处于 Web2 阶段，形成这样的局面很危险。</p><p>就像是「火影忍者」里的「无限月读」幻术一样，“让世上的人们沈浸在美好中，以此来结束世间的痛苦与战乱。”</p><h2 id="任务进度"><a href="#任务进度" class="headerlink" title="任务进度"></a>任务进度</h2><ul><li><em><strong>「日本語学習計画」</strong>：语法及词汇 <strong>第1页</strong></em></li><li><em><strong>「计算机图形学」</strong>：材质与外观</em></li><li><strong>「锻炼身体」</strong>：步行、上楼梯、Just Dance、健身环、刘畊宏直播 <strong>待加强</strong></li><li><em><strong>「ECMA-262」</strong>：6.2.4 The Reference Specification Type</em></li><li><strong>「Rust语言圣经(Rust教程 Rust Course)」</strong>：11.5.1. 数据布局和基本操作</li><li><strong>「Rust By Practice( Rust 练习实践 )」</strong>：17.3. 深入生命周期</li><li><strong>「The <code>wasm-bindgen</code> Guide」</strong>：1.10. web-sys: Closures</li><li><strong>「Rust 秘典（死灵书）」</strong>：3.1. 引用</li><li><strong>「Machine Learning 2022 Spring」</strong>：Lecture 8:Auto-encoder&#x2F; Anomaly Detection</li></ul><h2 id="stable-diffusion-安装指南"><a href="#stable-diffusion-安装指南" class="headerlink" title="stable-diffusion 安装指南"></a>stable-diffusion 安装指南</h2><p>当然不是复制官网的内容，也是借着可以在公司使用 RTX4090 的机会，在公司部署 stable-diffusion 。</p><p>受到网络的影响，所以总结一些其他安装思路。</p><p>但凡是安装出现问题，多数情况都是因为网络的影响所产生的，所以你懂的，根本的解决思路就是解决网络问题。</p><h3 id="安装-torch-1-13-1-cu117-cp310-cp310-win-amd64-whl-缓慢或者容易中断"><a href="#安装-torch-1-13-1-cu117-cp310-cp310-win-amd64-whl-缓慢或者容易中断" class="headerlink" title="安装 torch-1.13.1+cu117-cp310-cp310-win_amd64.whl 缓慢或者容易中断"></a>安装 torch-1.13.1+cu117-cp310-cp310-win_amd64.whl 缓慢或者容易中断</h3><p>可以使用其他下载工具把这个文件单独下载下来，然后进行手动安装。</p><p>需要注意的是，这里需要使用 <code>venv</code> 下的 <code>pip</code> 进行安装，可以尝试输入命令进行安装即可：</p><blockquote><p><a href="https://download.pytorch.org/whl/">https://download.pytorch.org/whl/</a> 这个地址下载起来确实有点吃力</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.<span class="token punctuation">\</span>venv<span class="token punctuation">\</span>Scripts<span class="token punctuation">\</span>pip.exe <span class="token function">install</span> .<span class="token punctuation">\</span>torch-1.13.1+cu117-cp310-cp310-win_amd64.whl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="git-仓库拉取慢"><a href="#git-仓库拉取慢" class="headerlink" title="git 仓库拉取慢"></a>git 仓库拉取慢</h3><p>没什么特别的点，自行前往 Github 下载压缩包解压放到指定目录即可。</p><h3 id="其他安装报错"><a href="#其他安装报错" class="headerlink" title="其他安装报错"></a>其他安装报错</h3><p>如果遇到了如下提示内容，按照提示单独下载安装即可：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stdout: Microsoft Visual C++ Redistributable is not installed, this may lead to the DLL load failure.It can be downloaded at https://aka.ms/vs/16/release/vc_redist.x64.exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Auto-GPT-安装指南"><a href="#Auto-GPT-安装指南" class="headerlink" title="Auto GPT 安装指南"></a>Auto GPT 安装指南</h2><p>也是比较扯，MacOS 里面自带了 Python 2.x ，导致需要手动区分使用。</p><p>首先你需要安装 Python 3.x 并且安装 <code>pip3</code> 。</p><p>将官方安装教程的 <code>pip</code> 修改成 <code>pip3</code> 来完成安装流程。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># pip install -r requirements.txt</span>pip3 <span class="token function">install</span> <span class="token parameter variable">-r</span> requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>比较奇怪的是，我运行会报错，所以我运行 <code>main.py</code> 来启动程序。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># python -m autogpt</span>python3 <span class="token parameter variable">-m</span> autogptpython3 scripts/main.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="混合云渲染"><a href="#混合云渲染" class="headerlink" title="混合云渲染"></a>混合云渲染</h2><p>只是依次尝试了 WebRTC 、Electron 和 Tauri 三个技术，没什么特别好说的，只是记录一下。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.com/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.com/tags/Blog/"/>
    
  </entry>
  
</feed>
