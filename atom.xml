<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zong</title>
  
  
  <link href="https://zongzi531.github.io/atom.xml" rel="self"/>
  
  <link href="https://zongzi531.github.io/"/>
  <updated>2025-06-01T09:56:31.000Z</updated>
  <id>https://zongzi531.github.io/</id>
  
  <author>
    <name>Zong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅聊 NL2SQL 的实战</title>
    <link href="https://zongzi531.github.io/2025/06/01/%E6%B5%85%E8%81%8ANL2SQL%E7%9A%84%E5%AE%9E%E6%88%98/"/>
    <id>https://zongzi531.github.io/2025/06/01/%E6%B5%85%E8%81%8ANL2SQL%E7%9A%84%E5%AE%9E%E6%88%98/</id>
    <published>2025-06-01T09:56:31.000Z</published>
    <updated>2025-06-01T09:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node  --><span id="more"></span><blockquote><p>大模型的应用环节！</p></blockquote><p>其实硬要说有什么技术含量也没有，一直在 prompt 工程上玩转罢了。</p><p>一个简易的 NL2SQL ，只需要把用户的问题，和数据库的表结构，给到大模型生成 SQL 就可以了。</p><p>然后再通过返回的 SQL 去查询数据库，就可以得到结果即可。</p><p>当然这是单次的查询，如果你的数据库信息很庞大，字段也很多，这时候就需要使用 RAG 来进行优化。</p><p>以减少上下文的长度。</p><p>那么肯定会有人好奇，生成的 SQL 会不会存在安全问题等等，那就不要直接生成 SQL ，而是生成一个 DSL 。</p><p>而这个 DSL 可以通过程序转成 SQL ，以保证查询的安全性。</p><p>同理 NL2SQL 在低代码的场景下，能生成低代码组件所需的配置信息，即实时获取数据的配置信息，同时依赖低代码规范，从而达成 NL2C ，来降低低代码平台的使用门槛。</p><p>从产品的角度，需要从准确性，简易的操作性，来改变用户的使用习惯，让用户相信大模型的能力。</p><p>结合产品的特点，制定合适友好的大模型路由即可。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node  --&gt;</summary>
    
    
    
    <category term="LLM" scheme="https://zongzi531.github.io/categories/LLM/"/>
    
    
    <category term="LLM" scheme="https://zongzi531.github.io/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>再见，我的初代 MacBook Pro</title>
    <link href="https://zongzi531.github.io/2025/05/01/byePro/"/>
    <id>https://zongzi531.github.io/2025/05/01/byePro/</id>
    <published>2025-05-01T07:33:28.000Z</published>
    <updated>2025-05-01T07:33:28.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node  --><span id="more"></span><blockquote><p>那么最后照一张照片吧，微笑🙂</p></blockquote><p>近 8 年的时间里，感谢你的陪伴，陪伴着我的代码技术成长，也感谢你提供的 Mac OS 系统，让我可以更轻易的进入代码世界，同时，谢谢你陪我一起奋战在职场的前线！</p><p>回看刚拥有你的时候，那时的我是如此的高兴，现在也是！</p><p>我不希望把你沉睡在家里，我想你也不想自己这样，所以，我们需要在此分别，向着未来发光发亮。</p><p>虽然现在要和你分别，但是我会带着你的意志和我一起继续前行！</p><p>我想你也会带着我的意志一起前行，毕竟我们 8 年的默契，一定会心有灵犀。</p><blockquote><p><a href="/2017/05/29/Pro/">入手 MacBook Pro</a></p></blockquote><p>当听到 Moscow 这首歌的时候，大脑的节奏和记忆一下子回到了 2017 年，感谢你在这么多人中选择了我，选择和我一起前往代码的世界。</p><p>我相信我们通过电子节奏的连接后，你也回到了 2017 年，我们第一次见面的时候，梦开始的地方。</p><blockquote><p>看了一下最近 2 个月的工作内容，基本是围绕着 AI 孵化产品。借助 AI 的能力，增强产品的能力。</p></blockquote><p>要说 AI 赋能吧，虽然说把 AI 转化成智能化的服务接入到业务中，但是感觉到成熟可信还需走一段较长的路程，虽然短而小的工具基本还是蛮稳定的，但是要上升到信任这个程度，感觉尚且还需要一段时间，至少我是这么认为的。</p><p>从接触 AI 到简单了解大模型，再到现在的 RAG 、 MCP 等等也好，其实能感受到 AI 的发展之快，但是总觉得要到真的普遍的落地（达成信任）的环节，还需要时间的考验。</p><p>不过，可以发现的是， AI 还是无法淘汰人，AI 只能做到帮助人，这个样子。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node  --&gt;</summary>
    
    
    
    <category term="MAC" scheme="https://zongzi531.github.io/categories/MAC/"/>
    
    
    <category term="Apple" scheme="https://zongzi531.github.io/tags/Apple/"/>
    
    <category term="MAC OS" scheme="https://zongzi531.github.io/tags/MAC-OS/"/>
    
  </entry>
  
  <entry>
    <title>我不会开车</title>
    <link href="https://zongzi531.github.io/2025/04/01/%E6%88%91%E4%B8%8D%E4%BC%9A%E5%BC%80%E8%BD%A6/"/>
    <id>https://zongzi531.github.io/2025/04/01/%E6%88%91%E4%B8%8D%E4%BC%9A%E5%BC%80%E8%BD%A6/</id>
    <published>2025-04-01T11:18:39.000Z</published>
    <updated>2025-04-01T11:18:39.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>我拿了 C1 的驾照的今天，行驶里程有 6 万公里，但是细想，我并不会开车。</p><p>虽然我变道会打灯，也不开慢车，但是仔细一想我还是不会开车。</p><p>杭州道路上的车辆，就像是杭州社会的一个缩影，就算我遵守规则，努力不成为道路上给其他人添加麻烦的那个人，也一样很难避免给我造成麻烦的人。</p><p>我也在尽量的改变，不能说是包容其他车辆吧，只能说是尽量保证自己的安全，我希望自己能成为一个会开车的人。</p><p>我经常无法释怀道路上形形色色的驾驶员，会斥责他们的驾驶习惯多么不安全，可这又能怎么样呢，我也在这个道路中，我无法改变他们，我与他们较真，最后只会浪费我自己的精力。</p><p>可是我真的在这个漩涡中，很难脱离出来，我觉得自己是中式教育产出的一种人。</p><p>喜欢论对错，守规矩，有道德。可是这又怎么样呢，我依然不会开车。总有人会说小孩子才争对错，可大人的利弊不也是对错的一种形式吗？对错只不过是相对的，不同立场的。</p><p>记得刚开始开车的时候，我遇到右转汇入的车辆未观察直行车辆也未让行的时候，我会愤怒，我会鸣笛，可是那又怎么样呢？这样的车就是这样的行车风格，如同做事做人。后来我也想开了，当我看到这样不观察不减速的车辆，我会减速，我会让他们，我会觉得和他们较真，讲规则都是多余的，因为我们的认知不在一层。可我们却可以在同一条道路上行驶，而我却要比这样的车操更多的心，所以，凭什么？综合下来，我还会这样想，说明我不会开车。</p><p>再一次在道路缩减，二变一的时候，我明白要交替通行，当我感受到对方没有这个意识的时候，我会给油去争取我的路权，所谓的正确。可这又怎么样呢，最后刮蹭，直到交警判对方全责，对方才或多或少的意识到自己的问题，可是耽误的是我的时间，这时候我才明白，我和他也不在一个层次，我又得操更多的心，所以，凭什么？还是我不会开车。</p><p>我明白道路上不同层次的人，感谢道路上为我操心的人，谢谢你们的包容，让我可以安全到达目的地。</p><p>或许这就是社会，我想摆脱现在的漩涡，我想成为会开车的人。</p><p>所以怎么样才算是会开车的人呢？还是说我需要寻找一个适合自己的漩涡？或者说有没有风平浪静的海面？</p><p>值得思考。</p><p>回想起日本道路上的车辆，我会觉得杭州的道路上确实乱糟糟的，我也在对比，在寻找我心目中的正确，建立我自己的三观，试图寻找着我向往的社会。（没有说日本哪里都好，只是拿这个举个例子）</p><p>杭州真的变得没那么喜欢了。</p><p>到底是我变了，还是杭州变了，还是都变了。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/tags/Blog/"/>
    
    <category term="感悟" scheme="https://zongzi531.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
    <category term="社会" scheme="https://zongzi531.github.io/tags/%E7%A4%BE%E4%BC%9A/"/>
    
    <category term="三观" scheme="https://zongzi531.github.io/tags/%E4%B8%89%E8%A7%82/"/>
    
    <category term="思考" scheme="https://zongzi531.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
    <category term="杭州" scheme="https://zongzi531.github.io/tags/%E6%9D%AD%E5%B7%9E/"/>
    
  </entry>
  
  <entry>
    <title>赏花Ⅱ</title>
    <link href="https://zongzi531.github.io/2025/03/03/%E8%B5%8F%E8%8A%B12/"/>
    <id>https://zongzi531.github.io/2025/03/03/%E8%B5%8F%E8%8A%B12/</id>
    <published>2025-03-03T09:32:36.000Z</published>
    <updated>2025-03-03T09:32:36.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>这个月基本上是在参与基础建设和低代码建设，计划低代码与 AI 适配。基本是在写 Prompt 。</p><p>月初的杭州一下子到了夏天的感觉，那就来赏赏梅花吧～</p><div style="display: grid; grid-template-columns: 1fr 1fr; grid-gap: 16px;">  <img src="pic2.jpg">  <img src="pic3.jpg"></div><hr><blockquote><p>“花气袭人知骤暖，鹊声穿树喜新晴。” —— 陆游 《村居书喜》</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>入门 ANTLR 4</title>
    <link href="https://zongzi531.github.io/2025/02/11/%E5%85%A5%E9%97%A8antlr4/"/>
    <id>https://zongzi531.github.io/2025/02/11/%E5%85%A5%E9%97%A8antlr4/</id>
    <published>2025-02-11T15:52:29.000Z</published>
    <updated>2025-02-11T15:52:29.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>最近因为业务需要，所以开始接触 ANTLR 4 语法解析器，在业务层面需要适配自己业务特征的 DSL 输入框。</p><p>调研了几种方向：</p><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>纯纯的 <code>string</code> 解析</td><td>开发周期短，轻松</td><td>迭代成本高，容易推翻重做</td></tr><tr><td>Babel 解析</td><td>基于文本解析成 AST 语法树，通过 AST 来完成业务，迭代轻松</td><td>需要实现文本分词，浏览器环境使用为动态解析，存在性能损耗</td></tr><tr><td>ANTLR 4 解析</td><td>定义语法能够静态编译出对应代码，迭代轻松</td><td>需要学习 ANTLR 4 生态环境</td></tr></tbody></table><blockquote><p>结合业务场景的需要，考虑到未来的迭代可能，所以决定使用 ANTLR 4 解析方案。</p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><code>package.json</code> 所需依赖：</p><table><thead><tr><th>名称</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td><code>antlr4ng-cli</code></td><td><code>^1.0.7</code></td><td>将 ANTLR 4 编译为 TypeScript 文件的终端执行文件</td></tr><tr><td><code>antlr-format-cli</code></td><td><code>^1.2.1</code></td><td>美化 <code>*.g4</code> 格式</td></tr><tr><td><code>antlr4ng</code></td><td><code>2.0.11</code></td><td>ANTLR 4 在 JavaScript 运行时</td></tr><tr><td><code>antlr4-c3</code></td><td><code>3.3.7</code></td><td>ANTLR 4 代码补全包</td></tr></tbody></table><blockquote><p>使用 <code>antlr4ng-cli</code> 编译需要电脑安装 JDK ，我这里对应的 JDK 版本是 17.0.12。<br>编译脚本参考<a href="https://github.com/DTStack/dt-sql-parser/blob/main/scripts/antlr4.js">DTStack&#x2F;dt-sql-parser</a>。<br>仓库使用 <code>inquirer</code> 包进行多 DSL 编译，因为业务场景，我移除了此功能，只对指定的文件进行编译工作。</p></blockquote><h1 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h1><p>简单做个示例，实现变量比较的功能。</p><p>在对应的目录下创建 <code>XXLLexer.g4</code> 词法分析文件和 <code>XXLParser.g4</code> 解析文件。</p><pre class="line-numbers language-antlr" data-language="antlr"><code class="language-antlr">&#x2F;&#x2F; XXLLexer.g4&#x2F;&#x2F; ...lexer grammar XXLLexer;options &#123;    caseInsensitive&#x3D; true;&#125;EQUAL                  : &#39;&#x3D;&#x3D;&#39;;AND                    : &#39;AND&#39;;OR                     : &#39;OR&#39;;VALUE                  : (LETTER | DIGIT)+;SPACE                  : [ \t\r\n]+ -&gt; skip;fragment DIGIT         : [0-9];fragment LETTER        : [A-Za-z];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-antlr" data-language="antlr"><code class="language-antlr">&#x2F;&#x2F; XXLParser.g4&#x2F;&#x2F; ...parser grammar XXLParser;options &#123;    tokenVocab&#x3D; XXLLexer;    caseInsensitive&#x3D; true;    superClass&#x3D;ParserBase;&#125;@header &#123;import &#123; ParserBase &#125; from &#39;..&#x2F;ParserBase&#39;;&#125;program    : singleStatement (AND | OR)* singleStatement* EOF    ;singleStatement    : singleStatement (AND | OR) singleStatement    | equalStatement    ;equalStatement    : VALUE EQUAL VALUE    ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后支持的效果是：</p><ul><li><code>a == b</code></li><li><code>C1 == Z AND a == b</code></li></ul><p>解析器的类也基于业务做了调整，可以参考 dt-sql-parser 项目。<br>g4 语法学习请参考<a href="https://github.com/antlr/antlr4/blob/dev/doc/getting-started.md">Getting Started with ANTLR v4</a>。<br>语法参考<a href="https://github.com/antlr/grammars-v4">antlr&#x2F;grammars-v4</a>。</p><h1 id="代码补全"><a href="#代码补全" class="headerlink" title="代码补全"></a>代码补全</h1><p>可以自己基于解析器实现一个代码补全方法，创建的方法：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> CandidatesCollection<span class="token punctuation">,</span> CodeCompletionCore <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'antlr4-c3'</span><span class="token punctuation">;</span><span class="token comment">// ...</span><span class="token keyword">const</span> core <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CodeCompletionCore</span><span class="token punctuation">(</span>parserIns<span class="token comment">/* 解析器实例 */</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * 设置需要匹配的规则 * 比如：singleStatement * 则设置： * protected preferredRules = new Set([ *   XXLParser.RULE_singleStatement, * ]); */</span>core<span class="token punctuation">.</span>preferredRules <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>preferredRules<span class="token punctuation">;</span><span class="token comment">// 获得候选列表</span><span class="token keyword">const</span> candidates <span class="token operator">=</span> core<span class="token punctuation">.</span><span class="token function">collectCandidates</span><span class="token punctuation">(</span>caretTokenIndex<span class="token punctuation">,</span> c3Context<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基于候选列表，可以提供一个体检舒适的 DSL 文本输入框，具备代码补全功能。</p><p>到此，算是浅尝了一下 ANTLR 4 ，能感受到的好处就是，当 DSL 产生迭代后，我基本只需要修改 g4 文件，重新编译即可。</p><p>非常的舒适～</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Tools" scheme="https://zongzi531.github.io/categories/Tools/"/>
    
    
    <category term="ANTLR" scheme="https://zongzi531.github.io/tags/ANTLR/"/>
    
    <category term="ANTLR 4" scheme="https://zongzi531.github.io/tags/ANTLR-4/"/>
    
    <category term="语法解析器" scheme="https://zongzi531.github.io/tags/%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>蛇蛇如意</title>
    <link href="https://zongzi531.github.io/2025/02/06/%E8%9B%87%E8%9B%87%E5%A6%82%E6%84%8F/"/>
    <id>https://zongzi531.github.io/2025/02/06/%E8%9B%87%E8%9B%87%E5%A6%82%E6%84%8F/</id>
    <published>2025-02-06T08:33:56.000Z</published>
    <updated>2025-02-06T08:33:56.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>发现自己的工作视角发生了转变，真正的从前端的视角脱离出来，上升到更全面的产品视角或者项目视角，考虑或者想做好的事情变得更多了。</p><p>这也是好事，因为视角的转变，从而影响到职业方向的转变。从而聚焦起来，把项目做的更好。</p><p>除了基础建设、去年还更多的参与到了项目也产品中去，感受和体会也会比较多吧。</p><p>当然还少不了 AI ，接触 RAG 相关的领域。</p><p>感受到了 AI 的飞速发展，和自己能力的有限。</p><p>所以，现在看来角色的视角转变确实还是蛮有意思的，或更深或更广。</p><p>新的一年，加油！</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>２０２５年おめでとうございます</title>
    <link href="https://zongzi531.github.io/2025/01/01/%EF%BC%92%EF%BC%90%EF%BC%92%EF%BC%95%E5%B9%B4%E3%81%8A%E3%82%81%E3%81%A7%E3%81%A8%E3%81%86%E3%81%94%E3%81%96%E3%81%84%E3%81%BE%E3%81%99/"/>
    <id>https://zongzi531.github.io/2025/01/01/%EF%BC%92%EF%BC%90%EF%BC%92%EF%BC%95%E5%B9%B4%E3%81%8A%E3%82%81%E3%81%A7%E3%81%A8%E3%81%86%E3%81%94%E3%81%96%E3%81%84%E3%81%BE%E3%81%99/</id>
    <published>2025-01-01T13:09:36.000Z</published>
    <updated>2025-01-01T13:09:36.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><h2 id="回顾-2024-年"><a href="#回顾-2024-年" class="headerlink" title="回顾 2024 年"></a>回顾 2024 年</h2><ul><li><strong><span class="github-emoji" alias="couplekiss_man_woman" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f469-2764-1f48b-1f468.png?v8">👩️‍❤️‍💋️‍👨</span> 更爱老婆，和她开心幸福在一起</strong></li><li><strong><span class="github-emoji" alias="heartpulse" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f497.png?v8">💗</span> 更爱家人，祝家人身体健康，平平安安</strong></li><li><strong><span class="github-emoji" alias="horse_racing" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f3c7.png?v8">🏇</span> 锻炼身体</strong> <code>适量</code></li><li><strong><span class="github-emoji" alias="books" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4da.png?v8">📚</span> 建立自己的知识体系</strong> <code>持续进行</code></li><li><strong>RAG</strong></li><li><strong>服务端</strong></li><li><strong>架构学习</strong></li></ul><h2 id="展望-2025-年"><a href="#展望-2025-年" class="headerlink" title="展望 2025 年"></a>展望 2025 年</h2><ul><li><strong><span class="github-emoji" alias="couplekiss_man_woman" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f469-2764-1f48b-1f468.png?v8">👩️‍❤️‍💋️‍👨</span> 更爱老婆，和她开心幸福在一起</strong></li><li><strong><span class="github-emoji" alias="heartpulse" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f497.png?v8">💗</span> 更爱家人，祝家人身体健康，平平安安</strong></li><li><strong><span class="github-emoji" alias="horse_racing" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f3c7.png?v8">🏇</span> 锻炼身体</strong></li><li><strong><span class="github-emoji" alias="books" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4da.png?v8">📚</span> 建立自己的知识体系</strong></li><li><strong>架构</strong></li><li><strong>机器学习</strong></li></ul>]]></content>
    
    
    <summary type="html">元旦快乐</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>体验咖啡集市</title>
    <link href="https://zongzi531.github.io/2024/12/01/%E4%BD%93%E9%AA%8C%E5%92%96%E5%95%A1%E9%9B%86%E5%B8%82/"/>
    <id>https://zongzi531.github.io/2024/12/01/%E4%BD%93%E9%AA%8C%E5%92%96%E5%95%A1%E9%9B%86%E5%B8%82/</id>
    <published>2024-12-01T10:08:39.000Z</published>
    <updated>2024-12-01T10:08:39.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>趁着天冷前，刚好看到天目里有举办活动，而且是第二届咖啡集市，就去感受一下吧。</p><p>去的当天人还是蛮多的，不知道大家都是喜欢喝咖啡，还是大多数和我一样，去凑凑热闹的。</p><p>因为基本都没喝过，不像平时喝的咖啡，感觉摊主们都是拿了奖的高级咖啡师。</p><p>挺不错的，这样的活动。</p><p>这个月的工作基本是围绕着业务进行，低代码、VSCode 插件作用范围预研、IDEA 插件预研，等其他业务。</p><p>也通过一些以往的项目来整理关于架构的一些知识体系，让整个软件架构知识体系更加饱满（会是一个较为漫长的过程）。</p><p>大概就这么多。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>关于门户的架构思考</title>
    <link href="https://zongzi531.github.io/2024/11/01/%E5%85%B3%E4%BA%8E%E9%97%A8%E6%88%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/"/>
    <id>https://zongzi531.github.io/2024/11/01/%E5%85%B3%E4%BA%8E%E9%97%A8%E6%88%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/</id>
    <published>2024-11-01T08:33:35.000Z</published>
    <updated>2024-11-01T08:33:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我负责 UED 门户项目整体的架构设计及服务端研发工作，<br>在确定项目需求后，我使用「分层架构」设计了项目整体的架构实现方式，设计系统自上而下分为应用层、业务层、服务层、数据层；<br>在面临多种的认证方式时，选用「适配器模式」解决认证方式差异的问题；<br>在解决 UED 门户需要获取应用操作记录的问题上，使用「观察者模式」，将通过向应用获取转变为应用上送以优化操作记录获取的方式，解耦功能；<br>并且从部署视角的角色选型「虚拟化技术」以保证部署的效率和稳定；</p></blockquote><!-- no node --><span id="more"></span><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>项目第一阶段已告一段，UED 门户项目，是我写 Node.js 开始第一次正式的、完整的参与到研发过程中的项目。</p><p>从技术选型、架构设计逐一入手，是一次较为全面完整的项目体验。</p><p>后续其他部门需要门户网站时，此项目即替换 Web 界面即可交付其他部门，已实现大体复用。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>UED 部门需要建立自己的门户网站，网站需要将现有的 UED 模块服务（原型设计稿、前端组件、设计资源、文档等）集成为一体，以提供一个统一设计资源规范、资源共建、学习成长为一体的门户网站。</p><h2 id="项目要求"><a href="#项目要求" class="headerlink" title="项目要求"></a>项目要求</h2><ol><li>用户的认证方式需要支持公司认证和独立认证，并且认证的用户角色分为用户和应用即「服务模块」</li><li>门户需要收集接入应用中指定的操作记录或其他消息信息</li><li>门户计划在多套环境下进行独立部署</li></ol><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p>架构设计采用「分层架构」，将门户分别为应用层、业务层、服务层、数据层。</p><ul><li>应用层包含 UED 门户自身对用户的 Web 界面以及需要集成进来的应用如：原型设计平台、组件平台、资源平台和文档平台等</li><li>业务层包含 UED 门户提供的业务模块，包含：服务模块管理模块、用户角色权限管理模块、意见反馈模块和文章模块</li><li>服务层包含认证服务、日志服务、订阅服务和资源服务</li><li>数据层包含 PostgreSQL 、 Redis 、 MinIO</li></ul><h3 id="认证服务设计"><a href="#认证服务设计" class="headerlink" title="认证服务设计"></a>认证服务设计</h3><p>认证方式在设计之初存在两种，分别是接入公司的认证中心和实现自己独立的认证中心。可以见得，认证方式是在项目部署时就决定的内容，并且只存在认证服务内部的实现逻辑差异，所以需要保证认证服务对外一致即可。</p><p>所以在设计时，选择以自己独立的认证中心为接口标准进行设计，设计认证标准抽象，让两种方式可以按照抽象进行实现。</p><p>设计模式上，这里选择适配器（Adapter）设计模式，此模式的优点是：</p><ol><li>单一职责原则你可以将接口或数据转换代码从程序主要业务逻辑中分离。</li></ol><p>以保证每一种接入的认证方式都和程序主要业务逻辑无关，保证认证服务对外提供的接口和行为一致。</p><ol start="2"><li>开闭原则。只要客户端代码通过客户端接口与适配器进行交互，你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。</li></ol><p>新增认证方式或则切换认证方式，都无需修改其他服务。</p><p>缺点是：</p><ol><li>代码整体复杂度增加，因为你需要新增一系列接口和类。有时直接更改服务类使其与其他代码兼容会更简单。</li></ol><p>所以在认证模式开发的阶段，使用适配器设计模式会使得代码较无设计模式的情况下，更为复杂一些。但是在程序运行阶段对认证方式切换则无需更新程序即可完成，同时新增认证方式也不会修改到程序的其他业务逻辑。</p><p>从程序质量属性的角度，保证了程序的可修改性。</p><h3 id="订阅服务设计"><a href="#订阅服务设计" class="headerlink" title="订阅服务设计"></a>订阅服务设计</h3><p>如果按照传统的方式去一一对接各个应用中的操作记录或者消息信息，会使得 UED 门户的程序代码与接入的应用功能强耦合，为了解决这个问题。</p><p>UED 门户提供订阅服务，采用观察者模式（Observer）来对接实现各个应用中的操作记录或者消息信息记录。</p><p>通过向应用获取转变为应用上送以优化操作记录获取的方式，约定 UED 门户所需的消息主题，各个应用将需要上送的消息按照对应的主题上送至 UED 门户，由 UED 门户向用户进行展示。</p><p>观察者模式的优点是：</p><ol><li>开闭原则。你无需修改发布者代码就能引入新的订阅者类</li></ol><p>即如果有新应用接入 UED 门户，保持同主题的推送消息，门户在无需进行修改的情况下，用户即可以获得新应用的消息内容。</p><p>缺点是：</p><ol><li>订阅者的通知顺序是随机的</li></ol><p>目前从需求来看，通知的顺序并没有很重要，但如果要实现顺序可以在通知内容中添加时间戳，以应用上送的时间戳为基准，以此来解决消息顺序的问题。</p><h3 id="部署视角"><a href="#部署视角" class="headerlink" title="部署视角"></a>部署视角</h3><p>从部署视角来看，项目需要在多套环境下进行部署，为了避免环境不一致引起的额外部署工作，所以选用虚拟化技术来完成项目部署。</p><p>目前公司存在办公网和内网环境，两套环境分别需要部署正式和测试环境，在技术选型上，我对 Docker 和 Kubernetes 进行了对比。</p><p>Docker 和 Kubernetes 都是虚拟化容器技术，以解决在任何计算机上部署你的项目，但是相比较而言。</p><p>Docker 属于容器运行时技术，更适合单机运行或对资源要求较小的应用，而 Kubernetes 则属于一种容器编排工具，更适合集群运行或更大规模的应用。</p><p>所以从部署视角来看，项目目前使用的用户对内，并且大部分都是研发侧的同学，同时在使用性能上并没有较高的并发需求，即最终选用 Docker 来完成部署工作更合适不过。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我负责 UED 门户项目整体的架构设计及服务端研发工作，&lt;br&gt;在确定项目需求后，我使用「分层架构」设计了项目整体的架构实现方式，设计系统自上而下分为应用层、业务层、服务层、数据层；&lt;br&gt;在面临多种的认证方式时，选用「适配器模式」解决认证方式差异的问题；&lt;br&gt;在解决 UED 门户需要获取应用操作记录的问题上，使用「观察者模式」，将通过向应用获取转变为应用上送以优化操作记录获取的方式，解耦功能；&lt;br&gt;并且从部署视角的角色选型「虚拟化技术」以保证部署的效率和稳定；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Architecture" scheme="https://zongzi531.github.io/categories/Architecture/"/>
    
    
    <category term="Architecture" scheme="https://zongzi531.github.io/tags/Architecture/"/>
    
    <category term="架构" scheme="https://zongzi531.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>低代码网格布局</title>
    <link href="https://zongzi531.github.io/2024/10/01/lowcode-grid-layout-rules/"/>
    <id>https://zongzi531.github.io/2024/10/01/lowcode-grid-layout-rules/</id>
    <published>2024-10-01T08:33:20.000Z</published>
    <updated>2024-10-01T08:33:20.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>时隔一年，又重新参与低代码的建设，重新根据业务形态抽象网格布局逻辑。</p><p>那就来分享一下网格布局的实现逻辑。</p><h2 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h2><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><p>设计将网格横向分为 <strong>12</strong> 列，并根据实际页面宽度（或者页面预设固定宽度）计算每列实际列宽，以作为 <code>w</code> 的单位映射值，即 <code>w</code> 最大为 <strong>12</strong>。</p><p>行高固定为 <strong>32</strong>px ，即 <code>h</code> 的单位映射值，不限制最大值。</p><p>格间间距为 <strong>16</strong>px 。</p><h3 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h3><h4 id="GridItem-网格项"><a href="#GridItem-网格项" class="headerlink" title="GridItem 网格项"></a><code>GridItem</code> 网格项</h4><p>此组件会体现在 <code>GridLayout</code> 下，会对业务组件或基础组件等进行包裹，以保证 <code>GridLayout</code> 在渲染时，对 <code>children</code> 各组件进行包裹。</p><p>并且，此组件自身无 <code>Schema</code> 配置信息，仅从被包裹 <code>Schema</code> 中获取 <code>size</code> 以呈现组件具体大小（实际大小），或者映射大小（网格单位，通过计算呈现实际大小）。</p><h4 id="GridLayout-网格容器"><a href="#GridLayout-网格容器" class="headerlink" title="GridLayout 网格容器"></a><code>GridLayout</code> 网格容器</h4><p>此组件为特殊内置组件（与业务组件或基础组件一致），具备 <code>Schema</code> 配置信息。</p><table><thead><tr><th>属性</th><th>备注</th><th>类型</th></tr></thead><tbody><tr><td><code>layouts</code></td><td><code>children</code> 中组件的位置信息</td><td><code>Array&lt;LayoutItem&gt;</code></td></tr></tbody></table><h6 id="相关类型"><a href="#相关类型" class="headerlink" title="相关类型"></a>相关类型</h6><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 设计参考 react-grid-layout 配置</span><span class="token keyword">interface</span> <span class="token class-name">LayoutItem</span> <span class="token punctuation">&#123;</span>  id<span class="token operator">:</span> <span class="token builtin">string</span>  x<span class="token operator">:</span> <span class="token builtin">number</span>  y<span class="token operator">:</span> <span class="token builtin">number</span>  w<span class="token operator">:</span> <span class="token builtin">number</span>  h<span class="token operator">:</span> <span class="token builtin">number</span>  gap<span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token string">'top'</span> <span class="token operator">|</span> <span class="token string">'right'</span> <span class="token operator">|</span> <span class="token string">'bottom'</span> <span class="token operator">|</span> <span class="token string">'left'</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="网格交互"><a href="#网格交互" class="headerlink" title="网格交互"></a>网格交互</h3><p>网格交互设计分为：插入、移动、大小调整、删除</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>获取环境信息</p><ul><li>是否选中组件</li><li><code>LayoutItem</code> 默认 <code>w</code> 为 6 ， <code>h</code> 为 6</li></ul><h5 id="点击插入"><a href="#点击插入" class="headerlink" title="点击插入"></a>点击插入</h5><ol><li>若未选中组件，则默认插入根 <code>GridLayout</code></li><li>更新 <code>GridLayout</code> 的 <code>layouts</code> 下 <code>LayoutItem</code> 数据至尾部（生成默认 <code>w</code> 和 <code>h</code> ）</li><li>布局计算</li><li>若选中组件，获得选中组件信息</li></ol><h6 id="选中-GridLayout"><a href="#选中-GridLayout" class="headerlink" title="选中 GridLayout"></a>选中 <code>GridLayout</code></h6><ol start="5"><li>更新 <code>GridLayout</code> 的 <code>layouts</code> 下 <code>LayoutItem</code> 数据至尾部（生成默认 <code>w</code> 和 <code>h</code> ）</li><li>布局计算</li></ol><h6 id="选中业务组件或基础组件"><a href="#选中业务组件或基础组件" class="headerlink" title="选中业务组件或基础组件"></a>选中业务组件或基础组件</h6><ol start="5"><li>获得选中组件 <code>parent</code></li><li>若是 <code>GridLayout</code> ，则更新 <code>GridLayout</code> 的 <code>layouts</code> 下 <code>LayoutItem</code> 数据至选中组件之后（生成默认 <code>w</code> 和 <code>h</code> ）</li><li>布局计算</li><li>若不是则默认插入，不执行网格布局逻辑</li></ol><h6 id="选中容器组件"><a href="#选中容器组件" class="headerlink" title="选中容器组件"></a>选中容器组件</h6><blockquote><p>容器组件为特殊组件，即业务组件或基础组件支持 <code>children</code> 渲染</p></blockquote><ol start="5"><li>默认插入，不执行网格布局逻辑</li></ol><h5 id="移动插入"><a href="#移动插入" class="headerlink" title="移动插入"></a>移动插入</h5><ol><li>获得鼠标落点（鼠标抬起位置）</li><li>获得落点组件信息</li><li>逻辑同「点击插入」时选中组件情况</li></ol><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><ol><li>获得鼠标落点（鼠标抬起位置）</li><li>获得落点组件信息</li></ol><h6 id="落点-GridLayout"><a href="#落点-GridLayout" class="headerlink" title="落点 GridLayout"></a>落点 <code>GridLayout</code></h6><ol start="3"><li>检查落点 <code>GridLayout</code> 是否与当前移动组件的 <code>parent</code> 一致</li><li>若一致则更新对应 <code>layouts</code> 下 <code>LayoutItem</code> 数据至尾部</li><li>布局计算</li><li>若不一致则执行删除和插入（采用当前 <code>w</code> 和 <code>h</code> ）操作</li></ol><h6 id="落点业务组件或基础组件"><a href="#落点业务组件或基础组件" class="headerlink" title="落点业务组件或基础组件"></a>落点业务组件或基础组件</h6><ol start="3"><li>获得落点组件 <code>parent</code> 是否与当前移动组件的 <code>parent</code> 一致</li><li>若一致则交换对应 <code>layouts</code> 下 <code>LayoutItem</code> 数据（除了交换，也可以是插入，具体根据自身业务决定）</li><li>布局计算</li><li>若不一致则执行删除和插入（采用当前 <code>w</code> 和 <code>h</code> ）操作</li></ol><h6 id="落点容器组件"><a href="#落点容器组件" class="headerlink" title="落点容器组件"></a>落点容器组件</h6><blockquote><p>容器组件为特殊组件，即业务组件或基础组件支持 <code>children</code> 渲染</p></blockquote><ol start="3"><li>执行删除和插入（不执行网格布局逻辑）操作</li><li>布局计算</li></ol><h4 id="大小调整"><a href="#大小调整" class="headerlink" title="大小调整"></a>大小调整</h4><ol><li>获得鼠标 <code>x</code> 和 <code>y</code> 的偏移量（鼠标按下到鼠标抬起后获得）</li><li>根据当前组件 <code>Schema</code> 大小累加偏移量（四舍五入）计算组件新大小，即 <code>w</code> 和 <code>h</code> 的值</li><li>更新对应 <code>layouts</code> 下 <code>LayoutItem</code> 数据</li><li>布局计算</li></ol><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ol><li>移除组件 <code>Schema</code></li><li>移除对应 <code>layouts</code> 下 <code>LayoutItem</code> （若存在）</li><li>布局计算（若存在）</li></ol><h3 id="布局计算"><a href="#布局计算" class="headerlink" title="布局计算"></a>布局计算</h3><ol><li>获得 <code>layouts</code> 信息</li><li>依次基于 <code>w</code> 和 <code>h</code> 的值计算 <code>x</code> 和 <code>y</code> 位置</li><li>并且根据当前 <code>w</code> 、 <code>h</code> 、 <code>x</code> 和 <code>y</code> 的关系计算格间间距值</li><li>更新 <code>layouts</code> 信息（格间间距在渲染、位置阴影、选中框时进行累加，不影响原值）</li><li>渲染更新</li></ol><p>算法根据自身业务决定，可以使用二维数组进行占位计算，或是使用自然堆叠计算方式，或是其他。</p><table><thead><tr><th>算法 A</th><th>算法 B</th></tr></thead><tbody><tr><td><img src="/2024/10/01/lowcode-grid-layout-rules/algorithm-a.png" alt="algorithm-a"></td><td><img src="/2024/10/01/lowcode-grid-layout-rules/algorithm-b.png" alt="algorithm-b"></td></tr></tbody></table><h4 id="算法-A"><a href="#算法-A" class="headerlink" title="算法 A"></a>算法 A</h4><blockquote><p>依次遍历 <code>layouts</code> 以返回新的 <code>x</code> 和 <code>y</code> 位置</p></blockquote><ol><li>初始化锚点 <code>x</code> 和 <code>y</code> 位置 <code>(0, 0)</code> ，行内标和行标 <code>(0, 0)</code> ，缓存最大 <code>y</code> 为 0</li><li>依次遍历，记录前一次的缓存最大 <code>y</code> 位置（用于计算格间间距）</li><li>比较 <code>LayoutItem</code> 的 <code>x</code> 与 <code>w</code> 的和是否大于 <strong>12</strong></li><li>若小于等于，则更新当前 <code>LayoutItem</code> 的 <code>x</code> 和 <code>y</code> 位置</li><li>同时更新锚点 <code>x</code> 的位置为当前 <code>LayoutItem</code> 的 <code>x</code> 与 <code>w</code> 的和</li><li>根据当前 <code>LayoutItem</code> 的 <code>y</code> 与 <code>h</code> 的和，缓存最大 <code>y</code> 位置（取最大值）</li><li>若大于，则表示溢出，重置锚点 <code>x</code> 为 0 ，将锚点 <code>y</code> 设置为缓存最大 <code>y</code></li><li>更新当前 <code>LayoutItem</code> 的 <code>x</code> 和 <code>y</code> 位置</li><li>重复 5, 6</li><li>每计算出 <code>LayoutItem</code> 的 <code>x</code> 和 <code>y</code> 位置后，比较前一次的缓存最大 <code>y</code> 位置和缓存最大 <code>y</code> 位置</li><li>若前一次的缓存最大 <code>y</code> 位置小于缓存最大 <code>y</code> 位置（说明换行过），增加行标，重置行内标为 0</li><li>反之则增加行内标</li><li>将当前行内标和行标与 <code>LayoutItem</code> 对应关联</li></ol><p>至此，已实现更新 <code>x</code> 和 <code>y</code> 位置，接下来结合行内标和行标信息来计算 <code>LayoutItem</code> 的格间间距。</p><blockquote><p>倒序遍历行内标和行标</p></blockquote><ol><li>设置第一次右间距存在标识为否，前一次行标为行内标和行标信息的最后一个值</li><li>倒序遍历，获得对应的行内标和行标</li><li>初始化 <code>LayoutItem</code> 对应的格间间距，左右上为 0 ，下为 1&#x2F;2 间距 8px</li><li>若前一次行标与当前行标不一致（意味着行变更），则重置第一次右间距存在标识为否</li><li>更新前一次行标为当前行标</li><li>若当前行标大于 1 ，则表示非第一行，设置格间间距上为 8px</li><li>若第一次右间距存在标识为是，或者当前对应的 <code>LayoutItem</code> 的 <code>x</code> 与 <code>w</code> 的和小于 <strong>12</strong> ，则设置格间间距右为 8px</li><li>若当前行内标大于 0 ，则设置格间间距左为 8px ，并将第一次右间距存在标识设置为是</li><li>更新格间间距至对应的 <code>LayoutItem</code></li></ol><h4 id="算法-B"><a href="#算法-B" class="headerlink" title="算法 B"></a>算法 B</h4><blockquote><p>依次遍历 <code>layouts</code> 以返回新的 <code>x</code> 和 <code>y</code> 位置</p></blockquote><ol><li>初始化空二维数组（记做标记空间），用于标记占位情况；<code>y</code> 标识用于记录需要延展的行数，初始为 0 ，以及上一次的 <code>y</code> 标识，同初始为 0</li><li>依次遍历，比较上一次的 <code>y</code> 标识与 <code>y</code> 标识加 <code>LayoutItem</code> 的 <code>h</code> ，取最大值更新上一次的 <code>y</code> 标识</li><li>使用上一次的 <code>y</code> 标识与标记空间长度比较，若大于 0 ，则批量生成行 <code>new Array(12).fill(null)</code></li><li>从 <code>(0, 0)</code> 标记位进行遍历（可优化至最左上角的一个 <code>null</code> 标记位），寻找 <code>null</code> 标记位</li><li>当找到 <code>null</code> 标记位后，以此标记位为起点，检查 <code>LayoutItem</code> 的 <code>w</code> 和 <code>h</code> 占位情况（以标记位为起点向右下检查 <code>LayoutItem</code> 的 <code>w</code> 和 <code>h</code> 长度，不能越界）</li><li>若均为 <code>null</code> 则更新标记空间，并更新 <code>LayoutItem</code> 的 <code>x</code> 和 <code>y</code> 为当前标记位起点，同时更新 <code>y</code> 标识为当前标记位起点 <code>y</code> 与 <code>LayoutItem</code> 的 <code>h</code> 的和，中断此次标记位遍历，进入下一个 <code>LayoutItem</code> 遍历</li><li>反之寻找下一个 <code>null</code> 标记位起点</li></ol><p>至此，已实现更新 <code>x</code> 和 <code>y</code> 位置，接下来结合标记空间来计算 <code>LayoutItem</code> 的格间间距。</p><ol><li>遍历标记空间 4 条边，记录占用 <code>LayoutItem</code> 信息</li><li>依次遍历 <code>LayoutItem</code> 并初始化对应的格间间距，左右上下为 8px</li><li>检查占用信息，对 4 条边存在占用的方向格间间距设置为 0</li><li>更新格间间距至对应的 <code>LayoutItem</code></li></ol><h3 id="辅助功能"><a href="#辅助功能" class="headerlink" title="辅助功能"></a>辅助功能</h3><ol><li>组件选中框跟随组件一起移动</li><li>计算组件预计落点位置阴影</li><li>动态替换</li></ol>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Lowcode" scheme="https://zongzi531.github.io/categories/Lowcode/"/>
    
    
    <category term="lowcode" scheme="https://zongzi531.github.io/tags/lowcode/"/>
    
    <category term="低代码" scheme="https://zongzi531.github.io/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"/>
    
    <category term="grid" scheme="https://zongzi531.github.io/tags/grid/"/>
    
    <category term="layout" scheme="https://zongzi531.github.io/tags/layout/"/>
    
    <category term="rules" scheme="https://zongzi531.github.io/tags/rules/"/>
    
  </entry>
  
  <entry>
    <title>RAG 生态探索</title>
    <link href="https://zongzi531.github.io/2024/09/01/rag%E7%94%9F%E6%80%81%E6%8E%A2%E7%B4%A2/"/>
    <id>https://zongzi531.github.io/2024/09/01/rag%E7%94%9F%E6%80%81%E6%8E%A2%E7%B4%A2/</id>
    <published>2024-09-01T09:19:39.000Z</published>
    <updated>2024-09-01T09:19:39.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>在对 RAG 有了简单认识之后，基于一些业务的场景，对 RAG 生态进行了一些探索。</p><p>网上有一张 RAG 生态的概括图，我认为不错。</p><p><img src="/2024/09/01/rag%E7%94%9F%E6%80%81%E6%8E%A2%E7%B4%A2/rag-eco.png" alt="rag-ecosystem"></p><h2 id="图谱"><a href="#图谱" class="headerlink" title="图谱"></a>图谱</h2><p>在 RAG 工作流中，考虑通过图谱的概念，生成更全面的一些信息以提升问答的功能。</p><p>尝试微软开源的 GraphRAG 对文本（大文本、多文本）提取实体、关系，以在问答环节可以尝试一些逻辑或者总结性的路由流程。</p><p>图谱相较于切片，具有更强的逻辑性，并且信息链更为清晰，而切片却有冗余以及无法多内容关联的问题。</p><p>当然了，也可以使用支持大 tokens 的 LLM 进行总结或其他动作，只不过这样会重复的消耗大 tokens ，从资源层面是浪费的。</p><p>以下是 GraphRAG 索引步骤：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">⠋ GraphRAG Indexer ├── Loading Input <span class="token punctuation">(</span>text<span class="token punctuation">)</span>├── create_base_text_units├── create_base_extracted_entities├── create_final_covariates├── create_summarized_entities├── join_text_units_to_covariate_ids├── create_base_entity_graph├── create_final_entities├── create_final_nodes├── create_final_communities├── join_text_units_to_entity_ids├── create_final_relationships├── join_text_units_to_relationship_ids├── create_final_community_reports├── create_final_text_units├── create_base_documents└── create_final_documents🚀 All workflows completed successfully.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目前， GraphRAG 对不同类型的文档进行索引时，需要人为为工具提供实体类型（考虑是不是能由 LLM 代替），以在索引时能够更好的分析提取实体和其之间的关系。</p><p>所以如果需要接入到现有的 RAG 流程，需要 Python 编程调整各节点逻辑，以适配 RAG 流程。</p><p>视觉效果：</p><p><img src="https://github.com/zongzi531/modular-rag/blob/main/index/graphrag/images/graph_example.png?raw=true" alt="graph_example"></p><blockquote><p>详细可<a href="https://github.com/zongzi531/modular-rag/blob/main/index/graphrag/README.md">查看</a></p></blockquote><h2 id="微调-Embeddings-模型尝试"><a href="#微调-Embeddings-模型尝试" class="headerlink" title="微调 Embeddings 模型尝试"></a>微调 Embeddings 模型尝试</h2><p>使用 <code>uniem</code> 工具对模型进行微调，分别尝试过对 <code>small</code> 、 <code>base</code> 、 <code>large</code> 进行不同的微调对比，可能是数据集选用的关系，效果并不是特别理想，并且在大数据集的微调场景下，微调时间较长，成本较大，所以暂缓。</p><p>最后直接选用 <code>bge-large-zh-v1.5</code> 为本地 Embeddings 模型。</p><h2 id="评测"><a href="#评测" class="headerlink" title="评测"></a>评测</h2><p>使用 Ragas 工具进行 RAG 流程评测。在使用此工具前，采用人工测试集进行评测，并且评测维度较为主观。</p><p>需要注意 ⚠️ ：在测试集生成和评测阶段，会大量消耗 LLM tokens ，请合理选择需要评测指标。</p><h3 id="评测指标"><a href="#评测指标" class="headerlink" title="评测指标"></a>评测指标</h3><table><thead><tr><th>指标名称</th><th>范围</th><th>含义</th></tr></thead><tbody><tr><td><code>context_precision</code> 上下文精度</td><td>(0,1)</td><td>值越大，表示 <code>ground_truth</code> 与 <code>contexts</code> 越相关。</td></tr><tr><td><code>faithfulness</code> 忠诚度&#x2F;可信度</td><td>(0,1)</td><td>由 <code>answer</code> 与 <code>contexts</code> 计算得出，值越大，表示 <code>answer</code> 更可信。</td></tr><tr><td><code>answer_relevancy</code> 答案相关性</td><td>(-1,1)</td><td>由 <code>answer</code> 、 <code>contexts</code> 与 <code>question</code> 计算得出，值越大，表示 <code>answer</code> 的相关性较好。</td></tr><tr><td><code>context_recall</code> 上下文召回</td><td>(0,1)</td><td>通过对 <code>ground_truth</code> 进行分解以验证是否可以归因于 <code>contexts</code> ，值越大，表示性能越好（避免反复尝试）。</td></tr><tr><td><code>context_entity_recall</code> 上下文实体召回</td><td>(0,1)</td><td>分别计算 <code>ground_truth</code> 和 <code>contexts</code> 的实体，使用其实体进行召回，值越大，表示性能越好（避免反复尝试）。</td></tr><tr><td><code>answer_similarity</code> 答案语义相似度</td><td>(0,1)</td><td>由 <code>answer</code> 与 <code>ground_truth</code> 计算得出，值越大，表示 <code>answer</code> 与 <code>ground_truth</code> 更相似。</td></tr><tr><td><code>answer_correctness</code> 答案正确性</td><td>(0,1)</td><td>由 <code>answer</code> 与 <code>ground_truth</code> 计算得出，值越大，表示 <code>answer</code> 与 <code>ground_truth</code> 一致性越高。</td></tr><tr><td><code>AspectCritique</code> 方面批评</td><td>-</td><td>用于评测 <code>answer</code> 的内容是否包含评测「方面」的内容，如有害性、恶意性、连贯性、正确性、简洁性</td></tr><tr><td><code>summarization_score</code> 总结分数</td><td>-</td><td>-</td></tr></tbody></table><hr><p>所以在不考虑 LLM tokens 的情况下，可以利用自动化评测工具来优化现在有的 RAG 应用，不限于 RAG 流程、Prompt 工程等，相较于人工测试集，可以说效率大大提升。</p><blockquote><p>详细可<a href="https://github.com/zongzi531/modular-rag/tree/main/evaluation/ragas">查看</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/tags/Blog/"/>
    
    <category term="RAG" scheme="https://zongzi531.github.io/tags/RAG/"/>
    
    <category term="GraphRAG" scheme="https://zongzi531.github.io/tags/GraphRAG/"/>
    
    <category term="Fine-tuning" scheme="https://zongzi531.github.io/tags/Fine-tuning/"/>
    
    <category term="Ragas" scheme="https://zongzi531.github.io/tags/Ragas/"/>
    
  </entry>
  
  <entry>
    <title>初识 RAG</title>
    <link href="https://zongzi531.github.io/2024/08/01/%E5%88%9D%E8%AF%86rag/"/>
    <id>https://zongzi531.github.io/2024/08/01/%E5%88%9D%E8%AF%86rag/</id>
    <published>2024-08-01T08:39:09.000Z</published>
    <updated>2024-08-01T08:39:09.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>继上个月对 Sentence Transformers 框架下的 embedding 模型有了简单的尝试和使用后，现在对 RAG 有了简单的认识。</p><p>用一张图来解释最为合适不过了。</p><p><img src="/2024/08/01/%E5%88%9D%E8%AF%86rag/C1-2-RAG.png" alt="rag"></p><blockquote><p>图片来自 <a href="https://github.com/datawhalechina/llm-universe">llm-universe</a></p></blockquote><p>关于什么是 RAG 这里就不多做介绍了，其实回顾下来，可以发现 RAG 的流程中，还有很多的优化点，可以更好的优化 LLM 在回答问题过程中的幻觉问题。</p><p>例如：</p><ul><li>文件在解析过程中的清洗操作，包括不限于对不同类型的文件进行特殊处理，对图片视频音频等媒体资源进行识别转文字或向量化。</li><li>知识库场景下，对单文件整篇进行总结、多文件集合总结。</li></ul><blockquote><p>以上优化目的在于尽可能产生多的向量可能与 Query 进行匹配，丰富进入 LLM 时生成 prompt 的内容。</p></blockquote><ul><li>Query 也可以在向量化前，经过 LLM 生成相似的 Query 生成多个向量进行查询匹配的优化逻辑。</li><li>知识库场景下，对存在的数据进行自动化知识图谱生成，并且优化 Query 的向量化流程，以能够更好的匹配到问题的领域，避免越界的同类词汇出现的问题。</li><li>Query 的 Chat 场景对一些模糊内容可以提供一些交互式的引导，来辅助问答。</li></ul><p>我们也在尝试着使用 RAG 来研发一个新型的知识库，解决传统知识库需要问题内容强匹配的问题，期望提供一个更易用的知识库。</p><p>其实 RAG 完全不限于知识库的场景。</p><p>在辅助编程领域，可以结合自身的代码合集进行更精准的推荐，也可以避免一些技术过时的问题，等等。</p><p>同样的，在办公领域，可以结合自身的业务领域，实现类似自动生成 Word 、 PPT 、PDF 等文件。</p><p>总之，可以让 LLM 的回答更实时、更准确、更专业。</p><p>回过来想一下， RAG 其实也会演变成一个基座，在此基座上衍生产品。</p><p>比较疑惑的点是，目前对 LLM 了解的并不充分，可以明白 LLM 对自然语言的理解还不错，但是对一些数理化的内容，似乎并不擅长，是不是在 LLM 的过程中引导进行推理可以提升准确率呢……</p><p>所以 RAG 之路，还很长……</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/tags/Blog/"/>
    
    <category term="RAG" scheme="https://zongzi531.github.io/tags/RAG/"/>
    
  </entry>
  
  <entry>
    <title>Sentence Transformers 使用介绍</title>
    <link href="https://zongzi531.github.io/2024/07/05/sentence-transformer%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>https://zongzi531.github.io/2024/07/05/sentence-transformer%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</id>
    <published>2024-07-05T09:17:30.000Z</published>
    <updated>2024-07-05T09:17:30.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><blockquote><p>官网 <a href="https://www.sbert.net/index.html">SBERT.net</a></p></blockquote><p>有关于 Sentence Transformers 是什么，其官网都有介绍，那本篇博客将简单介绍此框架该如何使用。</p><p>Sentence Transformers 框架支持直接使用模型，也就是 <strong>Inference</strong> 。</p><p>另外可以使用此框架对模型进行微调（<strong>fine-tuning</strong>），从而训练（<strong>Training</strong>）属于自己的模型，当然我目前还没操作过。</p><p>安装教程请参照官网，这里接直接进入使用阶段。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 引用框架及工具</span><span class="token keyword">from</span> sentence_transformers <span class="token keyword">import</span> SentenceTransformer<span class="token punctuation">,</span> util<span class="token comment"># 设置一些语句用于匹配</span>sentences <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"That is a happy dog"</span><span class="token punctuation">,</span> <span class="token string">"That is a very happy person"</span><span class="token punctuation">,</span> <span class="token string">"Today is a sunny day"</span><span class="token punctuation">]</span><span class="token comment"># 加载模型，这里使用的是官方模型，首次运行程序会从官网下载</span>model <span class="token operator">=</span> SentenceTransformer<span class="token punctuation">(</span><span class="token string">'sentence-transformers/all-MiniLM-L6-v2'</span><span class="token punctuation">)</span><span class="token comment"># 这是我想进行匹配的语句，从上面设置的语句中寻找最相似的</span>question <span class="token operator">=</span> <span class="token string">"That is a happy person"</span><span class="token comment"># 先将我想匹配的语句解析成向量数据</span>question_embeddings <span class="token operator">=</span> model<span class="token punctuation">.</span>encode<span class="token punctuation">(</span>question<span class="token punctuation">)</span><span class="token comment"># 可以尝试打印出来看一下</span><span class="token comment"># print(question_embeddings)</span><span class="token comment"># 可以打印该向量数据的维度</span><span class="token comment"># print(question_embeddings.shape)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"question is: &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>question<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> sentence <span class="token keyword">in</span> sentences<span class="token punctuation">:</span>  <span class="token comment"># 对上面设置的语句们，解析成向量数据</span>  embeddings <span class="token operator">=</span> model<span class="token punctuation">.</span>encode<span class="token punctuation">(</span>sentence<span class="token punctuation">)</span>  <span class="token comment"># 使用官方提供的数据计算两个向量的相似度</span>  sym <span class="token operator">=</span> <span class="token builtin">round</span><span class="token punctuation">(</span><span class="token builtin">float</span><span class="token punctuation">(</span>util<span class="token punctuation">.</span>pytorch_cos_sim<span class="token punctuation">(</span>question_embeddings<span class="token punctuation">,</span> embeddings<span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125; -> &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>sentence<span class="token punctuation">,</span> sym<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行这段 Python 脚本可以看到如下输出结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">question is: That is a happy personThat is a happy dog -<span class="token operator">></span> <span class="token number">0.69458</span>That is a very happy person -<span class="token operator">></span> <span class="token number">0.94292</span>Today is a sunny day -<span class="token operator">></span> <span class="token number">0.25688</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>看效果还不错吧，这时候是不是想试试看中文。我们可以使用官网 <a href="https://www.sbert.net/docs/sentence_transformer/pretrained_models.html#multilingual-models">Multilingual Models</a> 下的官方模型使用。</p><p>对中文都有所支持，我们调整一下 <code>sentences</code> 和 <code>question</code> 的内容，我这边使用的是 <code>distiluse-base-multilingual-cased-v1</code> 模型来运行，我们来看一下运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">question is: 我喜欢吃苹果我喜欢吃香蕉 -<span class="token operator">></span> <span class="token number">0.79271</span>我最喜欢苹果 -<span class="token operator">></span> <span class="token number">0.91433</span>今天买了一个苹果 -<span class="token operator">></span> <span class="token number">0.61951</span>我拥有一个苹果 -<span class="token operator">></span> <span class="token number">0.71284</span>儿子喜欢吃苹果 -<span class="token operator">></span> <span class="token number">0.73278</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到这个输出值，让人有点感觉“舒适”，在这个结果上，我们调整一下问题，在问题上加一个 <code>不</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">question is: 我不喜欢吃苹果我喜欢吃香蕉 -<span class="token operator">></span> <span class="token number">0.69195</span>我最喜欢苹果 -<span class="token operator">></span> <span class="token number">0.82793</span>今天买了一个苹果 -<span class="token operator">></span> <span class="token number">0.58365</span>我拥有一个苹果 -<span class="token operator">></span> <span class="token number">0.64693</span>儿子喜欢吃苹果 -<span class="token operator">></span> <span class="token number">0.674</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以要想提升这个准确度，可能就是需要我们自己对模型进的微调了吧……</p><p>当然其实也可以借助大语言模型对整个工作流进行优化，以约束这里匹配出来的结果。</p><p>官网也有一个示例集 <a href="https://github.com/UKPLab/sentence-transformers/blob/master/examples">examples</a> ，可以在里面学习不少。</p><p>到这里，其实已经对 Sentence Transformers 框架在 Python 下的使用已经有了一个简单的认识，至于怎么结合自己的工作流，就要看自己的业务场景了。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="NLP" scheme="https://zongzi531.github.io/categories/NLP/"/>
    
    
    <category term="embeddings" scheme="https://zongzi531.github.io/tags/embeddings/"/>
    
    <category term="tutorial" scheme="https://zongzi531.github.io/tags/tutorial/"/>
    
    <category term="framework" scheme="https://zongzi531.github.io/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>原谅别人的错，解脱自己的苦</title>
    <link href="https://zongzi531.github.io/2024/07/01/%E5%8E%9F%E8%B0%85%E5%88%AB%E4%BA%BA%E7%9A%84%E9%94%99%EF%BC%8C%E8%A7%A3%E8%84%B1%E8%87%AA%E5%B7%B1%E7%9A%84%E8%8B%A6/"/>
    <id>https://zongzi531.github.io/2024/07/01/%E5%8E%9F%E8%B0%85%E5%88%AB%E4%BA%BA%E7%9A%84%E9%94%99%EF%BC%8C%E8%A7%A3%E8%84%B1%E8%87%AA%E5%B7%B1%E7%9A%84%E8%8B%A6/</id>
    <published>2024-07-01T09:22:00.000Z</published>
    <updated>2024-07-01T09:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>嘿，这个月基本就是在写业务，有空出来的时间学习了一下 embedding 相关的内容，虽然对其实现可以说是一无所知，但是对怎么使用有了一些浅显的理解（包括 Python 开发）。</p><p>可以想象一些应用场景吧。</p><p>对了，还因为紧急情况，写了一个 shell 脚本，用于运维部署（真好家伙，啥都干啊）。</p><p>另外，有什么境外旅游推荐么，悠闲的那种，非特种兵，非网红打卡。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Here We Go!</title>
    <link href="https://zongzi531.github.io/2024/06/01/here-we-go/"/>
    <id>https://zongzi531.github.io/2024/06/01/here-we-go/</id>
    <published>2024-06-01T13:36:33.000Z</published>
    <updated>2024-06-01T13:36:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>周末去了一趟 USJ ，对马里奥园区还是很满意的，非常 Nice ，好玩！</p><p>哈利波特园区的项目也不错，其他的项目中规中矩吧～</p><p>还是东迪情绪给得到位，当然马里奥园区也不差。</p><p>这个月中规中矩吧，VSCode 插件开发、服务端开发（Node.js&#x2F;Python）。</p><p>简单入门了一下 Python ，因为交接同事的项目里有两个 Python 工具，需要转成服务，那就简单学习了一下 Python 来迁移吧。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>技术慢增长</title>
    <link href="https://zongzi531.github.io/2024/05/01/%E6%8A%80%E6%9C%AF%E6%85%A2%E5%A2%9E%E9%95%BF/"/>
    <id>https://zongzi531.github.io/2024/05/01/%E6%8A%80%E6%9C%AF%E6%85%A2%E5%A2%9E%E9%95%BF/</id>
    <published>2024-05-01T13:07:10.000Z</published>
    <updated>2024-05-01T13:07:10.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>这个月一半是服务端和运维的身份吧，另一半回到了从前的领域，开始接触 VSCode 插件开发，也算是一个分支积累吧。</p><p>当然了，其实换汤不换药，就是使用编程语言在给定的环境中实现功能罢了。</p><p>说是接触了有小半年服务端的研发及上线，其实最多也就是基本的一些 CRUD 和抽象罢了，以及踩了一些运维的坑。</p><p>深入服务端的路径确实太长，太黑。</p><p>以前想着的深入到 JS 规范中，似乎还是那么的遥远，其实还是缺乏系统性的计算机知识导致的。</p><p>所以，当下一步一个脚印还是没问题的。</p><p>OK，更多的时间还是得交给生活，享受生活～</p><blockquote><p>vscode logo, wallpaper, work space, office, lady –aspect 16:9 –v 6.0</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>赏花</title>
    <link href="https://zongzi531.github.io/2024/04/01/%E8%B5%8F%E8%8A%B1/"/>
    <id>https://zongzi531.github.io/2024/04/01/%E8%B5%8F%E8%8A%B1/</id>
    <published>2024-04-01T13:27:12.000Z</published>
    <updated>2024-04-01T13:27:12.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>这个月依然是服务端身份，已经成功的交付了 Midjourney API 供公司内部使用，并且在公司内部已经开始尝试 AI 辅助编码，感觉公司整体方向已经在往 AI 靠了。</p><p>总结来说就是基本的服务端研发 + 运维，以及 API 代理工程师。</p><p>赏樱的时间到了，本来想着要是能去日本看樱花就好了，但是机票实在是太不实惠了，而且杭州的樱花也好多呢。</p><p>话不多说，来欣赏一下吧～</p><div style="display: grid; grid-template-columns: 1fr 1fr; grid-gap: 16px;">  <img src="pic2.jpg">  <img src="pic3.jpg"></div><p>还去了太子湾欣赏郁金香，也是美美哒～</p><p>一起欣赏一下吧～</p><div style="display: grid; grid-template-columns: 1fr 1fr; grid-gap: 16px;">  <img src="pic4.jpg">  <img src="pic5.jpg"></div><p>一起享受生活吧～哈哈</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>年味鱼灯</title>
    <link href="https://zongzi531.github.io/2024/03/01/%E5%B9%B4%E5%91%B3%E9%B1%BC%E7%81%AF/"/>
    <id>https://zongzi531.github.io/2024/03/01/%E5%B9%B4%E5%91%B3%E9%B1%BC%E7%81%AF/</id>
    <published>2024-03-01T10:13:11.000Z</published>
    <updated>2024-03-01T10:13:11.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>春节过去了，又回归到了工作岗位上。</p><p>今年春节没有安排旅游，原因是发现今年出行的成本较以往变大了，所以暂时不考虑旅游。</p><p>春节假期这么长，考虑周边城市哪里晃一圈。</p><p>感觉现在的年味是没有小的时候那样热闹和开心，所以想着去感受一下其他地方的年味。</p><p>于是前往安徽北岸镇瞻淇村看一下鱼灯，感受下来确实很热闹也有年味。</p><p>和单纯的人多是不一样的感觉，是一种喜庆和开心的感觉，是一种文化的吸收。</p><div style="display: grid; grid-template-columns: 1fr 1fr; grid-gap: 16px;">  <img src="pic2.jpg">  <img src="pic3.jpg"></div><p>回来也发现今年类似于这种非物质文化遗产都慢慢浮现出来，好像大家都开始关注起来了。</p><p>也借机会去逛了一下浙江省非物质文化遗产馆，了解和学习以前留下来的文化。</p><p>这个月呢，主要还是从事后端开发的工作，接触了域名泛解析和 PVUV 相关的研发内容。</p><p>对了，还尝试结合开源的 API 接入 Midjourney 。</p>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>龙行大运</title>
    <link href="https://zongzi531.github.io/2024/02/01/%E9%BE%99%E8%A1%8C%E5%A4%A7%E8%BF%90/"/>
    <id>https://zongzi531.github.io/2024/02/01/%E9%BE%99%E8%A1%8C%E5%A4%A7%E8%BF%90/</id>
    <published>2024-02-01T13:35:11.000Z</published>
    <updated>2024-02-01T13:35:11.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><p>这一年可以说比去年更“精彩”，团队独立后，确实向前迈了一大步，但是由于市场环境的影响，团队最终被解散，部分成员出去成立了子公司，部分成员分布在了公司其他部门，部分成员离开了公司。</p><p>确实也慢慢接受了这些变化，虽然自己是喜欢变化的，但是这个变化确实有点“猛”。</p><p>低代码的业务确实也刚刚进入落地即将闭环的阶段，转而我开始从事基础建设，开始编写 Node.js ，开始尝试做运维的工作。</p><p>当然，这还是能让我从中学习到一些些产品的知识。</p><p>就眼下而已，其实做好手上事，持续积累即可，因为就算焦虑了也没用。</p><p>对了，关于性能优化，今年确实做了比较多的在浏览器上减少 JavaScript 的执行时间的相关优化工作。</p><p>这个月设计了 C2D 和 D2C 的架构，也不知道新年能不能就此有新的进展。</p><h1 id="基础建设"><a href="#基础建设" class="headerlink" title="基础建设"></a>基础建设</h1><ul><li>低代码引擎、低代码产品孵化</li><li>[Unity] <a href="https://github.com/zongzi531/make_fun">make_fun</a></li><li>Node.js 服务端研发</li></ul><h1 id="开源贡献"><a href="#开源贡献" class="headerlink" title="开源贡献"></a>开源贡献</h1><ul><li><p><a href="https://github.com/insightfuls/inquirer-tree-prompt">insightfuls&#x2F;inquirer-tree-prompt</a> <a href="https://github.com/insightfuls/inquirer-tree-prompt/pull/10">#10</a></p></li><li><p><a href="https://github.com/oven-sh/bun">oven-sh&#x2F;bun</a> <a href="https://github.com/oven-sh/bun/pull/5243">#5243</a> <a href="https://github.com/oven-sh/bun/pull/5250">#5250</a> <a href="https://github.com/oven-sh/bun/pull/5451">#5451</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>２０２４年おめでとうございます</title>
    <link href="https://zongzi531.github.io/2024/01/01/%EF%BC%92%EF%BC%90%EF%BC%92%EF%BC%94%E5%B9%B4%E3%81%8A%E3%82%81%E3%81%A7%E3%81%A8%E3%81%86%E3%81%94%E3%81%96%E3%81%84%E3%81%BE%E3%81%99/"/>
    <id>https://zongzi531.github.io/2024/01/01/%EF%BC%92%EF%BC%90%EF%BC%92%EF%BC%94%E5%B9%B4%E3%81%8A%E3%82%81%E3%81%A7%E3%81%A8%E3%81%86%E3%81%94%E3%81%96%E3%81%84%E3%81%BE%E3%81%99/</id>
    <published>2024-01-01T10:51:08.000Z</published>
    <updated>2024-01-01T10:51:08.000Z</updated>
    
    <content type="html"><![CDATA[<!-- no node --><span id="more"></span><h2 id="想先说的话"><a href="#想先说的话" class="headerlink" title="想先说的话"></a>想先说的话</h2><p>很明显大家都能感受到今年的经济很差，最后只能说难，大家都难。</p><p>虽然说开头这么消极，但是我还是对未来有所规划的，至少不能停滞不前吧。</p><p>能确定的大方向即是架构，如果说我想在这个行业继续深耕下去的话，架构是一定的。当然也可能转行咯，关注动态吧。</p><p>现在比较火热的就是 AI 了，人们对 AI 有着很多畅想，并且 AI 领域确实存在着很多机会。</p><p>比较让我没想到的是，下半年的时候部门没了，所以低代码就此应该就打住了。</p><p>Unity 其实在年中的时候也简单学习和把玩了一下，但是考虑到自己起步晚的事，想想还是算了。</p><p>更让我们没想到的是，进入到新部门做公司 UED 的时候，我居然开始写 Node.js 服务端了，还得负责运维的工作。</p><p>新年的工作走向很有可能继续是从事服务端开发的工作，有好有坏吧。</p><p>坏就是，我开始会慢慢脱离前端，在前端领域没办法继续“精”下去，虽然我本来在视觉层也只是皮毛，更擅长一些抽象。</p><p>好就是，我能够接触到服务端的内容，从整体去接触产品，会让走向架构轻松一些。</p><p>这可能会成为我架构方向的一个契机，也可能会成为我学习 Python 的一个契机。</p><p>但是也说不定，就领大礼包了～</p><h2 id="回顾-2023-年"><a href="#回顾-2023-年" class="headerlink" title="回顾 2023 年"></a>回顾 2023 年</h2><ul><li><strong><span class="github-emoji" alias="couplekiss_man_woman" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f469-2764-1f48b-1f468.png?v8">👩️‍❤️‍💋️‍👨</span> 更爱老婆，和她开心幸福在一起</strong></li><li><strong><span class="github-emoji" alias="heartpulse" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f497.png?v8">💗</span> 更爱家人，祝家人身体健康，平平安安</strong></li><li><strong><span class="github-emoji" alias="horse_racing" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f3c7.png?v8">🏇</span> 锻炼身体</strong> <code>适量</code></li><li><del><strong><span class="github-emoji" alias="notebook_with_decorative_cover" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d4.png?v8">📔</span> 日本語学習文法・語彙</strong></del></li><li><strong><span class="github-emoji" alias="books" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4da.png?v8">📚</span> 建立自己的知识体系</strong> <code>持续进行</code></li><li><del><strong>深入 Rust</strong></del></li><li><strong>深入低代码</strong></li><li><strong>性能优化</strong></li><li><strong>初探 Unity</strong></li><li><strong>初探机器学习</strong></li><li><strong>初探服务端 Node.js</strong></li></ul><h2 id="展望-2024-年"><a href="#展望-2024-年" class="headerlink" title="展望 2024 年"></a>展望 2024 年</h2><ul><li><strong><span class="github-emoji" alias="couplekiss_man_woman" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f469-2764-1f48b-1f468.png?v8">👩️‍❤️‍💋️‍👨</span> 更爱老婆，和她开心幸福在一起</strong></li><li><strong><span class="github-emoji" alias="heartpulse" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f497.png?v8">💗</span> 更爱家人，祝家人身体健康，平平安安</strong></li><li><strong><span class="github-emoji" alias="horse_racing" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f3c7.png?v8">🏇</span> 锻炼身体</strong></li><li><strong><span class="github-emoji" alias="books" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4da.png?v8">📚</span> 建立自己的知识体系</strong></li><li><strong>架构</strong></li><li><strong>Python</strong></li><li><strong>机器学习</strong></li></ul>]]></content>
    
    
    <summary type="html">&lt;!-- no node --&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/categories/Blog/"/>
    
    
    <category term="Blog" scheme="https://zongzi531.github.io/tags/Blog/"/>
    
  </entry>
  
</feed>
